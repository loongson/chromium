From 4a986b0f6407ceea2dcdeb2b155a4db8276f9b43 Mon Sep 17 00:00:00 2001
From: Cheng Yangyang <chengyangyang-hf@loongson.cn>
Date: Fri, 26 Apr 2024 16:00:38 +0800
Subject: [PATCH] [CH116][old-world] Add loongarch64 support

---
 .gitignore                                    |    2 +
 base/allocator/partition_allocator/BUILD.gn   |    3 +
 .../partition_allocator/partition_alloc.gni   |    3 +-
 .../stack/asm/loong64/push_registers_asm.cc   |   48 +
 base/debug/elf_reader.cc                      |    9 +
 base/debug/stack_trace.cc                     |    9 -
 base/debug/stack_trace.h                      |   16 +
 base/debug/stack_trace_unittest.cc            |    6 +-
 base/files/file_util_unittest.cc              |    8 +
 base/immediate_crash.h                        |    7 +
 base/immediate_crash_unittest.cc              |   19 +
 base/profiler/register_context.h              |   14 +
 base/profiler/thread_delegate_posix.cc        |    9 +
 base/system/sys_info.cc                       |    2 +
 build/build_config.h                          |    1 +
 build/config/clang/clang.gni                  |    6 +-
 build/config/compiler/BUILD.gn                |   19 +-
 build/config/loongarch64.gni                  |    2 +
 build/config/posix/BUILD.gn                   |    2 +-
 build/config/sysroot.gni                      |    2 +
 build/cross-build.sh                          |   49 +
 build/rust/rust_target.gni                    |    3 +
 chrome/app/chrome_main_delegate.cc            |   59 +
 .../one_time_permission_provider.cc           |    8 +-
 .../bubble/download_bubble_update_service.cc  |    6 +-
 .../runtime/chrome_runtime_api_delegate.cc    |    4 +
 chrome/browser/ui/location_bar/location_bar.h |    3 +
 .../ui/omnibox/chrome_omnibox_client.cc       |    2 +-
 chrome/installer/linux/common/apt.include     |    2 +
 chrome/installer/linux/common/rpm.include     |    2 +-
 .../linux/debian/calculate_package_deps.py    |    3 +
 .../metrics/debug/metrics_internals_utils.cc  |    2 +
 .../core/tflite_model_executor.h              |    2 +-
 components/variations/proto/study.proto       |    2 +
 .../service/variations_field_trial_creator.cc |    2 +
 .../skia_output_surface_impl_on_gpu.cc        |    2 +-
 .../service_worker_context_wrapper.cc         |    6 +-
 ...web_ui_browser_interface_broker_registry.h |    6 +-
 extensions/common/api/runtime.json            |    4 +-
 media/base/cdm_promise_adapter.cc             |    6 +-
 net/dns/host_resolver_cache.h                 |    4 +
 sandbox/features.gni                          |    3 +-
 sandbox/linux/BUILD.gn                        |    1 +
 sandbox/linux/bpf_dsl/linux_syscall_ranges.h  |    7 +
 sandbox/linux/bpf_dsl/seccomp_macros.h        |   42 +
 .../bpf_dsl_seccomp_unittest.cc               |    6 +-
 .../seccomp_broker_process_unittest.cc        |   23 +
 .../seccomp-bpf-helpers/baseline_policy.cc    |   11 +-
 .../baseline_policy_unittest.cc               |   14 +-
 .../seccomp-bpf-helpers/sigsys_handlers.cc    |    3 +
 .../syscall_parameters_restrictions.cc        |    7 +-
 .../linux/seccomp-bpf-helpers/syscall_sets.cc |   63 +-
 .../linux/seccomp-bpf-helpers/syscall_sets.h  |   16 +-
 sandbox/linux/seccomp-bpf/syscall.cc          |   38 +-
 sandbox/linux/seccomp-bpf/syscall_unittest.cc |    2 +
 sandbox/linux/services/credentials.cc         |    2 +-
 sandbox/linux/services/syscall_wrappers.cc    |   69 +-
 sandbox/linux/services/syscall_wrappers.h     |   12 +-
 sandbox/linux/syscall_broker/broker_client.cc |   17 +
 sandbox/linux/syscall_broker/broker_client.h  |    4 +
 sandbox/linux/syscall_broker/broker_command.h |    1 +
 sandbox/linux/syscall_broker/broker_host.cc   |   19 +-
 .../linux/syscall_broker/broker_process.cc    |   21 +-
 .../syscall_broker/broker_process_unittest.cc |    6 +
 .../remote_syscall_arg_handler_unittest.cc    |    4 +
 .../syscall_broker/syscall_dispatcher.cc      |    7 +
 .../linux/syscall_broker/syscall_dispatcher.h |    3 +
 sandbox/linux/system_headers/linux_seccomp.h  |    8 +
 sandbox/linux/system_headers/linux_signal.h   |    5 +-
 sandbox/linux/system_headers/linux_stat.h     |   59 +-
 sandbox/linux/system_headers/linux_syscalls.h |    4 +
 .../system_headers/loong64_linux_syscalls.h   | 1223 ++++++++++
 .../policy/linux/bpf_broker_policy_linux.cc   |    7 +
 .../linux/bpf_cros_amd_gpu_policy_linux.cc    |    2 +-
 sandbox/policy/linux/bpf_gpu_policy_linux.cc  |    2 +-
 .../policy/linux/bpf_network_policy_linux.cc  |    2 +-
 sandbox/policy/linux/sandbox_linux.cc         |    5 +
 skia/BUILD.gn                                 |   42 +
 skia/ext/convolver.cc                         |    6 +
 skia/ext/convolver.h                          |    6 +
 skia/ext/convolver_LSX.cc                     |  522 ++++
 skia/ext/convolver_LSX.h                      |   27 +
 .../parser/html_document_parser_fastpath.cc   |    2 +-
 .../paint/object_paint_properties_sparse.h    |    4 +-
 .../modules/canvas/canvas2d/canvas_style.cc   |    4 +-
 third_party/blink/renderer/platform/BUILD.gn  |    2 +-
 .../renderer/platform/fonts/font_palette.h    |    3 +
 .../platform/fonts/palette_interpolation.cc   |    2 +-
 .../crypto/fipsmodule/rand/getrandom_fillin.h |    2 +
 .../boringssl/src/include/openssl/base.h      |    3 +
 third_party/breakpad/BUILD.gn                 |    2 +
 third_party/breakpad/breakpad/Makefile.am     |    9 +
 third_party/breakpad/breakpad/Makefile.in     |   23 +
 .../breakpad/breakpad/autotools/config.guess  |    3 +
 .../dump_writer_common/raw_context_cpu.h      |    2 +
 .../linux/dump_writer_common/thread_info.cc   |   54 +
 .../linux/dump_writer_common/thread_info.h    |    9 +
 .../dump_writer_common/ucontext_reader.cc     |   43 +
 .../dump_writer_common/ucontext_reader.h      |    3 +
 .../client/linux/handler/exception_handler.cc |   15 +-
 .../client/linux/handler/exception_handler.h  |    3 +-
 .../handler/exception_handler_unittest.cc     |    2 +-
 .../microdump_writer/microdump_writer.cc      |    2 +
 .../microdump_writer_unittest.cc              |   12 +-
 .../minidump_writer/linux_core_dumper.cc      |   22 +-
 .../linux/minidump_writer/linux_dumper.h      |    3 +-
 .../linux_dumper_unittest_helper.cc           |    3 +
 .../minidump_writer/linux_ptrace_dumper.cc    |   18 +
 .../linux_ptrace_dumper_unittest.cc           |   14 +
 .../linux/minidump_writer/minidump_writer.cc  |    4 +-
 .../linux/minidump_writer/minidump_writer.h   |    4 +-
 .../minidump_writer_unittest.cc               |    3 +
 .../src/common/dwarf_cfi_to_module.cc         |   17 +
 .../breakpad/src/common/dwarf_cfi_to_module.h |    3 +
 .../src/common/linux/breakpad_getcontext.S    |   63 +-
 .../linux/breakpad_getcontext_unittest.cc     |   11 +
 .../breakpad/src/common/linux/dump_symbols.cc |    9 +
 .../src/common/linux/memory_mapped_file.cc    |    3 +-
 .../linux/memory_mapped_file_unittest.cc      |    6 +-
 .../src/common/linux/ucontext_constants.h     |   15 +
 .../src/common/memory_allocator_unittest.cc   |    8 +-
 .../google_breakpad/common/minidump_format.h  |    2 +
 .../google_breakpad/processor/dump_context.h  |    3 +
 .../src/google_breakpad/processor/microdump.h |    1 +
 .../processor/stack_frame_cpu.h               |   63 +
 .../breakpad/src/processor/dump_context.cc    |   47 +
 .../src/processor/exploitability_unittest.cc  |    4 +
 .../breakpad/src/processor/microdump.cc       |   16 +
 .../breakpad/src/processor/minidump.cc        |   61 +
 .../src/processor/minidump_processor.cc       |    5 +
 .../breakpad/src/processor/stackwalker.cc     |    8 +
 .../tools/linux/md2core/minidump-2-core.cc    |   33 +-
 .../client/crashpad_client_linux_test.cc      |    3 +-
 .../crashpad/crashpad/compat/non_win/winnt.h  |    1 +
 .../crashpad/minidump/minidump_context.h      |   53 +
 .../minidump/minidump_context_writer.cc       |   44 +
 .../minidump/minidump_context_writer.h        |   40 +
 .../crashpad/minidump/minidump_extensions.h   |    1 +
 .../minidump/minidump_misc_info_writer.cc     |    2 +
 .../minidump/minidump_system_info_writer.cc   |    3 +
 .../crashpad/snapshot/capture_memory.cc       |    4 +
 .../crashpad/snapshot/cpu_architecture.h      |    5 +-
 .../crashpad/crashpad/snapshot/cpu_context.cc |    6 +
 .../crashpad/crashpad/snapshot/cpu_context.h  |   19 +
 .../crashpad/snapshot/elf/elf_image_reader.cc |   14 +-
 .../snapshot/elf/elf_symbol_table_reader.cc   |   26 +-
 .../snapshot/linux/cpu_context_linux.cc       |   17 +
 .../snapshot/linux/cpu_context_linux.h        |   18 +-
 .../linux/exception_snapshot_linux.cc         |   59 +
 .../snapshot/linux/exception_snapshot_linux.h |    2 +
 .../linux/exception_snapshot_linux_test.cc    |   20 +
 .../snapshot/linux/process_reader_linux.cc    |    2 +
 .../crashpad/snapshot/linux/signal_context.h  |   56 +
 .../snapshot/linux/system_snapshot_linux.cc   |    9 +
 .../crashpad/snapshot/linux/test_modules.cc   |    2 +
 .../snapshot/linux/thread_snapshot_linux.cc   |    7 +
 .../snapshot/linux/thread_snapshot_linux.h    |    2 +
 .../minidump/minidump_context_converter.cc    |   24 +
 .../minidump/system_snapshot_minidump.cc      |    2 +
 .../crashpad/crashpad/test/linux/get_tls.cc   |    3 +
 .../crashpad/test/multiprocess_posix.cc       |    3 +-
 .../crashpad/crashpad/util/linux/ptracer.cc   |   42 +
 .../crashpad/util/linux/thread_info.h         |   18 +-
 .../util/misc/capture_context_linux.S         |   50 +-
 .../misc/capture_context_test_util_linux.cc   |    6 +
 .../util/net/http_transport_libcurl.cc        |    2 +
 third_party/ffmpeg/BUILD.gn                   |    4 +
 .../config/Chrome/linux/loong64/config.h      |  750 ++++++
 .../Chrome/linux/loong64/config_components.h  | 2155 +++++++++++++++++
 .../linux/loong64/libavcodec/bsf_list.c       |    2 +
 .../linux/loong64/libavcodec/codec_list.c     |   20 +
 .../linux/loong64/libavcodec/parser_list.c    |   11 +
 .../linux/loong64/libavformat/demuxer_list.c  |    9 +
 .../linux/loong64/libavformat/muxer_list.c    |    2 +
 .../linux/loong64/libavformat/protocol_list.c |    2 +
 .../Chrome/linux/loong64/libavutil/avconfig.h |    6 +
 .../linux/loong64/libavutil/ffversion.h       |    5 +
 .../ffmpeg/chromium/scripts/build_ffmpeg.py   |   24 +-
 .../ffmpeg/chromium/scripts/copy_config.sh    |    2 +-
 .../ffmpeg/chromium/scripts/generate_gn.py    |    2 +-
 third_party/ffmpeg/ffmpeg_generated.gni       |   34 +
 .../libvpx/source/libvpx/test/predict_test.cc |    8 +
 .../libvpx/test/test_intra_pred_speed.cc      |    9 +
 .../source/libvpx/test/vp9_intrapred_test.cc  |    9 +
 .../source/libvpx/test/vp9_quantize_test.cc   |   14 +-
 .../vp8/common/loongarch/sixtap_filter_lsx.c  |   23 +-
 .../libvpx/vpx_dsp/loongarch/quantize_lsx.c   |   25 +-
 third_party/libyuv/BUILD.gn                   |   48 +-
 .../libyuv/include/libyuv/rotate_row.h        |    2 +-
 third_party/libyuv/include/libyuv/row.h       |   22 +-
 third_party/libyuv/include/libyuv/scale_row.h |    2 +-
 third_party/libyuv/libyuv.gni                 |    7 +-
 third_party/libyuv/source/convert_argb.cc     |   24 +
 third_party/libyuv/source/cpu_id.cc           |   22 +
 third_party/libyuv/source/scale_argb.cc       |    8 +
 third_party/lss/linux_syscall_support.h       |   71 +-
 .../protobuf/src/google/protobuf/port_def.inc |    2 +-
 third_party/skia/BUILD.gn                     |   19 +
 third_party/skia/gn/opts.gni                  |    2 +
 third_party/skia/gn/shared_sources.gni        |    2 +
 third_party/skia/include/core/SkColor.h       |    4 +
 .../skia/include/private/base/SkFeatures.h    |   17 +
 third_party/skia/modules/skcms/skcms.cc       |    2 +
 .../skia/modules/skcms/src/Transform_inl.h    |   60 +-
 third_party/skia/src/base/SkVx.h              |   75 +-
 third_party/skia/src/core/SkBlitRow_D32.cpp   |  137 ++
 .../skia/src/core/SkBlitter_ARGB32.cpp        |  361 +++
 third_party/skia/src/core/SkCpu.cpp           |   37 +
 third_party/skia/src/core/SkCpu.h             |   14 +
 third_party/skia/src/core/SkOpts.cpp          |   10 +
 third_party/skia/src/core/SkRasterPipeline.h  |    2 +-
 .../imagefilters/SkBlurImageFilter.cpp        |   77 +
 .../skia/src/opts/SkBitmapProcState_opts.h    |  217 ++
 third_party/skia/src/opts/SkBlitRow_opts.h    |   35 +
 third_party/skia/src/opts/SkOpts_lasx.cpp     |   48 +
 .../skia/src/opts/SkRasterPipeline_opts.h     |  558 ++++-
 third_party/skia/src/opts/SkSwizzler_opts.h   |  293 +++
 .../src/Reactor/SubzeroReactor.cpp            |    4 +
 .../third_party/llvm-10.0/BUILD.gn            |    2 +
 ui/base/wayland/color_manager_util.h          |  136 +-
 ui/gfx/linux/drm_util_linux.cc                |    7 +
 221 files changed, 9053 insertions(+), 293 deletions(-)
 create mode 100644 .gitignore
 create mode 100644 base/allocator/partition_allocator/starscan/stack/asm/loong64/push_registers_asm.cc
 create mode 100755 build/cross-build.sh
 create mode 100644 sandbox/linux/system_headers/loong64_linux_syscalls.h
 create mode 100644 skia/ext/convolver_LSX.cc
 create mode 100644 skia/ext/convolver_LSX.h
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config.h
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config_components.h
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/bsf_list.c
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/codec_list.c
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/parser_list.c
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/demuxer_list.c
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/muxer_list.c
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/protocol_list.c
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/avconfig.h
 create mode 100644 third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/ffversion.h
 create mode 100644 third_party/skia/src/opts/SkOpts_lasx.cpp

diff --git a/.gitignore b/.gitignore
new file mode 100644
index 0000000000..c4884ada30
--- /dev/null
+++ b/.gitignore
@@ -0,0 +1,2 @@
+/out*/
+*.pyc
diff --git a/base/allocator/partition_allocator/BUILD.gn b/base/allocator/partition_allocator/BUILD.gn
index 189069bdc7..d152d09631 100644
--- a/base/allocator/partition_allocator/BUILD.gn
+++ b/base/allocator/partition_allocator/BUILD.gn
@@ -317,6 +317,9 @@ component("partition_alloc") {
     } else if (current_cpu == "arm64") {
       assert(pcscan_stack_supported)
       sources += [ "starscan/stack/asm/arm64/push_registers_asm.cc" ]
+    } else if (current_cpu == "loong64") {
+      assert(pcscan_stack_supported)
+      sources += [ "starscan/stack/asm/loong64/push_registers_asm.cc" ]
     } else {
       # To support a trampoline for another arch, please refer to v8/src/heap/base.
       assert(!pcscan_stack_supported)
diff --git a/base/allocator/partition_allocator/partition_alloc.gni b/base/allocator/partition_allocator/partition_alloc.gni
index 7334337934..8d733a86fd 100644
--- a/base/allocator/partition_allocator/partition_alloc.gni
+++ b/base/allocator/partition_allocator/partition_alloc.gni
@@ -202,7 +202,8 @@ use_starscan = build_with_chromium && has_64_bit_pointers
 
 pcscan_stack_supported =
     use_starscan && (current_cpu == "x64" || current_cpu == "x86" ||
-                     current_cpu == "arm" || current_cpu == "arm64")
+                     current_cpu == "arm" || current_cpu == "arm64" ||
+                     current_cpu == "loong64")
 
 # We want to provide assertions that guard against inconsistent build
 # args, but there is no point in having them fire if we're not building
diff --git a/base/allocator/partition_allocator/starscan/stack/asm/loong64/push_registers_asm.cc b/base/allocator/partition_allocator/starscan/stack/asm/loong64/push_registers_asm.cc
new file mode 100644
index 0000000000..6e6607e20d
--- /dev/null
+++ b/base/allocator/partition_allocator/starscan/stack/asm/loong64/push_registers_asm.cc
@@ -0,0 +1,48 @@
+// Copyright 2024 The Chromium Authors
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+// Push all callee-saved registers to get them on the stack for conservative
+// stack scanning.
+//
+// See asm/x64/push_registers_asm.cc for why the function is not generated
+// using clang.
+//
+// Calling convention source:
+// https://loongson.github.io/LoongArch-Documentation/LoongArch-ELF-ABI-EN.html
+// Table 1 & Table 2
+asm(".global PAPushAllRegistersAndIterateStack            \n"
+    ".type PAPushAllRegistersAndIterateStack, %function   \n"
+    ".hidden PAPushAllRegistersAndIterateStack            \n"
+    "PAPushAllRegistersAndIterateStack:                   \n"
+    // Push all callee-saved registers and save return address.
+    "  addi.d $sp, $sp, -96                               \n"
+    "  st.d $s8, $sp, 88                                  \n"
+    "  st.d $s7, $sp, 80                                  \n"
+    "  st.d $s6, $sp, 72                                  \n"
+    "  st.d $s5, $sp, 64                                  \n"
+    "  st.d $s4, $sp, 56                                  \n"
+    "  st.d $s3, $sp, 48                                  \n"
+    "  st.d $s2, $sp, 40                                  \n"
+    "  st.d $s1, $sp, 32                                  \n"
+    "  st.d $s0, $sp, 24                                  \n"
+    "  st.d $fp, $sp, 16                                  \n"
+    "  st.d $sp, $sp,  8                                  \n"
+    "  st.d $ra, $sp,  0                                  \n"
+    // Maintain frame pointer.
+    "  addi.d $fp, $sp, 0                                 \n"
+    // Pass 1st parameter (a0) unchanged (Stack*).
+    // Pass 2nd parameter (a1) unchanged (StackVisitor*).
+    // Save 3rd parameter (a2; IterateStackCallback).
+    "  addi.d $t7, $a2, 0                                 \n"
+    // Call the callback.
+    // Pass 3rd parameter as sp (stack pointer).
+    "  addi.d $a2, $sp, 0                                 \n"
+    "  jirl $ra, $t7, 0                                   \n"
+    // Load return address.
+    "  ld.d $ra, $sp, 0                                   \n"
+    // Restore frame pointer.
+    "  ld.d $fp, $sp, 16                                  \n"
+    // Discard all callee-saved registers.
+    "  addi.d $sp, $sp, 96                                \n"
+    "  jirl $zero, $ra, 0                                 \n");
diff --git a/base/debug/elf_reader.cc b/base/debug/elf_reader.cc
index 0fa0b6bc4a..849a6c24c4 100644
--- a/base/debug/elf_reader.cc
+++ b/base/debug/elf_reader.cc
@@ -150,6 +150,15 @@ absl::optional<StringPiece> ReadElfLibraryName(const void* elf_mapped_base) {
         // Fuchsia and Android do not relocate the symtab pointer on ELF load.
         strtab_addr = static_cast<size_t>(dynamic_iter->d_un.d_ptr) +
                       reinterpret_cast<const char*>(relocation_offset);
+#elif defined(LOONGARCH_IS_LEGACY)
+        // TODO(loongarch): Recheck this info, and find out why.
+        // OW loongarch64 sometimes doesn't relocate the symtab pointer?
+        if (static_cast<size_t>(dynamic_iter->d_un.d_ptr) > relocation_offset) {
+            strtab_addr = reinterpret_cast<const char*>(dynamic_iter->d_un.d_ptr);
+        } else {
+            strtab_addr = static_cast<size_t>(dynamic_iter->d_un.d_ptr) +
+                      reinterpret_cast<const char*>(relocation_offset);
+        }
 #else
         strtab_addr = reinterpret_cast<const char*>(dynamic_iter->d_un.d_ptr);
 #endif
diff --git a/base/debug/stack_trace.cc b/base/debug/stack_trace.cc
index 3debc8bd07..4a0455373b 100644
--- a/base/debug/stack_trace.cc
+++ b/base/debug/stack_trace.cc
@@ -40,15 +40,6 @@ namespace {
 
 #if BUILDFLAG(CAN_UNWIND_WITH_FRAME_POINTERS)
 
-#if defined(__arm__) && defined(__GNUC__) && !defined(__clang__)
-// GCC and LLVM generate slightly different frames on ARM, see
-// https://llvm.org/bugs/show_bug.cgi?id=18505 - LLVM generates
-// x86-compatible frame, while GCC needs adjustment.
-constexpr size_t kStackFrameAdjustment = sizeof(uintptr_t);
-#else
-constexpr size_t kStackFrameAdjustment = 0;
-#endif
-
 // On Arm-v8.3+ systems with pointer authentication codes (PAC), signature bits
 // are set in the top bits of the pointer, which confuses test assertions.
 // Because the signature size can vary based on the system configuration, use
diff --git a/base/debug/stack_trace.h b/base/debug/stack_trace.h
index ef4a1c6659..afb0b65a1f 100644
--- a/base/debug/stack_trace.h
+++ b/base/debug/stack_trace.h
@@ -149,6 +149,22 @@ BASE_EXPORT size_t CollectStackTrace(void** trace, size_t count);
 
 #if BUILDFLAG(CAN_UNWIND_WITH_FRAME_POINTERS)
 
+#if defined(__arm__) && defined(__GNUC__) && !defined(__clang__)
+// GCC and LLVM generate slightly different frames on ARM, see
+// https://llvm.org/bugs/show_bug.cgi?id=18505 - LLVM generates
+// x86-compatible frame, while GCC needs adjustment.
+constexpr size_t kStackFrameAdjustment = sizeof(uintptr_t);
+#elif defined(ARCH_CPU_LOONGARCH64)
+// Stack frame layout differ on LoongArch64:
+// +32 ...                      <- frame pointer set to here
+// +24 return address (ra)
+// +16 saved frame pointer (fp)
+// +8  ...
+constexpr size_t kStackFrameAdjustment = 2 * sizeof(uintptr_t);
+#else
+constexpr size_t kStackFrameAdjustment = 0;
+#endif
+
 // For stack scanning to be efficient it's very important for the thread to
 // be started by Chrome. In that case we naturally terminate unwinding once
 // we reach the origin of the stack (i.e. GetStackEnd()). If the thread is
diff --git a/base/debug/stack_trace_unittest.cc b/base/debug/stack_trace_unittest.cc
index 4759f27918..ad02cc1574 100644
--- a/base/debug/stack_trace_unittest.cc
+++ b/base/debug/stack_trace_unittest.cc
@@ -271,7 +271,7 @@ NOINLINE static std::unique_ptr<StackBuffer> CopyCurrentStackAndRewritePointers(
     uintptr_t* out_fp,
     uintptr_t* stack_end) {
   const uint8_t* fp =
-      reinterpret_cast<const uint8_t*>(__builtin_frame_address(0));
+      reinterpret_cast<const uint8_t*>(__builtin_frame_address(0)) - kStackFrameAdjustment;
   uintptr_t original_stack_end = GetStackEnd();
   size_t stack_size = original_stack_end - reinterpret_cast<uintptr_t>(fp);
   auto buffer = std::make_unique<StackBuffer>(stack_size);
@@ -377,7 +377,7 @@ TEST_F(StackTraceTest, MAYBE_StackEnd) {
 
 #if !defined(ADDRESS_SANITIZER) && !defined(UNDEFINED_SANITIZER)
 
-#if !defined(ARCH_CPU_ARM_FAMILY)
+#if !defined(ARCH_CPU_ARM_FAMILY) && !defined(LOONGARCH_NOT_LEGACY)
 // On Arm architecture invalid math operations such as division by zero are not
 // trapped and do not trigger a SIGFPE.
 // Hence disable the test for Arm platforms.
@@ -427,6 +427,8 @@ TEST(CheckExitCodeAfterSignalHandlerDeathTest, CheckSIGILL) {
     asm("ud2");
 #elif defined(ARCH_CPU_ARM_FAMILY)
     asm("udf 0");
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    asm(".word 0x0");
 #else
 #error Unsupported platform!
 #endif
diff --git a/base/files/file_util_unittest.cc b/base/files/file_util_unittest.cc
index c59c226c99..f55e1d0c8a 100644
--- a/base/files/file_util_unittest.cc
+++ b/base/files/file_util_unittest.cc
@@ -3881,11 +3881,19 @@ TEST_F(FileUtilTest, ReadFileToStringWithProcFileSystem) {
 
   data = "temp";
   EXPECT_FALSE(ReadFileToStringWithMaxSize(file_path, &data, 2));
+#if defined(ARCH_CPU_LOONGARCH_FAMILY)
+  EXPECT_TRUE(EqualsCaseInsensitiveASCII("sy", data));
+#else
   EXPECT_TRUE(EqualsCaseInsensitiveASCII("pr", data));
+#endif
 
   data = "temp";
   EXPECT_FALSE(ReadFileToStringWithMaxSize(file_path, &data, 4));
+#if defined(ARCH_CPU_LOONGARCH_FAMILY)
+  EXPECT_TRUE(EqualsCaseInsensitiveASCII("syst", data));
+#else
   EXPECT_TRUE(EqualsCaseInsensitiveASCII("proc", data));
+#endif
 
   EXPECT_FALSE(ReadFileToStringWithMaxSize(file_path, nullptr, 4));
 }
diff --git a/base/immediate_crash.h b/base/immediate_crash.h
index 049c9eef22..d7164334ae 100644
--- a/base/immediate_crash.h
+++ b/base/immediate_crash.h
@@ -82,6 +82,13 @@
 #define TRAP_SEQUENCE1_() asm volatile("brk #0")
 #define TRAP_SEQUENCE2_() asm volatile("hlt #0")
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+// This will always generate a SIGTRAP on loongarch64.
+// TODO(loongarch): Recheck SIGTRAP on loongarch64.
+#define TRAP_SEQUENCE1_() asm volatile("break 0x0")
+#define TRAP_SEQUENCE2_() asm volatile(".word 0x0")
+
 #else
 
 // Crash report accuracy will not be guaranteed on other architectures, but at
diff --git a/base/immediate_crash_unittest.cc b/base/immediate_crash_unittest.cc
index eb3850925e..8990abdd2a 100644
--- a/base/immediate_crash_unittest.cc
+++ b/base/immediate_crash_unittest.cc
@@ -91,6 +91,25 @@ constexpr Instruction kOptionalFooter[] = {};
 
 #endif
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+using Instruction = uint32_t;
+
+// LoongArch64 opcode reference:
+// https://loongson.github.io/LoongArch-Documentation/LoongArch-Vol1-EN.html.
+// Use an enum here rather than separate constexpr vars because otherwise some
+// of the vars will end up unused on each platform, upsetting
+// -Wunused-const-variable.
+enum : Instruction {
+  // There are multiple valid encodings of return (which is really a special
+  // form of branch). This is the one clang seems to use:
+  kRet = 0x4c000020,
+  kBrk0 = 0x002a0000,
+  kUdi = 0x0,
+};
+
+constexpr Instruction kRequiredBody[] = {kBrk0, kUdi};
+constexpr Instruction kOptionalFooter[] = {};
+
 #endif
 
 // This function loads a shared library that defines two functions,
diff --git a/base/profiler/register_context.h b/base/profiler/register_context.h
index 34a2ed48c2..51a9d23c79 100644
--- a/base/profiler/register_context.h
+++ b/base/profiler/register_context.h
@@ -191,6 +191,20 @@ inline uintptr_t& RegisterContextInstructionPointer(mcontext_t* context) {
   return AsUintPtr(&context->gregs[REG_RIP]);
 }
 
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY) && defined(ARCH_CPU_64_BITS)
+
+inline uintptr_t& RegisterContextStackPointer(mcontext_t* context) {
+  return AsUintPtr(&context->__gregs[3]);
+}
+
+inline uintptr_t& RegisterContextFramePointer(mcontext_t* context) {
+  return AsUintPtr(&context->__gregs[21]);
+}
+
+inline uintptr_t& RegisterContextInstructionPointer(mcontext_t* context) {
+  return AsUintPtr(&context->__pc);
+}
+
 #else  // defined(ARCH_CPU_ARM_FAMILY) && defined(ARCH_CPU_32_BITS)
 
 // Placeholders for other POSIX platforms that just return the first
diff --git a/base/profiler/thread_delegate_posix.cc b/base/profiler/thread_delegate_posix.cc
index d70413aaab..982034497e 100644
--- a/base/profiler/thread_delegate_posix.cc
+++ b/base/profiler/thread_delegate_posix.cc
@@ -98,6 +98,15 @@ std::vector<uintptr_t*> ThreadDelegatePosix::GetRegistersToRewrite(
       reinterpret_cast<uintptr_t*>(&thread_context->gregs[REG_R15]),
       reinterpret_cast<uintptr_t*>(&thread_context->gregs[REG_RSP]),
   };
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY) && defined(ARCH_CPU_64_BITS)
+  std::vector<uintptr_t*> registers;
+  registers.reserve(12);
+  // Return the set of callee-save registers per the LoongArch 64-bit Procedure Call
+  // Standard section 5.1.1, plus the stack pointer.
+  registers.push_back(reinterpret_cast<uintptr_t*>(&thread_context->__gregs[3]));
+  for (size_t i = 23; i <= 31; ++i)
+    registers.push_back(reinterpret_cast<uintptr_t*>(&thread_context->__gregs[i]));
+  return registers;
 #else  // #if defined(ARCH_CPU_ARM_FAMILY) && defined(ARCH_CPU_32_BITS)
   // Unimplemented for other architectures.
   return {};
diff --git a/base/system/sys_info.cc b/base/system/sys_info.cc
index 4029a869de..4dcb658d36 100644
--- a/base/system/sys_info.cc
+++ b/base/system/sys_info.cc
@@ -185,6 +185,8 @@ std::string SysInfo::ProcessCPUArchitecture() {
   return "ARM";
 #elif defined(ARCH_CPU_ARM64)
   return "ARM_64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return "LOONGARCH_64";
 #else
   return std::string();
 #endif
diff --git a/build/build_config.h b/build/build_config.h
index 2484703699..c0182c779f 100644
--- a/build/build_config.h
+++ b/build/build_config.h
@@ -336,6 +336,7 @@
 #define ARCH_CPU_BIG_ENDIAN 1
 #endif
 #elif defined(__loongarch__)
+#define ARCH_CPU_LOONG_FAMILY 1
 #define ARCH_CPU_LOONGARCH_FAMILY 1
 #define ARCH_CPU_LITTLE_ENDIAN 1
 #if __loongarch_grlen == 64
diff --git a/build/config/clang/clang.gni b/build/config/clang/clang.gni
index 3cb0553fe3..d3868efbf4 100644
--- a/build/config/clang/clang.gni
+++ b/build/config/clang/clang.gni
@@ -5,7 +5,11 @@
 import("//build/config/chromeos/ui_mode.gni")
 import("//build/toolchain/toolchain.gni")
 
-default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+if (current_cpu == "loong64") {
+  default_clang_base_path = "/opt/llvm_chrome114/llvm_install_15.0.7-3249e9f63766-debian10"
+} else {
+  default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+}
 
 declare_args() {
   # Indicates if the build should use the Chrome-specific plugins for enforcing
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index ae742b0b85..54fb5f8766 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -26,6 +26,9 @@ import("//build_overrides/build.gni")
 if (current_cpu == "arm" || current_cpu == "arm64") {
   import("//build/config/arm.gni")
 }
+if (current_cpu == "loong64") {
+  import("//build/config/loongarch64.gni")
+}
 if (current_cpu == "mipsel" || current_cpu == "mips64el" ||
     current_cpu == "mips" || current_cpu == "mips64") {
   import("//build/config/mips.gni")
@@ -379,6 +382,9 @@ config("compiler") {
 
     if (use_lld) {
       ldflags += [ "-fuse-ld=lld" ]
+      if (is_clang && current_cpu == "loong64") {
+        ldflags += [ "-Wl,--discard-locals" ]
+      }
       if (lld_path != "") {
         ldflags += [ "-B$lld_path" ]
       }
@@ -867,7 +873,7 @@ config("compiler") {
   # * Apple platforms (e.g. MacOS, iPhone, iPad) aren't supported because xcode
   #   lldb doesn't have the needed changes yet.
   # TODO(crbug.com/1379070): Remove if the upstream default ever changes.
-  if (is_clang && !is_nacl && !is_win && !is_apple) {
+  if (is_clang && !is_nacl && !is_win && !is_apple && target_cpu != "loong64") {
     cflags_cc += [ "-gsimple-template-names" ]
   }
 
@@ -1380,10 +1386,13 @@ config("compiler_cpu_abi") {
         cflags += [ "--target=loongarch64-linux-gnu" ]
         ldflags += [ "--target=loongarch64-linux-gnu" ]
       }
-      cflags += [
-        "-mabi=lp64d",
-        "-mcmodel=medium",
-      ]
+      if (loongarch_is_legacy) {
+        cflags += [
+          #"-mabi=lp64d",
+          "-mcmodel=large",
+          "-DLOONGARCH_IS_LEGACY",
+        ]
+      }
     } else if (current_cpu == "s390x") {
       cflags += [ "-m64" ]
       ldflags += [ "-m64" ]
diff --git a/build/config/loongarch64.gni b/build/config/loongarch64.gni
index 32aedbc671..da003cc748 100644
--- a/build/config/loongarch64.gni
+++ b/build/config/loongarch64.gni
@@ -9,5 +9,7 @@ if (current_cpu == "loong64") {
     # LOONGARCH64 SIMD Arch compilation flag.
     loongarch64_use_lsx = false
     loongarch64_use_lasx = false
+
+    loongarch_is_legacy = true
   }
 }
diff --git a/build/config/posix/BUILD.gn b/build/config/posix/BUILD.gn
index 8312d7ecf6..1e83b3f853 100644
--- a/build/config/posix/BUILD.gn
+++ b/build/config/posix/BUILD.gn
@@ -28,7 +28,7 @@ config("runtime_library") {
   if (!is_apple && sysroot != "" && current_os != "zos") {
     # Pass the sysroot to all C compiler variants, the assembler, and linker.
     sysroot_flags = [ "--sysroot=" + rebase_path(sysroot, root_build_dir) ]
-    if (is_linux || is_chromeos) {
+    if ((is_linux && current_cpu != "loong64") || is_chromeos) {
       # This is here so that all files get recompiled after a sysroot roll and
       # when turning the sysroot on or off. (defines are passed via the command
       # line, and build system rebuilds things when their commandline
diff --git a/build/config/sysroot.gni b/build/config/sysroot.gni
index 055c2a8246..85b59281fc 100644
--- a/build/config/sysroot.gni
+++ b/build/config/sysroot.gni
@@ -49,6 +49,8 @@ if (sysroot == "") {
       sysroot = "$target_sysroot_dir/debian_bullseye_armhf-sysroot"
     } else if (current_cpu == "arm64") {
       sysroot = "$target_sysroot_dir/debian_bullseye_arm64-sysroot"
+    } else if (current_cpu == "loong64") {
+      sysroot = "$target_sysroot_dir/debian_bullseye_loong64-sysroot"
     } else {
       assert(false, "No linux sysroot for cpu: $target_cpu")
     }
diff --git a/build/cross-build.sh b/build/cross-build.sh
new file mode 100755
index 0000000000..0e1171f660
--- /dev/null
+++ b/build/cross-build.sh
@@ -0,0 +1,49 @@
+#! /bin/bash
+
+# Chromium build configuration description.
+# Author: Wang Qing <wangqing-hf@loongson.cn>
+
+# Set gn args to build.
+export GN_CONFIG=(
+'google_api_key="AIzaSyDxKL42zsPjbke5O8_rPVpVrLrJ8aeE9rQ"'
+'google_default_client_id="595013732528-llk8trb03f0ldpqq6nprjp1s79596646.apps.googleusercontent.com"'
+'google_default_client_secret="5ntt6GbbkjnTVXx-MSxbmx5e"'
+'enable_hangout_services_extension=true'
+'enable_nacl=false'
+'enable_swiftshader=false'
+'angle_enable_swiftshader=false'
+'dawn_use_swiftshader=false'
+'enable_swiftshader_vulkan=false'
+'enable_widevine=false'
+'fatal_linker_warnings=false'
+'disable_fieldtrial_testing_config=true'
+'ffmpeg_branding="Chrome"'
+'is_debug=false'
+'use_gold=false'
+'is_clang=true'
+'clang_use_chrome_plugins=false'
+'link_pulseaudio=true'
+'proprietary_codecs=true'
+'symbol_level=0'
+'treat_warnings_as_errors=false'
+'use_cups=true'
+'use_kerberos=true'
+'use_pulseaudio=true'
+'use_sysroot=true'
+'rtc_include_dav1d_in_internal_decoder_factory=false'
+'host_cpu = "x64"'
+'target_cpu = "loong64"'
+'use_qt6=false'
+'v8_target_cpu = "loong64"'
+'rtc_use_pipewire=false'
+'enable_rust=false'
+'dcheck_always_on=false'
+'loongarch64_use_lsx=true'
+'loongarch64_use_lasx=true'
+'enable_libaom=false')
+
+# Set build directory.
+root_build_dir="out/la64_cross"
+
+# generate root_build_dir to build.
+./buildtools/linux64/gn gen $root_build_dir --args="${GN_CONFIG[*]}"
diff --git a/build/rust/rust_target.gni b/build/rust/rust_target.gni
index 757c1c69fc..e1f5b8f92b 100644
--- a/build/rust/rust_target.gni
+++ b/build/rust/rust_target.gni
@@ -105,6 +105,9 @@ template("rust_target") {
   }
 
   _rustflags = []
+  if (current_cpu == "loong64") {
+    _rustflags += [ "-Ccode-model=medium" ]
+  }
   if (defined(invoker.rustflags)) {
     _rustflags += invoker.rustflags
   }
diff --git a/chrome/app/chrome_main_delegate.cc b/chrome/app/chrome_main_delegate.cc
index d55fc46d9d..6fa2358056 100644
--- a/chrome/app/chrome_main_delegate.cc
+++ b/chrome/app/chrome_main_delegate.cc
@@ -235,6 +235,18 @@
 #include "ui/gfx/switches.h"
 #endif
 
+#if defined(ARCH_CPU_LOONG_FAMILY)
+extern unsigned int gLoongsonCpuFeatureSkia;
+extern unsigned int gLoongsonCpuFeatureZlib;
+extern unsigned int gLoongsonCpuFeatureLibyuv;
+extern unsigned int gLoongsonCpuFeatureFfmpeg;
+extern unsigned int gLoongsonCpuFeatureLibpng;
+extern unsigned int gLoongsonCpuFeatureLibjpeg;
+extern unsigned int gLoongsonCpuFeatureLibvpx;
+extern unsigned int gLoongsonCpuFeatureOpenh264;
+extern unsigned int gLoongsonCpuFeatureDav1d;
+#endif
+
 base::LazyInstance<ChromeContentGpuClient>::DestructorAtExit
     g_chrome_content_gpu_client = LAZY_INSTANCE_INITIALIZER;
 base::LazyInstance<ChromeContentRendererClient>::DestructorAtExit
@@ -628,6 +640,50 @@ void RecordMainStartupMetrics(base::TimeTicks application_start_time) {
   startup_metric_utils::RecordChromeMainEntryTime(now);
 }
 
+#if defined(ARCH_CPU_LOONG_FAMILY)
+enum {
+  LOONG_COM = 1 << 0,
+  LOONG_LSX = 1 << 1,
+  LOONG_LASX = 1 << 2,
+  DISABLE_LOONGOPT = 1 << 4,
+};
+#define LOONGARCH_CFG2 0x2
+#define LOONGARCH_CFG2_LSX    (1 << 6)
+#define LOONGARCH_CFG2_LASX   (1 << 7)
+
+static int loongson_get_cpu_flags_from_cpucfg(void) {
+  unsigned int flags = LOONG_COM;
+  unsigned int cfg2 = 0;
+
+  __asm__ volatile(
+      "cpucfg %0, %1 \n\t"
+      : "+&r"(cfg2)
+      : "r"(LOONGARCH_CFG2)
+  );
+
+  if (cfg2 & LOONGARCH_CFG2_LSX)
+      flags |= LOONG_LSX;
+
+  if (cfg2 & LOONGARCH_CFG2_LASX)
+      flags |= LOONG_LASX;
+
+  return flags;
+}
+static void LoongsonVectorInitial() {
+  static int flag = 0;
+  flag = loongson_get_cpu_flags_from_cpucfg();
+
+  // For loongarch SIMD opt, add global var initialize in here.
+  gLoongsonCpuFeatureSkia = flag;
+  //gLoongsonCpuFeatureZlib = flag;
+  gLoongsonCpuFeatureLibyuv = flag;
+  //gLoongsonCpuFeatureFfmpeg= flag;
+  //gLoongsonCpuFeatureLibpng= flag;
+  //gLoongsonCpuFeatureLibjpeg= flag;
+  //gLoongsonCpuFeatureOpenh264= flag;
+  //gLoongsonCpuFeatureDav1d= flag;
+}
+#endif
 }  // namespace
 
 ChromeMainDelegate::ChromeMainDelegate()
@@ -1326,6 +1382,9 @@ void ChromeMainDelegate::PreSandboxStartup() {
   // cpu_brand info.
   base::CPU cpu_info;
 #endif
+#if defined(ARCH_CPU_LOONG_FAMILY)
+  LoongsonVectorInitial();
+#endif
 
   // Initialize the user data dir for any process type that needs it.
   if (chrome::ProcessNeedsProfileDir(process_type))
diff --git a/chrome/browser/content_settings/one_time_permission_provider.cc b/chrome/browser/content_settings/one_time_permission_provider.cc
index 98135c4063..5e13cecb96 100644
--- a/chrome/browser/content_settings/one_time_permission_provider.cc
+++ b/chrome/browser/content_settings/one_time_permission_provider.cc
@@ -207,8 +207,8 @@ void OneTimePermissionProvider::OnSuspend() {
 
       while (rule_iterator && rule_iterator->HasNext()) {
         auto rule = rule_iterator->Next();
-        patterns_to_delete.emplace_back(setting_type, rule->primary_pattern,
-                                        rule->secondary_pattern);
+        patterns_to_delete.push_back({setting_type, rule->primary_pattern,
+                                        rule->secondary_pattern});
         permissions::PermissionUmaUtil::RecordOneTimePermissionEvent(
             setting_type,
             permissions::OneTimePermissionEvent::EXPIRED_ON_SUSPEND);
@@ -302,8 +302,8 @@ void OneTimePermissionProvider::DeleteEntriesMatchingGURL(
     auto rule = rule_iterator->Next();
     if (rule->primary_pattern.Matches(origin_gurl) &&
         rule->secondary_pattern.Matches(origin_gurl)) {
-      patterns_to_delete.emplace_back(
-          content_setting_type, rule->primary_pattern, rule->secondary_pattern);
+      patterns_to_delete.push_back(
+          {content_setting_type, rule->primary_pattern, rule->secondary_pattern});
       permissions::PermissionUmaUtil::RecordOneTimePermissionEvent(
           content_setting_type, trigger_event);
     }
diff --git a/chrome/browser/download/bubble/download_bubble_update_service.cc b/chrome/browser/download/bubble/download_bubble_update_service.cc
index 93ec91e38b..acd25f25d1 100644
--- a/chrome/browser/download/bubble/download_bubble_update_service.cc
+++ b/chrome/browser/download/bubble/download_bubble_update_service.cc
@@ -91,7 +91,7 @@ ItemSortKey GetSortKey(const Item& item) {
 // Helper to get an iterator to the last element in the cache. The cache
 // must not be empty.
 template <typename Item>
-SortedItems<Item>::const_iterator GetLastIter(const SortedItems<Item>& cache) {
+typename SortedItems<Item>::const_iterator GetLastIter(const SortedItems<Item>& cache) {
   CHECK(!cache.empty());
   auto it = cache.end();
   return std::prev(it);
@@ -967,9 +967,9 @@ bool DownloadBubbleUpdateService::CacheManager::RemoveItemFromCacheImpl(
 }
 
 template <typename Id, typename Item>
-SortedItems<Item>::iterator
+typename SortedItems<Item>::iterator
 DownloadBubbleUpdateService::CacheManager::RemoveItemFromCacheByIter(
-    SortedItems<Item>::iterator iter,
+    typename SortedItems<Item>::iterator iter,
     SortedItems<Item>& cache,
     IterMap<Id, Item>& iter_map) {
   CHECK(iter != cache.end());
diff --git a/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc b/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
index fcc035ef04..2a2f3645d4 100644
--- a/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
+++ b/chrome/browser/extensions/api/runtime/chrome_runtime_api_delegate.cc
@@ -301,6 +301,8 @@ bool ChromeRuntimeAPIDelegate::GetPlatformInfo(PlatformInfo* info) {
     info->arch = extensions::api::runtime::PlatformArch::kMips;
   } else if (strcmp(arch, "mips64el") == 0) {
     info->arch = extensions::api::runtime::PlatformArch::kMips64;
+  } else if (strcmp(arch, "loongarch64") == 0) {
+    info->arch = extensions::api::runtime::PlatformArch::kLoongarch64;
   } else {
     NOTREACHED();
     return false;
@@ -317,6 +319,8 @@ bool ChromeRuntimeAPIDelegate::GetPlatformInfo(PlatformInfo* info) {
     info->nacl_arch = extensions::api::runtime::PlatformNaclArch::kMips;
   } else if (strcmp(nacl_arch, "mips64") == 0) {
     info->nacl_arch = extensions::api::runtime::PlatformNaclArch::kMips64;
+  } else if (strcmp(nacl_arch, "loongarch64") == 0) {
+    info->nacl_arch = extensions::api::runtime::PlatformNaclArch::kLoongarch64;
   } else {
     NOTREACHED();
     return false;
diff --git a/chrome/browser/ui/location_bar/location_bar.h b/chrome/browser/ui/location_bar/location_bar.h
index 964f7a20db..6e5b2a9a50 100644
--- a/chrome/browser/ui/location_bar/location_bar.h
+++ b/chrome/browser/ui/location_bar/location_bar.h
@@ -38,6 +38,9 @@ class LocationBar {
     base::TimeTicks match_selection_timestamp;
     bool url_typed_without_scheme;
     bool url_typed_with_http_scheme;
+    static NavigationParams Make(GURL url, WindowOpenDisposition disposition, ui::PageTransition transition, base::TimeTicks timestamp, bool without_scheme, bool with_http_scheme) {
+      return {url, disposition, transition, timestamp, without_scheme, with_http_scheme};
+    }
   };
 
   explicit LocationBar(CommandUpdater* command_updater)
diff --git a/chrome/browser/ui/omnibox/chrome_omnibox_client.cc b/chrome/browser/ui/omnibox/chrome_omnibox_client.cc
index d923cdfa32..64d65ec426 100644
--- a/chrome/browser/ui/omnibox/chrome_omnibox_client.cc
+++ b/chrome/browser/ui/omnibox/chrome_omnibox_client.cc
@@ -470,7 +470,7 @@ void ChromeOmniboxClient::OnAutocompleteAccept(
               alternative_nav_match);
 
   // Store the details necessary to open the omnibox match via browser commands.
-  location_bar_->set_navigation_params(LocationBar::NavigationParams(
+  location_bar_->set_navigation_params(LocationBar::NavigationParams::Make(
       destination_url, disposition, transition, match_selection_timestamp,
       destination_url_entered_without_scheme,
       destination_url_entered_with_http_scheme));
diff --git a/chrome/installer/linux/common/apt.include b/chrome/installer/linux/common/apt.include
index 05c622864e..7d91f03dce 100644
--- a/chrome/installer/linux/common/apt.include
+++ b/chrome/installer/linux/common/apt.include
@@ -369,6 +369,8 @@ get_lib_dir() {
     LIBDIR=lib/mipsel-linux-gnu
   elif [ "$DEFAULT_ARCH" = "mips64el" ]; then
     LIBDIR=lib/mips64el-linux-gnuabi64
+  elif [ "$DEFAULT_ARCH" = "loongarch64" ]; then
+    LIBDIR=lib/loongarch64-linux-gnu
   else
     echo Unknown CPU Architecture: "$DEFAULT_ARCH"
     exit 1
diff --git a/chrome/installer/linux/common/rpm.include b/chrome/installer/linux/common/rpm.include
index 29438f4272..df9e2d3b69 100644
--- a/chrome/installer/linux/common/rpm.include
+++ b/chrome/installer/linux/common/rpm.include
@@ -477,7 +477,7 @@ get_lib_dir() {
       [ "$DEFAULT_ARCH" = "mipsel" ]; then
     LIBDIR=lib
   elif [ "$DEFAULT_ARCH" = "x86_64" ] || [ "$DEFAULT_ARCH" = "aarch64" ] || \
-        [ "$DEFAULT_ARCH" = "mips64el" ]; then
+        [ "$DEFAULT_ARCH" = "mips64el" ] || [ "$DEFAULT_ARCH" = "loongarch64" ]; then
     LIBDIR=lib64
   else
     echo Unknown CPU Architecture: "$DEFAULT_ARCH"
diff --git a/chrome/installer/linux/debian/calculate_package_deps.py b/chrome/installer/linux/debian/calculate_package_deps.py
index e6e88a9159..d68bfc0641 100755
--- a/chrome/installer/linux/debian/calculate_package_deps.py
+++ b/chrome/installer/linux/debian/calculate_package_deps.py
@@ -56,6 +56,9 @@ elif arch == 'mipsel':
 elif arch == 'mips64el':
   cmd.extend(['-l%s/usr/lib/mips64el-linux-gnuabi64' % sysroot,
               '-l%s/lib/mips64el-linux-gnuabi64' % sysroot])
+elif arch == 'loong64':
+  cmd.extend(['-l%s/usr/lib/loongarch64-linux-gnu' % sysroot,
+              '-l%s/lib/loongarch64-linux-gnu' % sysroot])
 else:
   print('Unsupported architecture ' + arch)
   sys.exit(1)
diff --git a/components/metrics/debug/metrics_internals_utils.cc b/components/metrics/debug/metrics_internals_utils.cc
index c32f2c7921..83439df1f7 100644
--- a/components/metrics/debug/metrics_internals_utils.cc
+++ b/components/metrics/debug/metrics_internals_utils.cc
@@ -68,6 +68,8 @@ std::string CpuArchitectureToString(
       return "arm32";
     case variations::Study::TRANSLATED_X86_64:
       return "translated_x86_64";
+    case variations::Study::LOONGARCH64:
+      return "loongarch64";
   }
   NOTREACHED();
 }
diff --git a/components/optimization_guide/core/tflite_model_executor.h b/components/optimization_guide/core/tflite_model_executor.h
index c4f750f468..b5635f4108 100644
--- a/components/optimization_guide/core/tflite_model_executor.h
+++ b/components/optimization_guide/core/tflite_model_executor.h
@@ -189,7 +189,7 @@ class TFLiteModelExecutor : public ModelExecutor<OutputType, InputType> {
   void SendForBatchExecution(
       BatchExecutionCallback callback_on_complete,
       base::TimeTicks start_time,
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
       override {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
diff --git a/components/variations/proto/study.proto b/components/variations/proto/study.proto
index b1d497a865..a087ec675e 100644
--- a/components/variations/proto/study.proto
+++ b/components/variations/proto/study.proto
@@ -258,6 +258,8 @@ message Study {
     // A Mac-only value, indicating an x86-64 binary running on an arm64 host
     // via "Rosetta 2" binary translation.
     TRANSLATED_X86_64 = 4;
+
+    LOONGARCH64 = 5;
   }
 
   // Enum to pass as optional bool.
diff --git a/components/variations/service/variations_field_trial_creator.cc b/components/variations/service/variations_field_trial_creator.cc
index bfddf3a8eb..abf6fcd623 100644
--- a/components/variations/service/variations_field_trial_creator.cc
+++ b/components/variations/service/variations_field_trial_creator.cc
@@ -109,6 +109,8 @@ RestrictionPolicy GetVariationPolicyRestriction(PrefService* local_state) {
 
 Study::CpuArchitecture GetCurrentCpuArchitecture() {
   std::string process_arch = base::SysInfo::ProcessCPUArchitecture();
+  if (process_arch == "LOONGARCH_64")
+    return Study::LOONGARCH64;
   if (process_arch == "ARM_64")
     return Study::ARM64;
   if (process_arch == "ARM")
diff --git a/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc b/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
index 3bace0dab1..bd7be4298a 100644
--- a/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
+++ b/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
@@ -1496,7 +1496,7 @@ void SkiaOutputSurfaceImplOnGpu::CopyOutputNV12(
 
       // Issue readbacks from the surfaces:
       for (size_t i = 0; i < CopyOutputResult::kNV12MaxPlanes; ++i) {
-        SkISize size(plane_surfaces[i]->width(), plane_surfaces[i]->height());
+        SkISize size = SkISize::Make(plane_surfaces[i]->width(), plane_surfaces[i]->height());
         SkImageInfo dst_info = SkImageInfo::Make(
             size, (i == 0) ? kAlpha_8_SkColorType : kR8G8_unorm_SkColorType,
             kUnpremul_SkAlphaType);
diff --git a/content/browser/service_worker/service_worker_context_wrapper.cc b/content/browser/service_worker/service_worker_context_wrapper.cc
index 6fbb7d75b9..5cd5e53fc4 100644
--- a/content/browser/service_worker/service_worker_context_wrapper.cc
+++ b/content/browser/service_worker/service_worker_context_wrapper.cc
@@ -1396,9 +1396,9 @@ void ServiceWorkerContextWrapper::MaybeProcessPendingWarmUpRequest() {
   auto [document_url, key, callback] = std::move(*request);
 
   DCHECK(document_url.is_valid());
-  TRACE_EVENT1("ServiceWorker",
-               "ServiceWorkerContextWrapper::MaybeProcessPendingWarmUpRequest",
-               "document_url", document_url.spec());
+  //TRACE_EVENT1("ServiceWorker",
+  //             "ServiceWorkerContextWrapper::MaybeProcessPendingWarmUpRequest",
+  //             "document_url", document_url.spec());
 
   context_core_->registry()->FindRegistrationForClientUrl(
       ServiceWorkerRegistry::Purpose::kNotForNavigation,
diff --git a/content/public/browser/web_ui_browser_interface_broker_registry.h b/content/public/browser/web_ui_browser_interface_broker_registry.h
index 0a419be66b..7253c9680f 100644
--- a/content/public/browser/web_ui_browser_interface_broker_registry.h
+++ b/content/public/browser/web_ui_browser_interface_broker_registry.h
@@ -127,10 +127,10 @@ class CONTENT_EXPORT WebUIBrowserInterfaceBrokerRegistry {
   //
   // TODO(crbug.com/1407936): Point to WebUIJsBridge documentation.
   template <typename ControllerType>
-  JsBridgeTraits<ControllerType>::BinderInitializer& ForWebUIWithJsBridge() {
+  typename JsBridgeTraits<ControllerType>::BinderInitializer& ForWebUIWithJsBridge() {
     using Traits = JsBridgeTraits<ControllerType>;
-    using Interface = Traits::Interface;
-    using JsBridgeBinderInitializer = Traits::BinderInitializer;
+    using Interface = typename Traits::Interface;
+    using JsBridgeBinderInitializer = typename Traits::BinderInitializer;
 
     // WebUIController::GetType() requires an instantiated WebUIController
     // (because it's a virtual method and can't be static). Here we only have
diff --git a/extensions/common/api/runtime.json b/extensions/common/api/runtime.json
index c68bec7268..228515f5ca 100644
--- a/extensions/common/api/runtime.json
+++ b/extensions/common/api/runtime.json
@@ -95,14 +95,14 @@
       {
         "id": "PlatformArch",
         "type": "string",
-        "enum": ["arm", "arm64", "x86-32", "x86-64", "mips", "mips64"],
+        "enum": ["arm", "arm64", "x86-32", "x86-64", "mips", "mips64", "loongarch64"],
         "description": "The machine's processor architecture."
       },
       {
         "id": "PlatformNaclArch",
         "description": "The native client architecture. This may be different from arch on some platforms.",
         "type": "string",
-        "enum": ["arm", "x86-32", "x86-64", "mips", "mips64"]
+        "enum": ["arm", "x86-32", "x86-64", "mips", "mips64", "loongarch64"]
       },
       {
         "id": "PlatformInfo",
diff --git a/media/base/cdm_promise_adapter.cc b/media/base/cdm_promise_adapter.cc
index f013809a62..11cc6cc8f4 100644
--- a/media/base/cdm_promise_adapter.cc
+++ b/media/base/cdm_promise_adapter.cc
@@ -95,9 +95,9 @@ void CdmPromiseAdapter::Clear(ClearReason reason) {
   // Reject all outstanding promises.
   DCHECK(thread_checker_.CalledOnValidThread());
   for (auto& [promise_id, promise] : promises_) {
-    TRACE_EVENT_NESTABLE_ASYNC_END1(
-        "media", "CdmPromise", TRACE_ID_WITH_SCOPE("CdmPromise", promise_id),
-        "status", "cleared");
+    //TRACE_EVENT_NESTABLE_ASYNC_END1(
+    //    "media", "CdmPromise", TRACE_ID_WITH_SCOPE("CdmPromise", promise_id),
+    //    "status", "cleared");
     promise->reject(CdmPromise::Exception::INVALID_STATE_ERROR,
                     ToSystemCode(reason), "Operation aborted.");
   }
diff --git a/net/dns/host_resolver_cache.h b/net/dns/host_resolver_cache.h
index 501a1cedd1..ef331c906a 100644
--- a/net/dns/host_resolver_cache.h
+++ b/net/dns/host_resolver_cache.h
@@ -120,6 +120,10 @@ class NET_EXPORT HostResolverCache final {
   struct Key {
     std::string domain_name;
     NetworkAnonymizationKey network_anonymization_key;
+    Key(std::string name, NetworkAnonymizationKey key) {
+      this->domain_name = name;
+      this->network_anonymization_key = key;
+    }
   };
 
   struct KeyRef {
diff --git a/sandbox/features.gni b/sandbox/features.gni
index 8434144118..e1c0af43ce 100644
--- a/sandbox/features.gni
+++ b/sandbox/features.gni
@@ -9,7 +9,8 @@
 use_seccomp_bpf = (is_linux || is_chromeos || is_android) &&
                   (current_cpu == "x86" || current_cpu == "x64" ||
                    current_cpu == "arm" || current_cpu == "arm64" ||
-                   current_cpu == "mipsel" || current_cpu == "mips64el")
+                   current_cpu == "mipsel" || current_cpu == "mips64el" ||
+                   current_cpu == "loong64")
 
 # SSBD (Speculative Store Bypass Disable) is a mitigation of Spectre Variant 4.
 # As Spectre Variant 4 can be mitigated by site isolation, opt-out SSBD on site
diff --git a/sandbox/linux/BUILD.gn b/sandbox/linux/BUILD.gn
index 483488a3f7..d6036efbc3 100644
--- a/sandbox/linux/BUILD.gn
+++ b/sandbox/linux/BUILD.gn
@@ -396,6 +396,7 @@ source_set("sandbox_services_headers") {
     "system_headers/linux_stat.h",
     "system_headers/linux_syscalls.h",
     "system_headers/linux_time.h",
+    "system_headers/loong64_linux_syscalls.h",
     "system_headers/mips64_linux_syscalls.h",
     "system_headers/mips_linux_syscalls.h",
     "system_headers/x86_32_linux_syscalls.h",
diff --git a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
index 1d0590b7dd..5169ad3c82 100644
--- a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
+++ b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
@@ -56,6 +56,13 @@
 #define MAX_PUBLIC_SYSCALL __NR_syscalls
 #define MAX_SYSCALL MAX_PUBLIC_SYSCALL
 
+#elif defined(__loongarch64)
+
+#include <asm-generic/unistd.h>
+#define MIN_SYSCALL 0u
+#define MAX_PUBLIC_SYSCALL __NR_syscalls
+#define MAX_SYSCALL MAX_PUBLIC_SYSCALL
+
 #else
 #error "Unsupported architecture"
 #endif
diff --git a/sandbox/linux/bpf_dsl/seccomp_macros.h b/sandbox/linux/bpf_dsl/seccomp_macros.h
index 87d5825aa3..44d5b3a8d2 100644
--- a/sandbox/linux/bpf_dsl/seccomp_macros.h
+++ b/sandbox/linux/bpf_dsl/seccomp_macros.h
@@ -343,6 +343,48 @@ struct regs_struct {
 #define SECCOMP_PT_PARM4(_regs) (_regs).regs[3]
 #define SECCOMP_PT_PARM5(_regs) (_regs).regs[4]
 #define SECCOMP_PT_PARM6(_regs) (_regs).regs[5]
+
+#elif defined(__loongarch64)
+struct regs_struct {
+  uint64_t regs[32];
+  uint64_t pc;
+};
+
+#define SECCOMP_ARCH AUDIT_ARCH_LOONGARCH64
+
+#define SECCOMP_REG(_ctx, _reg) ((_ctx)->uc_mcontext.__gregs[_reg])
+
+#define SECCOMP_RESULT(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_SYSCALL(_ctx) SECCOMP_REG(_ctx, 11)
+#define SECCOMP_IP(_ctx) (_ctx)->uc_mcontext.__pc
+#define SECCOMP_PARM1(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_PARM2(_ctx) SECCOMP_REG(_ctx, 5)
+#define SECCOMP_PARM3(_ctx) SECCOMP_REG(_ctx, 6)
+#define SECCOMP_PARM4(_ctx) SECCOMP_REG(_ctx, 7)
+#define SECCOMP_PARM5(_ctx) SECCOMP_REG(_ctx, 8)
+#define SECCOMP_PARM6(_ctx) SECCOMP_REG(_ctx, 9)
+
+#define SECCOMP_NR_IDX (offsetof(struct arch_seccomp_data, nr))
+#define SECCOMP_ARCH_IDX (offsetof(struct arch_seccomp_data, arch))
+#define SECCOMP_IP_MSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
+#define SECCOMP_IP_LSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 0)
+#define SECCOMP_ARG_MSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
+#define SECCOMP_ARG_LSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+
+#define SECCOMP_PT_RESULT(_regs) (_regs).regs[4]
+#define SECCOMP_PT_SYSCALL(_regs) (_regs).regs[11]
+#define SECCOMP_PT_IP(_regs) (_regs).pc
+#define SECCOMP_PT_PARM1(_regs) (_regs).regs[4]
+#define SECCOMP_PT_PARM2(_regs) (_regs).regs[5]
+#define SECCOMP_PT_PARM3(_regs) (_regs).regs[6]
+#define SECCOMP_PT_PARM4(_regs) (_regs).regs[7]
+#define SECCOMP_PT_PARM5(_regs) (_regs).regs[8]
+#define SECCOMP_PT_PARM6(_regs) (_regs).regs[9]
+
 #else
 #error Unsupported target platform
 
diff --git a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
index 4a2721c7ce..b2548f0f23 100644
--- a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
+++ b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
@@ -1932,7 +1932,8 @@ BPF_TEST_C(SandboxBPF, PthreadBitMask, PthreadPolicyBitMask) {
 //
 // Depending on the architecture, this may modify regs, so the caller is
 // responsible for committing these changes using PTRACE_SETREGS.
-#if !defined(__arm__) && !defined(__aarch64__) && !defined(__mips__)
+#if !defined(__arm__) && !defined(__aarch64__) && !defined(__mips__) && \
+    !defined(__loongarch__)
 long SetSyscall(pid_t pid, regs_struct* regs, int syscall_number) {
 #if defined(__arm__)
   // On ARM, the syscall is changed using PTRACE_SET_SYSCALL.  We cannot use the
@@ -1972,7 +1973,8 @@ SANDBOX_TEST(SandboxBPF, DISABLE_ON_TSAN(SeccompRetTrace)) {
 // See https://code.google.com/p/chromium/issues/detail?id=383977
 #if defined(__arm__) || defined(__aarch64__)
   printf("This test is currently disabled on ARM32/64 due to a kernel bug.");
-#elif defined(__mips__)
+#elif defined(__mips__) || defined(__loongarch__)
+  // TODO(loongarch): Recheck SandboxBPF.SeccompRetTrace
   // TODO: Figure out how to support specificity of handling indirect syscalls
   //        in this test and enable it.
   printf("This test is currently disabled on MIPS.");
diff --git a/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc b/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc
index 967b50741f..eb32bb8682 100644
--- a/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc
+++ b/sandbox/linux/integration_tests/seccomp_broker_process_unittest.cc
@@ -224,6 +224,7 @@ const int kFakeErrnoSentinel = 254;
 
 void ConvertKernelStatToLibcStat(default_stat_struct& in_stat,
                                  struct stat& out_stat) {
+#if !defined(LOONGARCH_NOT_LEGACY)
   out_stat.st_dev = in_stat.st_dev;
   out_stat.st_ino = in_stat.st_ino;
   out_stat.st_mode = in_stat.st_mode;
@@ -240,6 +241,28 @@ void ConvertKernelStatToLibcStat(default_stat_struct& in_stat,
   out_stat.st_mtim.tv_nsec = in_stat.st_mtime_nsec_;
   out_stat.st_ctim.tv_sec = in_stat.st_ctime_;
   out_stat.st_ctim.tv_nsec = in_stat.st_ctime_nsec_;
+#else
+  out_stat.st_dev =
+      ((in_stat.stx_dev_minor & 0xff) | (in_stat.stx_dev_major << 8) |
+       ((in_stat.stx_dev_minor & ~0xff) << 12));
+  out_stat.st_rdev =
+      ((in_stat.stx_rdev_minor & 0xff) | (in_stat.stx_rdev_major << 8) |
+       ((in_stat.stx_rdev_minor & ~0xff) << 12));
+  out_stat.st_ino = in_stat.stx_ino;
+  out_stat.st_mode = in_stat.stx_mode;
+  out_stat.st_nlink = in_stat.stx_nlink;
+  out_stat.st_uid = in_stat.stx_uid;
+  out_stat.st_gid = in_stat.stx_gid;
+  out_stat.st_atim.tv_sec = in_stat.stx_atime.tv_sec;
+  out_stat.st_atim.tv_nsec = in_stat.stx_atime.tv_nsec;
+  out_stat.st_mtim.tv_sec = in_stat.stx_mtime.tv_sec;
+  out_stat.st_mtim.tv_nsec = in_stat.stx_mtime.tv_nsec;
+  out_stat.st_ctim.tv_sec = in_stat.stx_ctime.tv_sec;
+  out_stat.st_ctim.tv_nsec = in_stat.stx_ctime.tv_nsec;
+  out_stat.st_size = in_stat.stx_size;
+  out_stat.st_blocks = in_stat.stx_blocks;
+  out_stat.st_blksize = in_stat.stx_blksize;
+#endif
 }
 }  // namespace
 
diff --git a/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc b/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
index 7bde501115..f4dfd1fa36 100644
--- a/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
@@ -193,7 +193,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return RestrictFcntlCommands();
 #endif
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
   // fork() is never used as a system call (clone() is used instead), but we
   // have seen it in fallback code on Android.
   if (sysno == __NR_fork) {
@@ -255,7 +255,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
   }
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch64)
   if (sysno == __NR_mmap)
     return RestrictMmapFlags();
 #endif
@@ -276,7 +276,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return RestrictPrctl();
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch64)
   if (sysno == __NR_socketpair) {
     // Only allow AF_UNIX, PF_UNIX. Crash if anything else is seen.
     static_assert(AF_UNIX == PF_UNIX,
@@ -305,9 +305,12 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
   // The fstatat syscalls are file system syscalls, which will be denied below
   // with fs_denied_errno. However some allowed fstat syscalls are rewritten by
   // libc implementations to fstatat syscalls, and we need to rewrite them back.
+#if defined(__NR_fstatat_default)
+  // TODO(loongarch): fstatat
   if (sysno == __NR_fstatat_default) {
     return RewriteFstatatSIGSYS(fs_denied_errno);
   }
+#endif
 
   // The statx syscall is a filesystem syscall, which will be denied below with
   // fs_denied_errno. However, on some platforms, glibc will default to statx
@@ -366,7 +369,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
   // Allow creating pipes, but don't allow weird flags to pipe2().
   // O_NOTIFICATION_PIPE (== O_EXCL) can be used to create
   // "notification pipes", which are rarely used.
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
   if (sysno == __NR_pipe) {
     return Allow();
   }
diff --git a/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc b/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
index dbbf1fb510..e33efe0af3 100644
--- a/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
@@ -57,6 +57,9 @@ namespace {
 void TestPipeOrSocketPair(base::ScopedFD read_end, base::ScopedFD write_end) {
   BPF_ASSERT_LE(0, read_end.get());
   BPF_ASSERT_LE(0, write_end.get());
+
+// Use statx instead of stat, lstat and fstatat on loongarch64 abi2.0, So don't
+// test fstat(), and fstatat for it.
   struct stat stat_buf;
   int sys_ret = fstat(read_end.get(), &stat_buf);
   BPF_ASSERT_EQ(0, sys_ret);
@@ -66,6 +69,8 @@ void TestPipeOrSocketPair(base::ScopedFD read_end, base::ScopedFD write_end) {
   BPF_ASSERT_EQ(0, sys_ret);
   BPF_ASSERT(S_ISFIFO(stat_buf.st_mode) || S_ISSOCK(stat_buf.st_mode));
 
+// TODO(loongarch): fstatat with path.
+#if !defined(LOONGARCH_NOT_LEGACY)
   // Make sure fstatat with anything other than an empty string is denied.
   sys_ret = fstatat(read_end.get(), "/", &stat_buf, AT_EMPTY_PATH);
   BPF_ASSERT_EQ(sys_ret, -1);
@@ -75,6 +80,7 @@ void TestPipeOrSocketPair(base::ScopedFD read_end, base::ScopedFD write_end) {
   sys_ret = fstatat(read_end.get(), "", &stat_buf, 0);
   BPF_ASSERT_EQ(sys_ret, -1);
   BPF_ASSERT_EQ(EPERM, errno);
+#endif
 
   const ssize_t kTestTransferSize = 4;
   static const char kTestString[kTestTransferSize] = {'T', 'E', 'S', 'T'};
@@ -256,7 +262,8 @@ BPF_TEST_C(BaselinePolicy, GetRandom, BaselinePolicy) {
 }
 
 // Not all architectures can restrict the domain for socketpair().
-#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
+    defined(__loongarch64)
 BPF_DEATH_TEST_C(BaselinePolicy,
                  SocketpairWrongDomain,
                  DEATH_SEGV_MESSAGE(GetErrorMessageContentForTests()),
@@ -265,7 +272,8 @@ BPF_DEATH_TEST_C(BaselinePolicy,
   std::ignore = socketpair(AF_INET, SOCK_STREAM, 0, sv);
   _exit(1);
 }
-#endif  // defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+#endif  // defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) ||
+        // defined(__loongarch64)
 
 BPF_TEST_C(BaselinePolicy, EPERM_open, BaselinePolicy) {
   errno = 0;
@@ -329,7 +337,7 @@ TEST_BASELINE_SIGSYS(__NR_sysinfo)
 TEST_BASELINE_SIGSYS(__NR_syslog)
 TEST_BASELINE_SIGSYS(__NR_timer_create)
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
 TEST_BASELINE_SIGSYS(__NR_inotify_init)
 TEST_BASELINE_SIGSYS(__NR_vserver)
 #endif
diff --git a/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc b/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
index 790b65c587..546146db70 100644
--- a/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/sigsys_handlers.cc
@@ -431,6 +431,8 @@ intptr_t SIGSYSSchedHandler(const struct arch_seccomp_data& args,
 
 intptr_t SIGSYSFstatatHandler(const struct arch_seccomp_data& args,
                               void* fs_denied_errno) {
+  // TODO(loongarch): fstatat
+#if defined(__NR_fstatat_default) && defined(__NR_fstat_default)
   if (args.nr == __NR_fstatat_default) {
     if (*reinterpret_cast<const char*>(args.args[1]) == '\0' &&
         args.args[3] == static_cast<uint64_t>(AT_EMPTY_PATH)) {
@@ -439,6 +441,7 @@ intptr_t SIGSYSFstatatHandler(const struct arch_seccomp_data& args,
     }
     return -reinterpret_cast<intptr_t>(fs_denied_errno);
   }
+#endif
 
   CrashSIGSYS_Handler(args, fs_denied_errno);
 
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
index 026e86bd85..6808334718 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
@@ -37,7 +37,7 @@
 
 #if (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) && \
     !defined(__arm__) && !defined(__aarch64__) &&             \
-    !defined(PTRACE_GET_THREAD_AREA)
+    !defined(PTRACE_GET_THREAD_AREA) && !defined(__loongarch__)
 // Also include asm/ptrace-abi.h since ptrace.h in older libc (for instance
 // the one in Ubuntu 16.04 LTS) is missing PTRACE_GET_THREAD_AREA.
 // asm/ptrace-abi.h doesn't exist on arm32 and PTRACE_GET_THREAD_AREA isn't
@@ -450,7 +450,10 @@ ResultExpr RestrictPtrace() {
   return Switch(request)
       .Cases({
 #if !defined(__aarch64__)
-                 PTRACE_GETREGS, PTRACE_GETFPREGS, PTRACE_GET_THREAD_AREA,
+                 PTRACE_GETREGS, PTRACE_GETFPREGS,
+#if !defined(__loongarch64)
+		 PTRACE_GET_THREAD_AREA,
+#endif
                  PTRACE_GETREGSET,
 #endif
 #if defined(__arm__)
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
index 27ea264070..0a6c52be57 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
@@ -103,7 +103,7 @@ bool SyscallSets::IsUmask(int sysno) {
 // Both EPERM and ENOENT are valid errno unless otherwise noted in comment.
 bool SyscallSets::IsFileSystem(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_access:  // EPERM not a valid errno.
     case __NR_chmod:
     case __NR_chown:
@@ -136,7 +136,7 @@ bool SyscallSets::IsFileSystem(int sysno) {
     case __NR_faccessat2:
     case __NR_fchmodat:
     case __NR_fchownat:  // Should be called chownat ?
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(LOONGARCH_IS_LEGACY)
     case __NR_newfstatat:  // fstatat(). EPERM not a valid errno.
 #elif defined(__i386__) || defined(__arm__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
@@ -211,7 +211,13 @@ bool SyscallSets::IsTruncate(int sysno) {
 
 bool SyscallSets::IsAllowedFileSystemAccessViaFd(int sysno) {
   switch (sysno) {
+#if !defined(LOONGARCH_NOT_LEGACY)
     case __NR_fstat:
+#else
+    // TODO(loongarch): statx is temporarily allowed.
+    // See https://lore.kernel.org/all/f59d73fb-7d3e-4c55-821a-082032267978@xen0n.name/T/
+    case __NR_statx:
+#endif
     case __NR_ftruncate:
 #if defined(__i386__) || defined(__arm__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
@@ -241,7 +247,7 @@ bool SyscallSets::IsAllowedFileSystemAccessViaFd(int sysno) {
     case __NR_oldfstat:
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_sync_file_range:  // EPERM not a valid errno.
 #elif defined(__arm__)
     case __NR_arm_sync_file_range:  // EPERM not a valid errno.
@@ -260,7 +266,7 @@ bool SyscallSets::IsDeniedFileSystemAccessViaFd(int sysno) {
 #if defined(__i386__) || defined(__arm__)
     case __NR_fchown32:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_getdents:    // EPERM not a valid errno.
 #endif
     case __NR_getdents64:  // EPERM not a valid errno.
@@ -339,7 +345,7 @@ bool SyscallSets::IsProcessPrivilegeChange(int sysno) {
 bool SyscallSets::IsProcessGroupOrSession(int sysno) {
   switch (sysno) {
     case __NR_setpgid:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_getpgrp:
 #endif
     case __NR_setsid:
@@ -373,7 +379,7 @@ bool SyscallSets::IsAllowedSignalHandling(int sysno) {
     case __NR_rt_sigqueueinfo:
     case __NR_rt_sigsuspend:
     case __NR_rt_tgsigqueueinfo:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_signalfd:
 #endif
     case __NR_signalfd4:
@@ -397,12 +403,12 @@ bool SyscallSets::IsAllowedOperationOnFd(int sysno) {
   switch (sysno) {
     case __NR_close:
     case __NR_dup:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_dup2:
 #endif
     case __NR_dup3:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_shutdown:
 #endif
       return true;
@@ -441,7 +447,7 @@ bool SyscallSets::IsAllowedProcessStartOrDeath(int sysno) {
       return true;
     case __NR_clone:  // Should be parameter-restricted.
     case __NR_setns:  // Privileged.
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_fork:
 #endif
 #if defined(__i386__) || defined(__x86_64__)
@@ -452,7 +458,7 @@ bool SyscallSets::IsAllowedProcessStartOrDeath(int sysno) {
 #endif
     case __NR_set_tid_address:
     case __NR_unshare:
-#if !defined(__mips__) && !defined(__aarch64__)
+#if !defined(__mips__) && !defined(__aarch64__) && !defined(__loongarch__)
     case __NR_vfork:
 #endif
     default:
@@ -477,7 +483,7 @@ bool SyscallSets::IsAllowedFutex(int sysno) {
 
 bool SyscallSets::IsAllowedEpoll(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_epoll_create:
     case __NR_epoll_wait:
 #endif
@@ -499,7 +505,7 @@ bool SyscallSets::IsAllowedEpoll(int sysno) {
 bool SyscallSets::IsDeniedGetOrModifySocket(int sysno) {
   switch (sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_accept:
     case __NR_accept4:
     case __NR_bind:
@@ -553,7 +559,7 @@ bool SyscallSets::IsAllowedAddressSpaceAccess(int sysno) {
     case __NR_mincore:
     case __NR_mlockall:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_mmap:
 #endif
 #if defined(__i386__) || defined(__arm__) || \
@@ -586,7 +592,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR__llseek:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_poll:
 #endif
     case __NR_ppoll:
@@ -607,7 +613,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     case __NR_recv:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_recvfrom:  // Could specify source.
     case __NR_recvmsg:   // Could specify source.
 #endif
@@ -622,7 +628,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     case __NR_send:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_sendmsg:  // Could specify destination.
     case __NR_sendto:   // Could specify destination.
 #endif
@@ -671,7 +677,7 @@ bool SyscallSets::IsSeccomp(int sysno) {
 bool SyscallSets::IsAllowedBasicScheduler(int sysno) {
   switch (sysno) {
     case __NR_sched_yield:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_pause:
 #endif
     case __NR_nanosleep:
@@ -755,7 +761,7 @@ bool SyscallSets::IsNuma(int sysno) {
     case __NR_getcpu:
     case __NR_mbind:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_migrate_pages:
 #endif
     case __NR_move_pages:
@@ -790,7 +796,7 @@ bool SyscallSets::IsGlobalProcessEnvironment(int sysno) {
   switch (sysno) {
     case __NR_acct:  // Privileged.
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_getrlimit:
 #endif
 #if defined(__i386__) || defined(__arm__)
@@ -825,7 +831,7 @@ bool SyscallSets::IsDebug(int sysno) {
 
 bool SyscallSets::IsGlobalSystemStatus(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR__sysctl:
     case __NR_sysfs:
 #endif
@@ -843,7 +849,7 @@ bool SyscallSets::IsGlobalSystemStatus(int sysno) {
 
 bool SyscallSets::IsEventFd(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_eventfd:
 #endif
     case __NR_eventfd2:
@@ -895,7 +901,8 @@ bool SyscallSets::IsKeyManagement(int sysno) {
 }
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch64)
 bool SyscallSets::IsSystemVSemaphores(int sysno) {
   switch (sysno) {
     case __NR_semctl:
@@ -914,7 +921,7 @@ bool SyscallSets::IsSystemVSemaphores(int sysno) {
 #endif
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__) ||                                         \
+    defined(__aarch64__) || defined(__loongarch64) ||               \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
 // These give a lot of ambient authority and bypass the setuid sandbox.
 bool SyscallSets::IsSystemVSharedMemory(int sysno) {
@@ -931,7 +938,8 @@ bool SyscallSets::IsSystemVSharedMemory(int sysno) {
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch64)
 bool SyscallSets::IsSystemVMessageQueue(int sysno) {
   switch (sysno) {
     case __NR_msgctl:
@@ -962,7 +970,8 @@ bool SyscallSets::IsSystemVIpc(int sysno) {
 
 bool SyscallSets::IsAnySystemV(int sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch64)
   return IsSystemVMessageQueue(sysno) || IsSystemVSemaphores(sysno) ||
          IsSystemVSharedMemory(sysno);
 #elif defined(__i386__) || \
@@ -999,7 +1008,7 @@ bool SyscallSets::IsAdvancedScheduler(int sysno) {
 bool SyscallSets::IsInotify(int sysno) {
   switch (sysno) {
     case __NR_inotify_add_watch:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_inotify_init:
 #endif
     case __NR_inotify_init1:
@@ -1137,7 +1146,7 @@ bool SyscallSets::IsMisc(int sysno) {
 #if defined(__x86_64__)
     case __NR_tuxcall:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_vserver:
 #endif
       return true;
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
index 9be7b03ec4..6ffba1c61d 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
@@ -52,7 +52,7 @@ class SANDBOX_EXPORT SyscallSets {
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
   static bool IsNetworkSocketInformation(int sysno);
 #endif
 
@@ -79,23 +79,27 @@ class SANDBOX_EXPORT SyscallSets {
   static bool IsAsyncIo(int sysno);
   static bool IsKeyManagement(int sysno);
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch__)
   static bool IsSystemVSemaphores(int sysno);
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
     defined(__aarch64__) ||                                         \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) || \
+    defined(__loongarch__)
   // These give a lot of ambient authority and bypass the setuid sandbox.
   static bool IsSystemVSharedMemory(int sysno);
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch__)
   static bool IsSystemVMessageQueue(int sysno);
 #endif
 
-#if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+#if defined(__i386__) ||                                            \
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__looongarch__)
   // Big system V multiplexing system call.
   static bool IsSystemVIpc(int sysno);
 #endif
diff --git a/sandbox/linux/seccomp-bpf/syscall.cc b/sandbox/linux/seccomp-bpf/syscall.cc
index 02cbb047c1..0b4dcf476a 100644
--- a/sandbox/linux/seccomp-bpf/syscall.cc
+++ b/sandbox/linux/seccomp-bpf/syscall.cc
@@ -18,7 +18,7 @@ namespace sandbox {
 namespace {
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
 // Number that's not currently used by any Linux kernel ABIs.
 const int kInvalidSyscallNumber = 0x351d3;
 #else
@@ -308,6 +308,25 @@ asm(// We need to be able to tell the kernel exactly where we made a
     "2:ret\n"
     ".cfi_endproc\n"
     ".size SyscallAsm, .-SyscallAsm\n"
+#elif defined(__loongarch_lp64)
+    ".text\n"
+    ".global SyscallAsm\n"
+    ".type SyscallAsm, %function\n"
+    "SyscallAsm:\n"
+    "bge $a0, $zero, 1f\n"
+    "la.pcrel $a0, 2f\n"
+    "b 2f\n"
+    "1:ld.d $a5, $a6, 40\n"
+    "ld.d $a4, $a6, 32\n"
+    "ld.d $a3, $a6, 24\n"
+    "ld.d $a2, $a6, 16\n"
+    "ld.d $a1, $a6, 8\n"
+    "move $a7, $a0\n"
+    "ld.d $a0, $a6, 0\n"
+    // Enter the kernel
+    "syscall 0\n"
+    "2:jirl $zero, $ra, 0\n"
+    ".size SyscallAsm, .-SyscallAsm\n"
 #endif
     );  // asm
 
@@ -424,6 +443,23 @@ intptr_t Syscall::Call(int nr,
                  : "memory", "x1", "x2", "x3", "x4", "x5", "x8", "x30");
     ret = inout;
   }
+#elif defined(__loongarch_lp64)
+  intptr_t ret;
+  {
+#if defined(LOONGARCH_IS_LEGACY)
+    // invalid syscall number bigger than u16_max may get unexpected return value.
+    if(nr > 0xFFFF) {
+      nr = 0xDEAD;
+    }
+#endif
+    register intptr_t inout __asm__("$r4") = nr;
+    register const intptr_t* data __asm__("$r10") = args;
+    asm volatile("bl SyscallAsm\n"
+                 : "=r"(inout)
+                 : "0"(inout), "r"(data)
+                 : "memory", "$r5", "$r6", "$r7", "$r8", "$r9", "$r11", "$r1");
+    ret = inout;
+  }
 
 #else
 #error "Unimplemented architecture"
diff --git a/sandbox/linux/seccomp-bpf/syscall_unittest.cc b/sandbox/linux/seccomp-bpf/syscall_unittest.cc
index 9667feaae8..fa8e9743f8 100644
--- a/sandbox/linux/seccomp-bpf/syscall_unittest.cc
+++ b/sandbox/linux/seccomp-bpf/syscall_unittest.cc
@@ -65,6 +65,8 @@ TEST(Syscall, WellKnownEntryPoint) {
   EXPECT_EQ(0x0cu, (((uint32_t*)Syscall::Call(-1))[-1]) & 0x0000FFFF);
 #elif defined(__aarch64__)
   EXPECT_EQ(0xD4000001u, ((uint32_t*)Syscall::Call(-1))[-1]);  // SVC 0
+#elif defined(__loongarch__)
+  EXPECT_EQ(0x2B0000u, ((uint32_t*)Syscall::Call(-1))[-1]);  // syscall 0
 #else
 #warning Incomplete test case; need port for target platform
 #endif
diff --git a/sandbox/linux/services/credentials.cc b/sandbox/linux/services/credentials.cc
index e284c59d23..5257bddc7c 100644
--- a/sandbox/linux/services/credentials.cc
+++ b/sandbox/linux/services/credentials.cc
@@ -80,7 +80,7 @@ bool ChrootToSafeEmptyDir() {
   pid_t pid = -1;
   alignas(16) char stack_buf[PTHREAD_STACK_MIN];
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONG_FAMILY)
   // The stack grows downward.
   void* stack = stack_buf + sizeof(stack_buf);
 #else
diff --git a/sandbox/linux/services/syscall_wrappers.cc b/sandbox/linux/services/syscall_wrappers.cc
index 7650e983b3..255d20a993 100644
--- a/sandbox/linux/services/syscall_wrappers.cc
+++ b/sandbox/linux/services/syscall_wrappers.cc
@@ -58,10 +58,10 @@ long sys_clone(unsigned long flags,
   if (ctid) MSAN_UNPOISON(ctid, sizeof(*ctid));
   // See kernel/fork.c in Linux. There is different ordering of sys_clone
   // parameters depending on CONFIG_CLONE_BACKWARDS* configuration options.
-#if defined(ARCH_CPU_X86_64)
+#if defined(ARCH_CPU_X86_64) || defined(LOONGARCH_NOT_LEGACY)
   return syscall(__NR_clone, flags, child_stack, ptid, ctid, tls);
 #elif defined(ARCH_CPU_X86) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(LOONGARCH_IS_LEGACY)
   // CONFIG_CLONE_BACKWARDS defined.
   return syscall(__NR_clone, flags, child_stack, ptid, tls, ctid);
 #endif
@@ -163,9 +163,62 @@ int sys_sigaction(int signum,
   return sigaction(signum, act, oldact);
 }
 
+void statx_to_stat(struct kernel_stat* to, struct kernel_statx* from) {
+  memset(to, 0, sizeof(struct kernel_stat));
+  to->st_dev = ((from->stx_dev_minor & 0xff) | (from->stx_dev_major << 8) |
+                ((from->stx_dev_minor & ~0xff) << 12));
+  to->st_rdev = ((from->stx_rdev_minor & 0xff) | (from->stx_rdev_major << 8) |
+                 ((from->stx_rdev_minor & ~0xff) << 12));
+  to->st_ino = from->stx_ino;
+  to->st_mode = from->stx_mode;
+  to->st_nlink = from->stx_nlink;
+  to->st_uid = from->stx_uid;
+  to->st_gid = from->stx_gid;
+  to->st_atime_ = from->stx_atime.tv_sec;
+  to->st_atime_nsec_ = from->stx_atime.tv_nsec;
+  to->st_mtime_ = from->stx_mtime.tv_sec;
+  to->st_mtime_nsec_ = from->stx_mtime.tv_nsec;
+  to->st_ctime_ = from->stx_ctime.tv_sec;
+  to->st_ctime_nsec_ = from->stx_ctime.tv_nsec;
+  to->st_size = from->stx_size;
+  to->st_blocks = from->stx_blocks;
+  to->st_blksize = from->stx_blksize;
+}
+
+int sys_statx(int fd,
+              const char* path,
+              int flags,
+              unsigned int mask,
+              struct kernel_statx* statx_buf) {
+#if defined(__NR_statx)
+  int res;
+  res = syscall(__NR_statx, fd, path, flags, mask, statx_buf);
+  if (res == 0) {
+    MSAN_UNPOISON(statx_buf, sizeof(*statx_buf));
+  }
+  return res;
+#else  // defined(__NR_statx)
+  RAW_CHECK(false);
+  return -ENOSYS;
+#endif
+}
+
 int sys_stat(const char* path, struct kernel_stat* stat_buf) {
   int res;
-#if !defined(__NR_stat)
+#if defined(__NR_statx)
+  kernel_statx statx_buf;
+  res = sys_statx(AT_FDCWD, path, AT_STATX_SYNC_AS_STAT, STATX_BASIC_STATS,
+                  &statx_buf);
+  // TODO(loongarch): better way to handle EFAULT?
+  if (reinterpret_cast<long>(stat_buf) & 0x7) {
+      res = sys_statx(AT_FDCWD, path, AT_STATX_SYNC_AS_STAT, STATX_BASIC_STATS,
+                  reinterpret_cast<kernel_statx*>(NULL));
+      return res;
+  }
+  if (res == 0) {
+    statx_to_stat(stat_buf, &statx_buf);
+  }
+#elif !defined(__NR_stat)
   res = syscall(__NR_newfstatat, AT_FDCWD, path, stat_buf, 0);
 #else
   res = syscall(__NR_stat, path, stat_buf);
@@ -177,7 +230,15 @@ int sys_stat(const char* path, struct kernel_stat* stat_buf) {
 
 int sys_lstat(const char* path, struct kernel_stat* stat_buf) {
   int res;
-#if !defined(__NR_lstat)
+#if defined(__NR_statx)
+  kernel_statx statx_buf;
+  int flag = 0;
+  flag = AT_NO_AUTOMOUNT | AT_SYMLINK_NOFOLLOW;
+  res = sys_statx(AT_FDCWD, path, flag, STATX_BASIC_STATS, &statx_buf);
+  if (res == 0) {
+    statx_to_stat(stat_buf, &statx_buf);
+  }
+#elif !defined(__NR_lstat)
   res = syscall(__NR_newfstatat, AT_FDCWD, path, stat_buf, AT_SYMLINK_NOFOLLOW);
 #else
   res = syscall(__NR_lstat, path, stat_buf);
diff --git a/sandbox/linux/services/syscall_wrappers.h b/sandbox/linux/services/syscall_wrappers.h
index a05d447022..1342a5634f 100644
--- a/sandbox/linux/services/syscall_wrappers.h
+++ b/sandbox/linux/services/syscall_wrappers.h
@@ -19,6 +19,7 @@ struct cap_hdr;
 struct cap_data;
 struct kernel_stat;
 struct kernel_stat64;
+struct kernel_statx;
 
 namespace sandbox {
 
@@ -87,8 +88,8 @@ SANDBOX_EXPORT int sys_sigaction(int signum,
                                  struct sigaction* oldact);
 
 // Some architectures do not have stat() and lstat() syscalls. In that case,
-// these wrappers will use newfstatat(), which is available on all other
-// architectures, with the same capabilities as stat() and lstat().
+// these wrappers will use statx() or newfstatat(), which is available on all
+// other architectures, with the same capabilities as stat() and lstat().
 SANDBOX_EXPORT int sys_stat(const char* path, struct kernel_stat* stat_buf);
 SANDBOX_EXPORT int sys_lstat(const char* path, struct kernel_stat* stat_buf);
 
@@ -98,6 +99,13 @@ SANDBOX_EXPORT int sys_fstatat64(int dirfd,
                                  const char* pathname,
                                  struct kernel_stat64* stat_buf,
                                  int flags);
+// Takes care of unpoisoning |stat_buf| for MSAN. Check-fails if statx() is
+// not a supported syscall on the current platform.
+SANDBOX_EXPORT int sys_statx(int fd,
+                             const char* path,
+                             int flags,
+                             unsigned int mask,
+                             struct kernel_statx* statx_buf);
 
 }  // namespace sandbox
 
diff --git a/sandbox/linux/syscall_broker/broker_client.cc b/sandbox/linux/syscall_broker/broker_client.cc
index 679ff420d0..650f8b09bf 100644
--- a/sandbox/linux/syscall_broker/broker_client.cc
+++ b/sandbox/linux/syscall_broker/broker_client.cc
@@ -193,6 +193,23 @@ int BrokerClient::Stat64(const char* pathname,
                            sizeof(*sb));
 }
 
+int BrokerClient::Statx(const char* pathname,
+                        bool follow_links,
+                        struct kernel_statx* sb) const {
+  if (!pathname || !sb) {
+    return -EFAULT;
+  }
+
+
+  if (fast_check_in_client_ &&
+      !CommandStatIsSafe(policy_->allowed_command_set,
+                         *policy_->file_permissions, pathname)) {
+    return -policy_->file_permissions->denied_errno();
+  }
+  return StatFamilySyscall(COMMAND_STATX, pathname, follow_links, sb,
+                           sizeof(*sb));
+}
+
 int BrokerClient::Unlink(const char* path) const {
   if (!path)
     return -EFAULT;
diff --git a/sandbox/linux/syscall_broker/broker_client.h b/sandbox/linux/syscall_broker/broker_client.h
index 9d0fdee5f3..e14f468385 100644
--- a/sandbox/linux/syscall_broker/broker_client.h
+++ b/sandbox/linux/syscall_broker/broker_client.h
@@ -67,6 +67,10 @@ class SANDBOX_EXPORT BrokerClient : public SyscallDispatcher {
   int Stat64(const char* pathname,
              bool follow_links,
              struct kernel_stat64* sb) const override;
+  int Statx(const char* pathname,
+            bool follow_links,
+            struct kernel_statx* sb) const override;
+
   int Unlink(const char* unlink) const override;
   int InotifyAddWatch(int fd,
                       const char* pathname,
diff --git a/sandbox/linux/syscall_broker/broker_command.h b/sandbox/linux/syscall_broker/broker_command.h
index d44c42fe2b..5fd22d8186 100644
--- a/sandbox/linux/syscall_broker/broker_command.h
+++ b/sandbox/linux/syscall_broker/broker_command.h
@@ -42,6 +42,7 @@ enum BrokerCommand {
   COMMAND_RMDIR,
   COMMAND_STAT,
   COMMAND_STAT64,
+  COMMAND_STATX,
   COMMAND_UNLINK,
   COMMAND_INOTIFY_ADD_WATCH,
 
diff --git a/sandbox/linux/syscall_broker/broker_host.cc b/sandbox/linux/syscall_broker/broker_host.cc
index 8447121007..c2fbfdfd4f 100644
--- a/sandbox/linux/syscall_broker/broker_host.cc
+++ b/sandbox/linux/syscall_broker/broker_host.cc
@@ -286,7 +286,21 @@ void BrokerHost::StatFileForIPC(BrokerCommand command_type,
     RAW_CHECK(
         reply->AddDataToMessage(reinterpret_cast<char*>(&sb), sizeof(sb)));
   } else {
-#if defined(__NR_fstatat64)
+#if defined(__NR_statx)
+    DCHECK(command_type == COMMAND_STATX);
+    struct kernel_statx sb;
+
+    int sts = sandbox::sys_statx(AT_FDCWD, file_to_access,
+                                 follow_links ? 0 : AT_SYMLINK_NOFOLLOW,
+                                 STATX_BASIC_STATS, &sb);
+    if (sts < 0) {
+      RAW_CHECK(reply->AddIntToMessage(-errno));
+      return;
+    }
+    RAW_CHECK(reply->AddIntToMessage(0));
+    RAW_CHECK(
+        reply->AddDataToMessage(reinterpret_cast<char*>(&sb), sizeof(sb)));
+#elif defined(__NR_fstatat64)
     DCHECK(command_type == COMMAND_STAT64);
     struct kernel_stat64 sb;
 
@@ -438,7 +452,8 @@ bool BrokerHost::HandleRemoteCommand(BrokerSimpleMessage* message,
       break;
     }
     case COMMAND_STAT:
-    case COMMAND_STAT64: {
+    case COMMAND_STAT64:
+    case COMMAND_STATX: {
       const char* requested_filename;
       if (!message->ReadString(&requested_filename)) {
         return false;
diff --git a/sandbox/linux/syscall_broker/broker_process.cc b/sandbox/linux/syscall_broker/broker_process.cc
index a55b548a8e..662c51e8e4 100644
--- a/sandbox/linux/syscall_broker/broker_process.cc
+++ b/sandbox/linux/syscall_broker/broker_process.cc
@@ -122,44 +122,44 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
   // and are default disabled in Android. So, we should refuse to broker them
   // to be consistent with the platform's restrictions.
   switch (sysno) {
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch64)
     case __NR_access:
 #endif
     case __NR_faccessat:
     case __NR_faccessat2:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_ACCESS);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch64)
     case __NR_mkdir:
 #endif
     case __NR_mkdirat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_MKDIR);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch64)
     case __NR_open:
 #endif
     case __NR_openat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_OPEN);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch64)
     case __NR_readlink:
 #endif
     case __NR_readlinkat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_READLINK);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch64)
     case __NR_rename:
 #endif
     case __NR_renameat:
     case __NR_renameat2:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_RENAME);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch64)
     case __NR_rmdir:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_RMDIR);
 #endif
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch64)
     case __NR_stat:
     case __NR_lstat:
 #endif
@@ -169,8 +169,11 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
 #if defined(__NR_fstatat64)
     case __NR_fstatat64:
 #endif
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(LOONGARCH_IS_LEGACY)
     case __NR_newfstatat:
+#endif
+#if defined(LOONGARCH_NOT_LEGACY)
+    case __NR_statx:
 #endif
       return !fast_check || policy_->allowed_command_set.test(COMMAND_STAT);
 
@@ -184,7 +187,7 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
       return !fast_check || policy_->allowed_command_set.test(COMMAND_STAT);
 #endif
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch64)
     case __NR_unlink:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_UNLINK);
 #endif
diff --git a/sandbox/linux/syscall_broker/broker_process_unittest.cc b/sandbox/linux/syscall_broker/broker_process_unittest.cc
index cb85c87f2c..df3c542e6d 100644
--- a/sandbox/linux/syscall_broker/broker_process_unittest.cc
+++ b/sandbox/linux/syscall_broker/broker_process_unittest.cc
@@ -880,6 +880,9 @@ TEST(BrokerProcess, CreateFile) {
   unlink(permfile_name);
 }
 
+// Use statx instead of stat,lstat and fstatat on loongarch64 architecture,
+// So not test run TestStatHelper on loongarch64 abi2.0.
+#if !defined(LOONGARCH_NOT_LEGACY)
 void TestStatHelper(bool fast_check_in_client, bool follow_links) {
   ScopedTemporaryFile tmp_file;
   EXPECT_EQ(12, write(tmp_file.fd(), "blahblahblah", 12));
@@ -1092,6 +1095,7 @@ TEST(BrokerProcess, StatFileHost) {
   TestStatHelper(false, true);
   TestStatHelper(false, false);
 }
+#endif
 
 void TestRenameHelper(bool fast_check_in_client) {
   std::string oldpath;
@@ -1996,12 +2000,14 @@ TEST(BrokerProcess, IsSyscallAllowed) {
         __NR_readlink
 #endif
        }},
+#if !defined(__loongarch64)
       {COMMAND_RENAME,
        {__NR_renameat,
 #if defined(__NR_rename) && !BUILDFLAG(IS_ANDROID)
         __NR_rename
 #endif
        }},
+#endif
       {COMMAND_UNLINK,
        {__NR_unlinkat,
 #if defined(__NR_unlink) && !BUILDFLAG(IS_ANDROID)
diff --git a/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc b/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc
index 15b2ee66d4..12ccb0b5d9 100644
--- a/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc
+++ b/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc
@@ -28,7 +28,11 @@ namespace {
 const char kPathPart[] = "/i/am/path";
 
 void FillBufferWithPath(char* buf, size_t size, bool null_terminate) {
+#if defined(__loongarch64)
+  SANDBOX_ASSERT_LE(size, static_cast<size_t>(PATH_MAX)*4);
+#else
   SANDBOX_ASSERT_LE(size, static_cast<size_t>(PATH_MAX));
+#endif
   size_t str_len = strlen(kPathPart);
   size_t len_left_to_write = size;
   char* curr_buf_pos = buf;
diff --git a/sandbox/linux/syscall_broker/syscall_dispatcher.cc b/sandbox/linux/syscall_broker/syscall_dispatcher.cc
index 6abc80b432..a0cdbf482c 100644
--- a/sandbox/linux/syscall_broker/syscall_dispatcher.cc
+++ b/sandbox/linux/syscall_broker/syscall_dispatcher.cc
@@ -26,6 +26,8 @@ int SyscallDispatcher::DefaultStatForTesting(const char* pathname,
   return Stat64(pathname, follow_links, sb);
 #elif defined(__NR_newfstatat)
   return Stat(pathname, follow_links, sb);
+#elif defined(__NR_statx)
+  return Statx(pathname, follow_links, sb);
 #endif
 }
 
@@ -191,6 +193,11 @@ int SyscallDispatcher::DispatchSyscall(const arch_seccomp_data& args) {
     case __NR_newfstatat:
       return PerformStatat(args, /*stat64=*/false);
 #endif
+#if defined(__NR_statx)
+    case __NR_statx:
+      return Statx(reinterpret_cast<const char*>(args.args[1]), true,
+                   reinterpret_cast<struct kernel_statx*>(args.args[4]));
+#endif
 #if defined(__NR_unlink)
     case __NR_unlink:
       return Unlink(reinterpret_cast<const char*>(args.args[0]));
diff --git a/sandbox/linux/syscall_broker/syscall_dispatcher.h b/sandbox/linux/syscall_broker/syscall_dispatcher.h
index 906c37d922..7d0b8e0351 100644
--- a/sandbox/linux/syscall_broker/syscall_dispatcher.h
+++ b/sandbox/linux/syscall_broker/syscall_dispatcher.h
@@ -49,6 +49,9 @@ class SANDBOX_EXPORT SyscallDispatcher {
   virtual int Stat64(const char* pathname,
                      bool follow_links,
                      struct kernel_stat64* sb) const = 0;
+  virtual int Statx(const char* pathname,
+                    bool follow_links,
+                    struct kernel_statx* sb) const = 0;
 
   // Emulates unlink()/unlinkat().
   virtual int Unlink(const char* unlink) const = 0;
diff --git a/sandbox/linux/system_headers/linux_seccomp.h b/sandbox/linux/system_headers/linux_seccomp.h
index 8690a96eb0..97638236f4 100644
--- a/sandbox/linux/system_headers/linux_seccomp.h
+++ b/sandbox/linux/system_headers/linux_seccomp.h
@@ -39,6 +39,10 @@
 #define EM_AARCH64 183
 #endif
 
+#ifndef EM_LOONGARCH
+#define EM_LOONGARCH 258
+#endif
+
 #ifndef __AUDIT_ARCH_64BIT
 #define __AUDIT_ARCH_64BIT 0x80000000
 #endif
@@ -71,6 +75,10 @@
 #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
 #endif
 
+#ifndef AUDIT_ARCH_LOONGARCH64
+#define AUDIT_ARCH_LOONGARCH64 (EM_LOONGARCH | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
+#endif
+
 // For prctl.h
 #ifndef PR_SET_SECCOMP
 #define PR_SET_SECCOMP               22
diff --git a/sandbox/linux/system_headers/linux_signal.h b/sandbox/linux/system_headers/linux_signal.h
index 69ccaf1081..ba3daf7e23 100644
--- a/sandbox/linux/system_headers/linux_signal.h
+++ b/sandbox/linux/system_headers/linux_signal.h
@@ -13,7 +13,7 @@
 // (not undefined, but defined different values and in different memory
 // layouts). So, fill the gap here.
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch64)
 
 #define LINUX_SIGHUP 1
 #define LINUX_SIGINT 2
@@ -97,7 +97,8 @@ typedef siginfo_t LinuxSigInfo;
 struct LinuxSigSet {
   unsigned long sig[_NSIG_WORDS];
 };
-#elif defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)
+#elif defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS) || \
+    defined(ARCH_CPU_LOONG_FAMILY)
 #if !defined(_NSIG_WORDS)
 #define _NSIG_WORDS 2
 #endif
diff --git a/sandbox/linux/system_headers/linux_stat.h b/sandbox/linux/system_headers/linux_stat.h
index 3aae8cbced..59d4973c78 100644
--- a/sandbox/linux/system_headers/linux_stat.h
+++ b/sandbox/linux/system_headers/linux_stat.h
@@ -150,7 +150,7 @@ struct kernel_stat {
   int st_blocks;
   int st_pad4[14];
 };
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch__)
 struct kernel_stat {
   unsigned long st_dev;
   unsigned long st_ino;
@@ -174,6 +174,37 @@ struct kernel_stat {
   unsigned int __unused5;
 };
 #endif
+// #elif defined(LOONGARCH_NOT_LEGACY)
+// kernel_statx is used without ifdef wrapper, so this needs to be implemented
+// for other platforms too.
+struct kernel_statx_timestamp {
+  long tv_sec;
+  unsigned int tv_nsec;
+  int __reserved;
+};
+struct kernel_statx {
+  unsigned int stx_mask;
+  unsigned int stx_blksize;
+  unsigned long stx_attributes;
+  unsigned int stx_nlink;
+  unsigned int stx_uid;
+  unsigned int stx_gid;
+  unsigned short stx_mode;
+  unsigned short __spare0[1];
+  unsigned long stx_ino;
+  unsigned long stx_size;
+  unsigned long stx_blocks;
+  unsigned long stx_attributes_mask;
+  struct kernel_statx_timestamp stx_atime;
+  struct kernel_statx_timestamp stx_btime;
+  struct kernel_statx_timestamp stx_ctime;
+  struct kernel_statx_timestamp stx_mtime;
+  unsigned int stx_rdev_major;
+  unsigned int stx_rdev_minor;
+  unsigned int stx_dev_major;
+  unsigned int stx_dev_minor;
+  unsigned long __spare2[14];
+};
 
 #if !defined(AT_EMPTY_PATH)
 #define AT_EMPTY_PATH 0x1000
@@ -191,6 +222,9 @@ struct kernel_stat {
 // different syscall names on 32 and 64-bit platforms.
 #if defined(__NR_fstatat64)
 
+#if defined(LOONGARCH_NOT_LEGACY)
+#error "new world loongarch doesn't support fstatat64"
+#endif
 namespace sandbox {
 using default_stat_struct = struct kernel_stat64;
 }  // namespace sandbox
@@ -199,7 +233,9 @@ using default_stat_struct = struct kernel_stat64;
 #define __NR_fstat_default __NR_fstat64
 
 #elif defined(__NR_newfstatat)
-
+#if defined(LOONGARCH_NOT_LEGACY)
+#error "new world loongarch doesn't support newfstatat"
+#endif
 namespace sandbox {
 using default_stat_struct = struct kernel_stat;
 }  // namespace sandbox
@@ -207,8 +243,25 @@ using default_stat_struct = struct kernel_stat;
 #define __NR_fstatat_default __NR_newfstatat
 #define __NR_fstat_default __NR_fstat
 
+#elif defined(__NR_statx)
+
+namespace sandbox {
+using default_stat_struct = struct kernel_statx;
+using default_fstatat_struct = struct kernel_statx;
+}  // namespace sandbox
+
+#define AT_STATX_SYNC_TYPE 0x6000
+#define AT_STATX_SYNC_AS_STAT 0x0000
+#define AT_STATX_FORCE_SYNC 0x2000
+#define AT_STATX_DONT_SYNC 0x4000
+#define STATX_ALL 0x00000fffU
+
+// #define __NR_fstat_default 80
+// #define __NR_fstatat_default 79
+#define __NR_statx_default __NR_statx
+
 #else
-#error "one of fstatat64 and newfstatat must be defined"
+#error "one of fstatat64, newfstatat and statx must be defined"
 #endif
 
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_STAT_H_
diff --git a/sandbox/linux/system_headers/linux_syscalls.h b/sandbox/linux/system_headers/linux_syscalls.h
index 438147b401..c7f0f82f7d 100644
--- a/sandbox/linux/system_headers/linux_syscalls.h
+++ b/sandbox/linux/system_headers/linux_syscalls.h
@@ -35,5 +35,9 @@
 #include "sandbox/linux/system_headers/arm64_linux_syscalls.h"
 #endif
 
+#if defined(__loongarch64)
+#include "sandbox/linux/system_headers/loong64_linux_syscalls.h"
+#endif
+
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_SYSCALLS_H_
 
diff --git a/sandbox/linux/system_headers/loong64_linux_syscalls.h b/sandbox/linux/system_headers/loong64_linux_syscalls.h
new file mode 100644
index 0000000000..9ab06aa870
--- /dev/null
+++ b/sandbox/linux/system_headers/loong64_linux_syscalls.h
@@ -0,0 +1,1223 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_LOONG64_LINUX_SYSCALLS_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_LOONG64_LINUX_SYSCALLS_H_
+
+#if !defined(__loongarch__)
+#error "Including header on wrong architecture"
+#endif
+#include <asm/unistd.h>
+
+#if !defined(__NR_io_setup)
+#define __NR_io_setup 0
+#endif
+
+#if !defined(__NR_io_destroy)
+#define __NR_io_destroy 1
+#endif
+
+#if !defined(__NR_io_submit)
+#define __NR_io_submit 2
+#endif
+
+#if !defined(__NR_io_cancel)
+#define __NR_io_cancel 3
+#endif
+
+#if !defined(__NR_io_getevents)
+#define __NR_io_getevents 4
+#endif
+
+#if !defined(__NR_setxattr)
+#define __NR_setxattr 5
+#endif
+
+#if !defined(__NR_lsetxattr)
+#define __NR_lsetxattr 6
+#endif
+
+#if !defined(__NR_fsetxattr)
+#define __NR_fsetxattr 7
+#endif
+
+#if !defined(__NR_getxattr)
+#define __NR_getxattr 8
+#endif
+
+#if !defined(__NR_lgetxattr)
+#define __NR_lgetxattr 9
+#endif
+
+#if !defined(__NR_fgetxattr)
+#define __NR_fgetxattr 10
+#endif
+
+#if !defined(__NR_listxattr)
+#define __NR_listxattr 11
+#endif
+
+#if !defined(__NR_llistxattr)
+#define __NR_llistxattr 12
+#endif
+
+#if !defined(__NR_flistxattr)
+#define __NR_flistxattr 13
+#endif
+
+#if !defined(__NR_removexattr)
+#define __NR_removexattr 14
+#endif
+
+#if !defined(__NR_lremovexattr)
+#define __NR_lremovexattr 15
+#endif
+
+#if !defined(__NR_fremovexattr)
+#define __NR_fremovexattr 16
+#endif
+
+#if !defined(__NR_getcwd)
+#define __NR_getcwd 17
+#endif
+
+#if !defined(__NR_lookup_dcookie)
+#define __NR_lookup_dcookie 18
+#endif
+
+#if !defined(__NR_eventfd2)
+#define __NR_eventfd2 19
+#endif
+
+#if !defined(__NR_epoll_create1)
+#define __NR_epoll_create1 20
+#endif
+
+#if !defined(__NR_epoll_ctl)
+#define __NR_epoll_ctl 21
+#endif
+
+#if !defined(__NR_epoll_pwait)
+#define __NR_epoll_pwait 22
+#endif
+
+#if !defined(__NR_dup)
+#define __NR_dup 23
+#endif
+
+#if !defined(__NR_dup3)
+#define __NR_dup3 24
+#endif
+
+#if !defined(__NR_fcntl)
+#define __NR_fcntl 25
+#endif
+
+#if !defined(__NR_inotify_init1)
+#define __NR_inotify_init1 26
+#endif
+
+#if !defined(__NR_inotify_add_watch)
+#define __NR_inotify_add_watch 27
+#endif
+
+#if !defined(__NR_inotify_rm_watch)
+#define __NR_inotify_rm_watch 28
+#endif
+
+#if !defined(__NR_ioctl)
+#define __NR_ioctl 29
+#endif
+
+#if !defined(__NR_ioprio_set)
+#define __NR_ioprio_set 30
+#endif
+
+#if !defined(__NR_ioprio_get)
+#define __NR_ioprio_get 31
+#endif
+
+#if !defined(__NR_flock)
+#define __NR_flock 32
+#endif
+
+#if !defined(__NR_mknodat)
+#define __NR_mknodat 33
+#endif
+
+#if !defined(__NR_mkdirat)
+#define __NR_mkdirat 34
+#endif
+
+#if !defined(__NR_unlinkat)
+#define __NR_unlinkat 35
+#endif
+
+#if !defined(__NR_symlinkat)
+#define __NR_symlinkat 36
+#endif
+
+#if !defined(__NR_linkat)
+#define __NR_linkat 37
+#endif
+
+#if !defined(__NR_renameat)
+#define __NR_renameat 38
+#endif
+
+#if !defined(__NR_umount2)
+#define __NR_umount2 39
+#endif
+
+#if !defined(__NR_mount)
+#define __NR_mount 40
+#endif
+
+#if !defined(__NR_pivot_root)
+#define __NR_pivot_root 41
+#endif
+
+#if !defined(__NR_nfsservctl)
+#define __NR_nfsservctl 42
+#endif
+
+#if !defined(__NR_statfs)
+#define __NR_statfs 43
+#endif
+
+#if !defined(__NR_fstatfs)
+#define __NR_fstatfs 44
+#endif
+
+#if !defined(__NR_truncate)
+#define __NR_truncate 45
+#endif
+
+#if !defined(__NR_ftruncate)
+#define __NR_ftruncate 46
+#endif
+
+#if !defined(__NR_fallocate)
+#define __NR_fallocate 47
+#endif
+
+#if !defined(__NR_faccessat)
+#define __NR_faccessat 48
+#endif
+
+#if !defined(__NR_chdir)
+#define __NR_chdir 49
+#endif
+
+#if !defined(__NR_fchdir)
+#define __NR_fchdir 50
+#endif
+
+#if !defined(__NR_chroot)
+#define __NR_chroot 51
+#endif
+
+#if !defined(__NR_fchmod)
+#define __NR_fchmod 52
+#endif
+
+#if !defined(__NR_fchmodat)
+#define __NR_fchmodat 53
+#endif
+
+#if !defined(__NR_fchownat)
+#define __NR_fchownat 54
+#endif
+
+#if !defined(__NR_fchown)
+#define __NR_fchown 55
+#endif
+
+#if !defined(__NR_openat)
+#define __NR_openat 56
+#endif
+
+#if !defined(__NR_close)
+#define __NR_close 57
+#endif
+
+#if !defined(__NR_vhangup)
+#define __NR_vhangup 58
+#endif
+
+#if !defined(__NR_pipe2)
+#define __NR_pipe2 59
+#endif
+
+#if !defined(__NR_quotactl)
+#define __NR_quotactl 60
+#endif
+
+#if !defined(__NR_getdents64)
+#define __NR_getdents64 61
+#endif
+
+#if !defined(__NR_lseek)
+#define __NR_lseek 62
+#endif
+
+#if !defined(__NR_read)
+#define __NR_read 63
+#endif
+
+#if !defined(__NR_write)
+#define __NR_write 64
+#endif
+
+#if !defined(__NR_readv)
+#define __NR_readv 65
+#endif
+
+#if !defined(__NR_writev)
+#define __NR_writev 66
+#endif
+
+#if !defined(__NR_pread64)
+#define __NR_pread64 67
+#endif
+
+#if !defined(__NR_pwrite64)
+#define __NR_pwrite64 68
+#endif
+
+#if !defined(__NR_preadv)
+#define __NR_preadv 69
+#endif
+
+#if !defined(__NR_pwritev)
+#define __NR_pwritev 70
+#endif
+
+#if !defined(__NR_sendfile)
+#define __NR_sendfile 71
+#endif
+
+#if !defined(__NR_pselect6)
+#define __NR_pselect6 72
+#endif
+
+#if !defined(__NR_ppoll)
+#define __NR_ppoll 73
+#endif
+
+#if !defined(__NR_signalfd4)
+#define __NR_signalfd4 74
+#endif
+
+#if !defined(__NR_vmsplice)
+#define __NR_vmsplice 75
+#endif
+
+#if !defined(__NR_splice)
+#define __NR_splice 76
+#endif
+
+#if !defined(__NR_tee)
+#define __NR_tee 77
+#endif
+
+#if !defined(__NR_readlinkat)
+#define __NR_readlinkat 78
+#endif
+
+#if defined(__ARCH_WANT_NEW_STAT) || defined(__ARCH_WANT_STAT64)
+#if !defined(__NR_newfstatat)
+#define __NR_newfstatat 79
+#endif
+
+#if !defined(__NR_fstat)
+#define __NR_fstat 80
+#endif
+#endif
+
+#if !defined(__NR_sync)
+#define __NR_sync 81
+#endif
+
+#if !defined(__NR_fsync)
+#define __NR_fsync 82
+#endif
+
+#if !defined(__NR_fdatasync)
+#define __NR_fdatasync 83
+#endif
+
+#if !defined(__NR_sync_file_range)
+#define __NR_sync_file_range 84
+#endif
+
+#if !defined(__NR_timerfd_create)
+#define __NR_timerfd_create 85
+#endif
+
+#if !defined(__NR_timerfd_settime)
+#define __NR_timerfd_settime 86
+#endif
+
+#if !defined(__NR_timerfd_gettime)
+#define __NR_timerfd_gettime 87
+#endif
+
+#if !defined(__NR_utimensat)
+#define __NR_utimensat 88
+#endif
+
+#if !defined(__NR_acct)
+#define __NR_acct 89
+#endif
+
+#if !defined(__NR_capget)
+#define __NR_capget 90
+#endif
+
+#if !defined(__NR_capset)
+#define __NR_capset 91
+#endif
+
+#if !defined(__NR_personality)
+#define __NR_personality 92
+#endif
+
+#if !defined(__NR_exit)
+#define __NR_exit 93
+#endif
+
+#if !defined(__NR_exit_group)
+#define __NR_exit_group 94
+#endif
+
+#if !defined(__NR_waitid)
+#define __NR_waitid 95
+#endif
+
+#if !defined(__NR_set_tid_address)
+#define __NR_set_tid_address 96
+#endif
+
+#if !defined(__NR_unshare)
+#define __NR_unshare 97
+#endif
+
+#if !defined(__NR_futex)
+#define __NR_futex 98
+#endif
+
+#if !defined(__NR_set_robust_list)
+#define __NR_set_robust_list 99
+#endif
+
+#if !defined(__NR_get_robust_list)
+#define __NR_get_robust_list 100
+#endif
+
+#if !defined(__NR_nanosleep)
+#define __NR_nanosleep 101
+#endif
+
+#if !defined(__NR_getitimer)
+#define __NR_getitimer 102
+#endif
+
+#if !defined(__NR_setitimer)
+#define __NR_setitimer 103
+#endif
+
+#if !defined(__NR_kexec_load)
+#define __NR_kexec_load 104
+#endif
+
+#if !defined(__NR_init_module)
+#define __NR_init_module 105
+#endif
+
+#if !defined(__NR_delete_module)
+#define __NR_delete_module 106
+#endif
+
+#if !defined(__NR_timer_create)
+#define __NR_timer_create 107
+#endif
+
+#if !defined(__NR_timer_gettime)
+#define __NR_timer_gettime 108
+#endif
+
+#if !defined(__NR_timer_getoverrun)
+#define __NR_timer_getoverrun 109
+#endif
+
+#if !defined(__NR_timer_settime)
+#define __NR_timer_settime 110
+#endif
+
+#if !defined(__NR_timer_delete)
+#define __NR_timer_delete 111
+#endif
+
+#if !defined(__NR_clock_settime)
+#define __NR_clock_settime 112
+#endif
+
+#if !defined(__NR_clock_gettime)
+#define __NR_clock_gettime 113
+#endif
+
+#if !defined(__NR_clock_getres)
+#define __NR_clock_getres 114
+#endif
+
+#if !defined(__NR_clock_nanosleep)
+#define __NR_clock_nanosleep 115
+#endif
+
+#if !defined(__NR_syslog)
+#define __NR_syslog 116
+#endif
+
+#if !defined(__NR_ptrace)
+#define __NR_ptrace 117
+#endif
+
+#if !defined(__NR_sched_setparam)
+#define __NR_sched_setparam 118
+#endif
+
+#if !defined(__NR_sched_setscheduler)
+#define __NR_sched_setscheduler 119
+#endif
+
+#if !defined(__NR_sched_getscheduler)
+#define __NR_sched_getscheduler 120
+#endif
+
+#if !defined(__NR_sched_getparam)
+#define __NR_sched_getparam 121
+#endif
+
+#if !defined(__NR_sched_setaffinity)
+#define __NR_sched_setaffinity 122
+#endif
+
+#if !defined(__NR_sched_getaffinity)
+#define __NR_sched_getaffinity 123
+#endif
+
+#if !defined(__NR_sched_yield)
+#define __NR_sched_yield 124
+#endif
+
+#if !defined(__NR_sched_get_priority_max)
+#define __NR_sched_get_priority_max 125
+#endif
+
+#if !defined(__NR_sched_get_priority_min)
+#define __NR_sched_get_priority_min 126
+#endif
+
+#if !defined(__NR_sched_rr_get_interval)
+#define __NR_sched_rr_get_interval 127
+#endif
+
+#if !defined(__NR_restart_syscall)
+#define __NR_restart_syscall 128
+#endif
+
+#if !defined(__NR_kill)
+#define __NR_kill 129
+#endif
+
+#if !defined(__NR_tkill)
+#define __NR_tkill 130
+#endif
+
+#if !defined(__NR_tgkill)
+#define __NR_tgkill 131
+#endif
+
+#if !defined(__NR_sigaltstack)
+#define __NR_sigaltstack 132
+#endif
+
+#if !defined(__NR_rt_sigsuspend)
+#define __NR_rt_sigsuspend 133
+#endif
+
+#if !defined(__NR_rt_sigaction)
+#define __NR_rt_sigaction 134
+#endif
+
+#if !defined(__NR_rt_sigprocmask)
+#define __NR_rt_sigprocmask 135
+#endif
+
+#if !defined(__NR_rt_sigpending)
+#define __NR_rt_sigpending 136
+#endif
+
+#if !defined(__NR_rt_sigtimedwait)
+#define __NR_rt_sigtimedwait 137
+#endif
+
+#if !defined(__NR_rt_sigqueueinfo)
+#define __NR_rt_sigqueueinfo 138
+#endif
+
+#if !defined(__NR_rt_sigreturn)
+#define __NR_rt_sigreturn 139
+#endif
+
+#if !defined(__NR_setpriority)
+#define __NR_setpriority 140
+#endif
+
+#if !defined(__NR_getpriority)
+#define __NR_getpriority 141
+#endif
+
+#if !defined(__NR_reboot)
+#define __NR_reboot 142
+#endif
+
+#if !defined(__NR_setregid)
+#define __NR_setregid 143
+#endif
+
+#if !defined(__NR_setgid)
+#define __NR_setgid 144
+#endif
+
+#if !defined(__NR_setreuid)
+#define __NR_setreuid 145
+#endif
+
+#if !defined(__NR_setuid)
+#define __NR_setuid 146
+#endif
+
+#if !defined(__NR_setresuid)
+#define __NR_setresuid 147
+#endif
+
+#if !defined(__NR_getresuid)
+#define __NR_getresuid 148
+#endif
+
+#if !defined(__NR_setresgid)
+#define __NR_setresgid 149
+#endif
+
+#if !defined(__NR_getresgid)
+#define __NR_getresgid 150
+#endif
+
+#if !defined(__NR_setfsuid)
+#define __NR_setfsuid 151
+#endif
+
+#if !defined(__NR_setfsgid)
+#define __NR_setfsgid 152
+#endif
+
+#if !defined(__NR_times)
+#define __NR_times 153
+#endif
+
+#if !defined(__NR_setpgid)
+#define __NR_setpgid 154
+#endif
+
+#if !defined(__NR_getpgid)
+#define __NR_getpgid 155
+#endif
+
+#if !defined(__NR_getsid)
+#define __NR_getsid 156
+#endif
+
+#if !defined(__NR_setsid)
+#define __NR_setsid 157
+#endif
+
+#if !defined(__NR_getgroups)
+#define __NR_getgroups 158
+#endif
+
+#if !defined(__NR_setgroups)
+#define __NR_setgroups 159
+#endif
+
+#if !defined(__NR_uname)
+#define __NR_uname 160
+#endif
+
+#if !defined(__NR_sethostname)
+#define __NR_sethostname 161
+#endif
+
+#if !defined(__NR_setdomainname)
+#define __NR_setdomainname 162
+#endif
+
+#if !defined(__NR_getrlimit)
+#define __NR_getrlimit 163
+#endif
+
+#if !defined(__NR_setrlimit)
+#define __NR_setrlimit 164
+#endif
+
+#if !defined(__NR_getrusage)
+#define __NR_getrusage 165
+#endif
+
+#if !defined(__NR_umask)
+#define __NR_umask 166
+#endif
+
+#if !defined(__NR_prctl)
+#define __NR_prctl 167
+#endif
+
+#if !defined(__NR_getcpu)
+#define __NR_getcpu 168
+#endif
+
+#if !defined(__NR_gettimeofday)
+#define __NR_gettimeofday 169
+#endif
+
+#if !defined(__NR_settimeofday)
+#define __NR_settimeofday 170
+#endif
+
+#if !defined(__NR_adjtimex)
+#define __NR_adjtimex 171
+#endif
+
+#if !defined(__NR_getpid)
+#define __NR_getpid 172
+#endif
+
+#if !defined(__NR_getppid)
+#define __NR_getppid 173
+#endif
+
+#if !defined(__NR_getuid)
+#define __NR_getuid 174
+#endif
+
+#if !defined(__NR_geteuid)
+#define __NR_geteuid 175
+#endif
+
+#if !defined(__NR_getgid)
+#define __NR_getgid 176
+#endif
+
+#if !defined(__NR_getegid)
+#define __NR_getegid 177
+#endif
+
+#if !defined(__NR_gettid)
+#define __NR_gettid 178
+#endif
+
+#if !defined(__NR_sysinfo)
+#define __NR_sysinfo 179
+#endif
+
+#if !defined(__NR_mq_open)
+#define __NR_mq_open 180
+#endif
+
+#if !defined(__NR_mq_unlink)
+#define __NR_mq_unlink 181
+#endif
+
+#if !defined(__NR_mq_timedsend)
+#define __NR_mq_timedsend 182
+#endif
+
+#if !defined(__NR_mq_timedreceive)
+#define __NR_mq_timedreceive 183
+#endif
+
+#if !defined(__NR_mq_notify)
+#define __NR_mq_notify 184
+#endif
+
+#if !defined(__NR_mq_getsetattr)
+#define __NR_mq_getsetattr 185
+#endif
+
+#if !defined(__NR_msgget)
+#define __NR_msgget 186
+#endif
+
+#if !defined(__NR_msgctl)
+#define __NR_msgctl 187
+#endif
+
+#if !defined(__NR_msgrcv)
+#define __NR_msgrcv 188
+#endif
+
+#if !defined(__NR_msgsnd)
+#define __NR_msgsnd 189
+#endif
+
+#if !defined(__NR_semget)
+#define __NR_semget 190
+#endif
+
+#if !defined(__NR_semctl)
+#define __NR_semctl 191
+#endif
+
+#if !defined(__NR_semtimedop)
+#define __NR_semtimedop 192
+#endif
+
+#if !defined(__NR_semop)
+#define __NR_semop 193
+#endif
+
+#if !defined(__NR_shmget)
+#define __NR_shmget 194
+#endif
+
+#if !defined(__NR_shmctl)
+#define __NR_shmctl 195
+#endif
+
+#if !defined(__NR_shmat)
+#define __NR_shmat 196
+#endif
+
+#if !defined(__NR_shmdt)
+#define __NR_shmdt 197
+#endif
+
+#if !defined(__NR_socket)
+#define __NR_socket 198
+#endif
+
+#if !defined(__NR_socketpair)
+#define __NR_socketpair 199
+#endif
+
+#if !defined(__NR_bind)
+#define __NR_bind 200
+#endif
+
+#if !defined(__NR_listen)
+#define __NR_listen 201
+#endif
+
+#if !defined(__NR_accept)
+#define __NR_accept 202
+#endif
+
+#if !defined(__NR_connect)
+#define __NR_connect 203
+#endif
+
+#if !defined(__NR_getsockname)
+#define __NR_getsockname 204
+#endif
+
+#if !defined(__NR_getpeername)
+#define __NR_getpeername 205
+#endif
+
+#if !defined(__NR_sendto)
+#define __NR_sendto 206
+#endif
+
+#if !defined(__NR_recvfrom)
+#define __NR_recvfrom 207
+#endif
+
+#if !defined(__NR_setsockopt)
+#define __NR_setsockopt 208
+#endif
+
+#if !defined(__NR_getsockopt)
+#define __NR_getsockopt 209
+#endif
+
+#if !defined(__NR_shutdown)
+#define __NR_shutdown 210
+#endif
+
+#if !defined(__NR_sendmsg)
+#define __NR_sendmsg 211
+#endif
+
+#if !defined(__NR_recvmsg)
+#define __NR_recvmsg 212
+#endif
+
+#if !defined(__NR_readahead)
+#define __NR_readahead 213
+#endif
+
+#if !defined(__NR_brk)
+#define __NR_brk 214
+#endif
+
+#if !defined(__NR_munmap)
+#define __NR_munmap 215
+#endif
+
+#if !defined(__NR_mremap)
+#define __NR_mremap 216
+#endif
+
+#if !defined(__NR_add_key)
+#define __NR_add_key 217
+#endif
+
+#if !defined(__NR_request_key)
+#define __NR_request_key 218
+#endif
+
+#if !defined(__NR_keyctl)
+#define __NR_keyctl 219
+#endif
+
+#if !defined(__NR_clone)
+#define __NR_clone 220
+#endif
+
+#if !defined(__NR_execve)
+#define __NR_execve 221
+#endif
+
+#if !defined(__NR_mmap)
+#define __NR_mmap 222
+#endif
+
+#if !defined(__NR_fadvise64)
+#define __NR_fadvise64 223
+#endif
+
+#if !defined(__NR_swapon)
+#define __NR_swapon 224
+#endif
+
+#if !defined(__NR_swapoff)
+#define __NR_swapoff 225
+#endif
+
+#if !defined(__NR_mprotect)
+#define __NR_mprotect 226
+#endif
+
+#if !defined(__NR_msync)
+#define __NR_msync 227
+#endif
+
+#if !defined(__NR_mlock)
+#define __NR_mlock 228
+#endif
+
+#if !defined(__NR_munlock)
+#define __NR_munlock 229
+#endif
+
+#if !defined(__NR_mlockall)
+#define __NR_mlockall 230
+#endif
+
+#if !defined(__NR_munlockall)
+#define __NR_munlockall 231
+#endif
+
+#if !defined(__NR_mincore)
+#define __NR_mincore 232
+#endif
+
+#if !defined(__NR_madvise)
+#define __NR_madvise 233
+#endif
+
+#if !defined(__NR_remap_file_pages)
+#define __NR_remap_file_pages 234
+#endif
+
+#if !defined(__NR_mbind)
+#define __NR_mbind 235
+#endif
+
+#if !defined(__NR_get_mempolicy)
+#define __NR_get_mempolicy 236
+#endif
+
+#if !defined(__NR_set_mempolicy)
+#define __NR_set_mempolicy 237
+#endif
+
+#if !defined(__NR_migrate_pages)
+#define __NR_migrate_pages 238
+#endif
+
+#if !defined(__NR_move_pages)
+#define __NR_move_pages 239
+#endif
+
+#if !defined(__NR_rt_tgsigqueueinfo)
+#define __NR_rt_tgsigqueueinfo 240
+#endif
+
+#if !defined(__NR_perf_event_open)
+#define __NR_perf_event_open 241
+#endif
+
+#if !defined(__NR_accept4)
+#define __NR_accept4 242
+#endif
+
+#if !defined(__NR_recvmmsg)
+#define __NR_recvmmsg 243
+#endif
+
+#if !defined(__NR_wait4)
+#define __NR_wait4 260
+#endif
+
+#if !defined(__NR_prlimit64)
+#define __NR_prlimit64 261
+#endif
+
+#if !defined(__NR_fanotify_init)
+#define __NR_fanotify_init 262
+#endif
+
+#if !defined(__NR_fanotify_mark)
+#define __NR_fanotify_mark 263
+#endif
+
+#if !defined(__NR_name_to_handle_at)
+#define __NR_name_to_handle_at 264
+#endif
+
+#if !defined(__NR_open_by_handle_at)
+#define __NR_open_by_handle_at 265
+#endif
+
+#if !defined(__NR_clock_adjtime)
+#define __NR_clock_adjtime 266
+#endif
+
+#if !defined(__NR_syncfs)
+#define __NR_syncfs 267
+#endif
+
+#if !defined(__NR_setns)
+#define __NR_setns 268
+#endif
+
+#if !defined(__NR_sendmmsg)
+#define __NR_sendmmsg 269
+#endif
+
+#if !defined(__NR_process_vm_readv)
+#define __NR_process_vm_readv 270
+#endif
+
+#if !defined(__NR_process_vm_writev)
+#define __NR_process_vm_writev 271
+#endif
+
+#if !defined(__NR_kcmp)
+#define __NR_kcmp 272
+#endif
+
+#if !defined(__NR_finit_module)
+#define __NR_finit_module 273
+#endif
+
+#if !defined(__NR_sched_setattr)
+#define __NR_sched_setattr 274
+#endif
+
+#if !defined(__NR_sched_getattr)
+#define __NR_sched_getattr 275
+#endif
+
+#if !defined(__NR_renameat2)
+#define __NR_renameat2 276
+#endif
+
+#if !defined(__NR_seccomp)
+#define __NR_seccomp 277
+#endif
+
+#if !defined(__NR_getrandom)
+#define __NR_getrandom 278
+#endif
+
+#if !defined(__NR_memfd_create)
+#define __NR_memfd_create 279
+#endif
+
+#if !defined(__NR_bfp)
+#define __NR_bfp 280
+#endif
+
+#if !defined(__NR_execveat)
+#define __NR_execveat 281
+#endif
+
+#if !defined(__NR_userfaultfd)
+#define __NR_userfaultfd 282
+#endif
+
+#if !defined(__NR_membarrier)
+#define __NR_membarrier 283
+#endif
+
+#if !defined(__NR_memlock2)
+#define __NR_memlock2 284
+#endif
+
+#if !defined(__NR_copy_file_range)
+#define __NR_copy_file_range 285
+#endif
+
+#if !defined(__NR_preadv2)
+#define __NR_preadv2 286
+#endif
+
+#if !defined(__NR_pwritev2)
+#define __NR_pwritev2 287
+#endif
+
+#if !defined(__NR_pkey_mprotect)
+#define __NR_pkey_mprotect 288
+#endif
+
+#if !defined(__NR_pkey_alloc)
+#define __NR_pkey_alloc 289
+#endif
+
+#if !defined(__NR_pkey_free)
+#define __NR_pkey_free 290
+#endif
+
+#if !defined(__NR_statx)
+#define __NR_statx 291
+#endif
+
+#if !defined(__NR_io_pgetevents)
+#define __NR_io_pgetevents 292
+#endif
+
+#if !defined(__NR_rseq)
+#define __NR_rseq 293
+#endif
+
+#if !defined(__NR_kexec_file_load)
+#define __NR_kexec_file_load 294
+#endif
+
+#if !defined(__NR_pidfd_send_signal)
+#define __NR_pidfd_send_signal 424
+#endif
+
+#if !defined(__NR_io_uring_setup)
+#define __NR_io_uring_setup 425
+#endif
+
+#if !defined(__NR_io_uring_enter)
+#define __NR_io_uring_enter 426
+#endif
+
+#if !defined(__NR_io_uring_register)
+#define __NR_io_uring_register 427
+#endif
+
+#if !defined(__NR_open_tree)
+#define __NR_open_tree 428
+#endif
+
+#if !defined(__NR_move_mount)
+#define __NR_move_mount 429
+#endif
+
+#if !defined(__NR_fsopen)
+#define __NR_fsopen 430
+#endif
+
+#if !defined(__NR_fsconfig)
+#define __NR_fsconfig 431
+#endif
+
+#if !defined(__NR_fsmount)
+#define __NR_fsmount 432
+#endif
+
+#if !defined(__NR_fspick)
+#define __NR_fspick 433
+#endif
+
+#if !defined(__NR_pidfd_open)
+#define __NR_pidfd_open 434
+#endif
+
+#if !defined(__NR_clone3)
+#define __NR_clone3 435
+#endif
+
+#if !defined(__NR_close_range)
+#define __NR_close_range 436
+#endif
+
+#if !defined(__NR_openat2)
+#define __NR_openat2 437
+#endif
+
+#if !defined(__NR_pidfd_getfd)
+#define __NR_pidfd_getfd 438
+#endif
+
+#if !defined(__NR_faccessat2)
+#define __NR_faccessat2 439
+#endif
+
+#if !defined(__NR_process_madvise)
+#define __NR_process_madvise 440
+#endif
+
+#if !defined(__NR_epoll_pwait2)
+#define __NR_epoll_pwait2 441
+#endif
+
+#if !defined(__NR_mount_setattr)
+#define __NR_mount_setattr 442
+#endif
+
+#if !defined(__NR_quotactl_path)
+#define __NR_quotactl_path 443
+#endif
+
+#if !defined(__NR_landlock_create_ruleset)
+#define __NR_landlock_create_ruleset 444
+#endif
+
+#if !defined(__NR_landlock_add_rule)
+#define __NR_landlock_add_rule 445
+#endif
+
+#if !defined(__NR_landlock_restrict_self)
+#define __NR_landlock_restrict_self 446
+#endif
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LOONG64_LINUX_SYSCALLS_H_
diff --git a/sandbox/policy/linux/bpf_broker_policy_linux.cc b/sandbox/policy/linux/bpf_broker_policy_linux.cc
index 87a0cc1faf..b09fbf2434 100644
--- a/sandbox/policy/linux/bpf_broker_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_broker_policy_linux.cc
@@ -111,6 +111,13 @@ ResultExpr BrokerProcessPolicy::EvaluateSyscall(int sysno) const {
         return Allow();
       break;
 #endif
+#if defined(__NR_statx)
+    case __NR_statx:
+      if (allowed_command_set_.test(syscall_broker::COMMAND_STAT)) {
+        return Allow();
+      }
+      break;
+#endif
 #if defined(__NR_readlink)
     case __NR_readlink:
       if (allowed_command_set_.test(syscall_broker::COMMAND_READLINK))
diff --git a/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc b/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
index df2567f749..42275afc1d 100644
--- a/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
@@ -38,7 +38,7 @@ ResultExpr CrosAmdGpuProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_sched_setscheduler:
     case __NR_sysinfo:
     case __NR_uname:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_readlink:
     case __NR_stat:
 #endif
diff --git a/sandbox/policy/linux/bpf_gpu_policy_linux.cc b/sandbox/policy/linux/bpf_gpu_policy_linux.cc
index 35ccbb7a7f..b40cae7a96 100644
--- a/sandbox/policy/linux/bpf_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_gpu_policy_linux.cc
@@ -73,7 +73,7 @@ ResultExpr GpuProcessPolicy::EvaluateSyscall(int sysno) const {
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_ftruncate64:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_getdents:
 #endif
     case __NR_getdents64:
diff --git a/sandbox/policy/linux/bpf_network_policy_linux.cc b/sandbox/policy/linux/bpf_network_policy_linux.cc
index 98e738a7e3..e66f669354 100644
--- a/sandbox/policy/linux/bpf_network_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_network_policy_linux.cc
@@ -255,7 +255,7 @@ ResultExpr NetworkProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_fdatasync:
     case __NR_fsync:
     case __NR_mremap:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch64)
     case __NR_getdents:
 #endif
     case __NR_getdents64:
diff --git a/sandbox/policy/linux/sandbox_linux.cc b/sandbox/policy/linux/sandbox_linux.cc
index 5dbb628a74..d41c815152 100644
--- a/sandbox/policy/linux/sandbox_linux.cc
+++ b/sandbox/policy/linux/sandbox_linux.cc
@@ -551,6 +551,8 @@ bpf_dsl::ResultExpr SandboxLinux::HandleViaBroker(int sysno) const {
   const bpf_dsl::ResultExpr handle_via_broker =
       bpf_dsl::Trap(syscall_broker::BrokerClient::SIGSYS_Handler,
                     broker_process_->GetBrokerClientSignalBased());
+#if defined(__NR_fstatat_default)
+  // TODO(loongarch): fstatat
   if (sysno == __NR_fstatat_default) {
     // This may be an fstatat(fd, "", stat_buf, AT_EMPTY_PATH), which should be
     // rewritten as fstat(fd, stat_buf). This should be consistent with how the
@@ -564,6 +566,9 @@ bpf_dsl::ResultExpr SandboxLinux::HandleViaBroker(int sysno) const {
   } else {
     return handle_via_broker;
   }
+#else
+  return handle_via_broker;
+#endif
 }
 
 bool SandboxLinux::HasOpenDirectories() const {
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index af5086e17f..061d2b65b7 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -21,6 +21,11 @@ if (current_cpu == "arm") {
 if (current_cpu == "mipsel" || current_cpu == "mips64el") {
   import("//build/config/mips.gni")
 }
+if(current_cpu == "loong64") {
+  import("//build/config/loongarch64.gni")
+  skia_use_lsx_opt = loongarch64_use_lsx
+  skia_use_lasx_opt = loongarch64_use_lsx
+}
 
 buildflag_header("buildflags") {
   header = "buildflags.h"
@@ -242,6 +247,10 @@ source_set("skcms") {
     ]
   }
 
+  if ( current_cpu == "loong64" && skia_use_lsx_opt ) {
+    cflags += [  "-mlsx", "-flax-vector-conversions=all", "-fno-vectorize", ]
+  }
+
   # LLVM automatically sets the equivalent of GCC's -mfp16-format=ieee on ARM
   # builds by default, while GCC itself does not. We need it to enable support
   # for half-precision floating point data types used by SKCMS on ARM.
@@ -348,6 +357,14 @@ component("skia") {
         "ext/convolver_neon.h",
       ]
     }
+  } else if (current_cpu == "loong64") {
+    if(skia_use_lsx_opt) {
+        sources += [
+          "ext/convolver_LSX.cc",
+          "ext/convolver_LSX.h",
+        ]
+      cflags = [ "-mlsx", "-flax-vector-conversions=all"]
+    }
   }
 
   if (is_win) {
@@ -715,6 +732,10 @@ skia_source_set("skia_core_and_effects") {
   if (skia_support_gpu) {
     deps = [ "//gpu/config:workaround_list" ]
   }
+  # For the Opt functions in the cpp file by the macro definition included.
+  if(current_cpu == "loong64" && skia_use_lsx_opt) {
+    cflags = [ "-mlsx", "-flax-vector-conversions=all"]
+  }
   if (skia_use_dawn) {
     # Note: This is needed as files in this target include GrDawnTypes.h, which
     # includes Dawn headers that are generated by the below target. Normally it
@@ -777,6 +798,19 @@ if (current_cpu == "x86" || current_cpu == "x64") {
   }
 }
 
+if (current_cpu == "loong64") {
+  skia_source_set("skia_opts_lasx") {
+    sources = skia_opts.lasx_sources
+    cflags = [ "-mlasx", "-flax-vector-conversions=all", "-O3" ]
+    visibility = [ ":skia_opts" ]
+  }
+  #skia_source_set("skia_opts_lsx") {
+  #  sources = skia_opts.lsx_sources
+  #  cflags = [ "-mlsx",  "-flax-vector-conversions=all", "-O3" ]
+  #  visibility = [ ":skia_opts" ]
+  #}
+}
+
 skia_source_set("skia_opts") {
   cflags = []
   defines = []
@@ -819,6 +853,14 @@ skia_source_set("skia_opts") {
     # Conditional and empty body needed to avoid assert() below.
   } else if (current_cpu == "riscv64") {
     # Conditional and empty body needed to avoid assert() below.
+  } else if (current_cpu == "loong64") {
+    if(skia_use_lasx_opt) {
+      deps += [ ":skia_opts_lasx" ]
+      #deps += [ ":skia_opts_lsx" ]
+    }
+    else {
+      sources = skia_opts.none_sources
+    }
   } else {
     assert(false, "Unknown cpu target")
   }
diff --git a/skia/ext/convolver.cc b/skia/ext/convolver.cc
index 8b3bd070d1..e9bf882126 100644
--- a/skia/ext/convolver.cc
+++ b/skia/ext/convolver.cc
@@ -8,6 +8,7 @@
 #include "base/notreached.h"
 #include "skia/ext/convolver.h"
 #include "skia/ext/convolver_SSE2.h"
+#include "skia/ext/convolver_LSX.h"
 #include "skia/ext/convolver_mips_dspr2.h"
 #include "skia/ext/convolver_neon.h"
 #include "third_party/skia/include/core/SkSize.h"
@@ -376,6 +377,11 @@ void SetupSIMD(ConvolveProcs *procs) {
   procs->convolve_vertically = &ConvolveVertically_Neon;
   procs->convolve_4rows_horizontally = &Convolve4RowsHorizontally_Neon;
   procs->convolve_horizontally = &ConvolveHorizontally_Neon;
+#elif defined SIMD_LSX
+  procs->extra_horizontal_reads = 3;
+  procs->convolve_vertically = &ConvolveVertically_LSX;
+  procs->convolve_4rows_horizontally = &Convolve4RowsHorizontally_LSX;
+  procs->convolve_horizontally = &ConvolveHorizontally_LSX;
 #endif
 }
 
diff --git a/skia/ext/convolver.h b/skia/ext/convolver.h
index 2409ce4ec1..8571ab3fff 100644
--- a/skia/ext/convolver.h
+++ b/skia/ext/convolver.h
@@ -21,6 +21,12 @@
 #define SIMD_PADDING 8  // 8 * int16_t
 #endif
 
+#if defined(ARCH_CPU_LA_FAMILY) && !defined(OS_IOS) && \
+	defined(__loongarch_sx)
+#define SIMD_LSX 1
+//#define SIMD_PADDING 8  // 8 * int16_t
+#endif
+
 #if defined (ARCH_CPU_MIPS_FAMILY) && \
     defined(__mips_dsp) && (__mips_dsp_rev >= 2)
 #define SIMD_MIPS_DSPR2 1
diff --git a/skia/ext/convolver_LSX.cc b/skia/ext/convolver_LSX.cc
new file mode 100644
index 0000000000..c7ffd6405e
--- /dev/null
+++ b/skia/ext/convolver_LSX.cc
@@ -0,0 +1,522 @@
+// Copyright (c) 2011 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include <algorithm>
+
+#include "build/build_config.h"
+#include "skia/ext/convolver.h"
+#include "skia/ext/convolver_LSX.h"
+#include "third_party/skia/include/core/SkTypes.h"
+
+#if SIMD_LSX
+#include <lsxintrin.h> // ARCH_CPU_LA_FAMILY was defined in build/build_config.h
+#define LSX_LD(psrc) *((__m128i *)(psrc))
+#define LSX_ST(in, pdst) *((__m128i *)(pdst)) = (in)
+#define _MM_SHUFFLE(z, y, x, w) (((z) << 6) | ((y) << 4) | ((x) << 2) | (w))
+#endif
+
+namespace skia {
+#if SIMD_LSX
+static __m128i emulate_lsx_set_epi16(uint16_t a, uint16_t b, uint16_t c, uint16_t d,
+                    uint16_t e, uint16_t f, uint16_t g, uint16_t h){
+    v8u16 retv = {h, g, f, e, d, c, b, a};
+    return (__m128i)retv;
+}
+static __m128i emulate_lsx_loadl_epi64(const void* mem_addr)
+{
+    __m128i tmp = __lsx_vldi(0);
+    __m128i ptr_lsx = __lsx_vldrepl_d((void *)(mem_addr), 0);
+    return __lsx_vilvl_d(tmp, ptr_lsx);
+}
+static __m128i emulate_lsx_shufflelo_epi16_0(__m128i data)
+{
+    v4i32 v0 = {0, 0, -1, -1};
+    __m128i v_hi = __lsx_vand_v(data, (__m128i)v0);
+    data = __lsx_vshuf4i_h(data, _MM_SHUFFLE(1, 1, 0, 0));
+    v0 = (v4i32)__lsx_vnor_v((__m128i)v0, (__m128i)v0);
+    data = __lsx_vand_v(data, (__m128i)v0);
+    return __lsx_vor_v(data, v_hi);
+}
+static __m128i emulate_lsx_shufflelo_epi16_1(__m128i data)
+{
+    v4i32 v0 = {0, 0, -1, -1};
+    __m128i v_hi = __lsx_vand_v(data, (__m128i)v0);
+    data = __lsx_vshuf4i_h(data, _MM_SHUFFLE(3, 3, 2, 2));
+    v0 = (v4i32)__lsx_vnor_v((__m128i)v0, (__m128i)v0);
+    data = __lsx_vand_v(data, (__m128i)v0);
+    return __lsx_vor_v(data, v_hi);
+}
+
+static __m128i emulate_lsx_packs_epi32(__m128i a, __m128i b)
+{
+    __m128i tmp0 = __lsx_vsat_w(a, 15);
+    __m128i tmp1 = __lsx_vsat_w(b, 15);
+    return __lsx_vpickev_h(tmp1, tmp0);
+}
+static __m128i emulate_lsx_packus_epi16(__m128i a, __m128i b)
+{
+    a = __lsx_vmaxi_h(a, 0);
+    b = __lsx_vmaxi_h(b, 0);
+    __m128i tmp0 = __lsx_vsat_hu(a, 7);
+    __m128i tmp1 = __lsx_vsat_hu(b, 7);
+    return __lsx_vpickev_b(tmp1, tmp0);
+}
+static __m128i emulate_lsx_srai_epi32(__m128i a, int imm8)
+{
+    __m128i tmp0 = __lsx_vldrepl_w(&imm8, 0);
+    return __lsx_vsra_w(a, tmp0);
+}
+#endif
+// Convolves horizontally along a single row. The row data is given in
+// |src_data| and continues for the num_values() of the filter.
+void ConvolveHorizontally_LSX(const unsigned char* src_data,
+                               const ConvolutionFilter1D& filter,
+                               unsigned char* out_row,
+                               bool /*has_alpha*/) {
+
+#if SIMD_LSX
+  int num_values = filter.num_values();
+
+  int filter_offset, filter_length;
+  __m128i zero = __lsx_vldi(0);
+  __m128i mask[4];
+  // |mask| will be used to decimate all extra filter coefficients that are
+  // loaded by SIMD when |filter_length| is not divisible by 4.
+  // mask[0] is not used in following algorithm.
+  mask[1] = emulate_lsx_set_epi16(0, 0, 0, 0, 0, 0, 0, -1);
+  mask[2] = emulate_lsx_set_epi16(0, 0, 0, 0, 0, 0, -1, -1);
+  mask[3] = emulate_lsx_set_epi16(0, 0, 0, 0, 0, -1, -1, -1);
+
+  // Output one pixel each iteration, calculating all channels (RGBA) together.
+  for (int out_x = 0; out_x < num_values; out_x++) {
+    const ConvolutionFilter1D::Fixed* filter_values =
+        filter.FilterForValue(out_x, &filter_offset, &filter_length);
+
+    __m128i accum = __lsx_vldi(0);
+
+    // Compute the first pixel in this row that the filter affects. It will
+    // touch |filter_length| pixels (4 bytes each) after this.
+    const __m128i* row_to_filter =
+        reinterpret_cast<const __m128i*>(&src_data[filter_offset << 2]);
+
+    // We will load and accumulate with four coefficients per iteration.
+    for (int filter_x = 0; filter_x < filter_length >> 2; filter_x++) {
+
+      // Load 4 coefficients => duplicate 1st and 2nd of them for all channels.
+      __m128i coeff, coeff16;
+      // [16] xx xx xx xx c3 c2 c1 c0
+      coeff = emulate_lsx_loadl_epi64(reinterpret_cast<const __m128i*>(filter_values));
+      // [16] xx xx xx xx c1 c1 c0 c0
+      coeff16 = emulate_lsx_shufflelo_epi16_0(coeff);
+      // [16] c1 c1 c1 c1 c0 c0 c0 c0
+      coeff16 = __lsx_vilvl_h(coeff16, coeff16);
+
+      // Load four pixels => unpack the first two pixels to 16 bits =>
+      // multiply with coefficients => accumulate the convolution result.
+      // [8] a3 b3 g3 r3 a2 b2 g2 r2 a1 b1 g1 r1 a0 b0 g0 r0
+      __m128i src8 = LSX_LD(row_to_filter);
+      // [16] a1 b1 g1 r1 a0 b0 g0 r0
+      __m128i src16 = __lsx_vilvl_b(zero, src8);
+      __m128i mul_hi = __lsx_vmuh_h(src16, coeff16);
+      __m128i mul_lo = __lsx_vmul_h(src16, coeff16);
+      // [32]  a0*c0 b0*c0 g0*c0 r0*c0
+      __m128i t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum = __lsx_vadd_w(accum, t);
+      // [32]  a1*c1 b1*c1 g1*c1 r1*c1
+      t = __lsx_vilvh_h(mul_hi, mul_lo);
+      accum = __lsx_vadd_w(accum, t);
+
+      // Duplicate 3rd and 4th coefficients for all channels =>
+      // unpack the 3rd and 4th pixels to 16 bits => multiply with coefficients
+      // => accumulate the convolution results.
+      // [16] xx xx xx xx c3 c3 c2 c2
+      coeff16 = emulate_lsx_shufflelo_epi16_1(coeff);
+      // [16] c3 c3 c3 c3 c2 c2 c2 c2
+      coeff16 = __lsx_vilvl_h(coeff16, coeff16);
+      // [16] a3 g3 b3 r3 a2 g2 b2 r2
+      src16 = __lsx_vilvh_b(zero, src8);
+      mul_hi = __lsx_vmuh_h(src16, coeff16);
+      mul_lo = __lsx_vmul_h(src16, coeff16);
+      // [32]  a2*c2 b2*c2 g2*c2 r2*c2
+      t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum = __lsx_vadd_w(accum, t);
+      // [32]  a3*c3 b3*c3 g3*c3 r3*c3
+      t = __lsx_vilvh_h(mul_hi, mul_lo);
+      accum = __lsx_vadd_w(accum, t);
+
+      // Advance the pixel and coefficients pointers.
+      row_to_filter += 1;
+      filter_values += 4;
+    }
+
+    // When |filter_length| is not divisible by 4, we need to decimate some of
+    // the filter coefficient that was loaded incorrectly to zero; Other than
+    // that the algorithm is same with above, exceot that the 4th pixel will be
+    // always absent.
+    int r = filter_length&3;
+    if (r) {
+      // Note: filter_values must be padded to align_up(filter_offset, 8).
+      __m128i coeff, coeff16;
+      coeff = emulate_lsx_loadl_epi64(reinterpret_cast<const __m128i*>(filter_values));
+      // Mask out extra filter taps.
+      coeff = __lsx_vand_v(coeff, mask[r]);
+      coeff16 = emulate_lsx_shufflelo_epi16_0(coeff);
+      coeff16 = __lsx_vilvl_h(coeff16, coeff16);
+
+      // Note: line buffer must be padded to align_up(filter_offset, 16).
+      // We resolve this by use C-version for the last horizontal line.
+      __m128i src8 = LSX_LD(row_to_filter);
+      __m128i src16 = __lsx_vilvl_b(zero, src8);
+      __m128i mul_hi = __lsx_vmuh_h(src16, coeff16);
+      __m128i mul_lo = __lsx_vmul_h(src16, coeff16);
+      __m128i t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum = __lsx_vadd_w(accum, t);
+      t = __lsx_vilvh_h(mul_hi, mul_lo);
+      accum = __lsx_vadd_w(accum, t);
+
+      src16 = __lsx_vilvh_b(zero, src8);
+      coeff16 = emulate_lsx_shufflelo_epi16_1(coeff);
+      coeff16 = __lsx_vilvl_h(coeff16, coeff16);
+      mul_hi = __lsx_vmuh_h(src16, coeff16);
+      mul_lo = __lsx_vmul_h(src16, coeff16);
+      t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum = __lsx_vadd_w(accum, t);
+    }
+
+    // Shift right for fixed point implementation.
+    accum = emulate_lsx_srai_epi32(accum, ConvolutionFilter1D::kShiftBits);
+
+    // Packing 32 bits |accum| to 16 bits per channel (signed saturation).
+    accum = emulate_lsx_packs_epi32(accum, zero);
+    // Packing 16 bits |accum| to 8 bits per channel (unsigned saturation).
+    accum = emulate_lsx_packus_epi16(accum, zero);
+
+    // Store the pixel value of 32 bits.
+    *(reinterpret_cast<int*>(out_row)) = __lsx_vpickve2gr_w(accum, 0);
+    out_row += 4;
+  }
+#endif
+}
+
+// Convolves horizontally along four rows. The row data is given in
+// |src_data| and continues for the num_values() of the filter.
+// The algorithm is almost same as |ConvolveHorizontally_LSX|. Please
+// refer to that function for detailed comments.
+void Convolve4RowsHorizontally_LSX(const unsigned char* src_data[4],
+                                    const ConvolutionFilter1D& filter,
+                                    unsigned char* out_row[4]) {
+#if SIMD_LSX
+  int num_values = filter.num_values();
+  int filter_offset, filter_length;
+  __m128i zero = __lsx_vldi(0);
+  __m128i mask[4];
+  // |mask| will be used to decimate all extra filter coefficients that are
+  // loaded by SIMD when |filter_length| is not divisible by 4.
+  // mask[0] is not used in following algorithm.
+  mask[1] = emulate_lsx_set_epi16(0, 0, 0, 0, 0, 0, 0, -1);
+  mask[2] = emulate_lsx_set_epi16(0, 0, 0, 0, 0, 0, -1, -1);
+  mask[3] = emulate_lsx_set_epi16(0, 0, 0, 0, 0, -1, -1, -1);
+
+  // Output one pixel each iteration, calculating all channels (RGBA) together.
+  for (int out_x = 0; out_x < num_values; out_x++) {
+    const ConvolutionFilter1D::Fixed* filter_values =
+        filter.FilterForValue(out_x, &filter_offset, &filter_length);
+
+    // four pixels in a column per iteration.
+    __m128i accum0 = __lsx_vldi(0);
+    __m128i accum1 = __lsx_vldi(0);
+    __m128i accum2 = __lsx_vldi(0);
+    __m128i accum3 = __lsx_vldi(0);
+    int start = (filter_offset<<2);
+    // We will load and accumulate with four coefficients per iteration.
+    for (int filter_x = 0; filter_x < (filter_length >> 2); filter_x++) {
+      __m128i coeff, coeff16lo, coeff16hi;
+      // [16] xx xx xx xx c3 c2 c1 c0
+      coeff = emulate_lsx_loadl_epi64(reinterpret_cast<const __m128i*>(filter_values));
+      // [16] xx xx xx xx c1 c1 c0 c0
+      coeff16lo = emulate_lsx_shufflelo_epi16_0(coeff);
+      // [16] c1 c1 c1 c1 c0 c0 c0 c0
+      coeff16lo = __lsx_vilvl_h(coeff16lo, coeff16lo);
+      // [16] xx xx xx xx c3 c3 c2 c2
+      coeff16hi = emulate_lsx_shufflelo_epi16_1(coeff);
+      // [16] c3 c3 c3 c3 c2 c2 c2 c2
+      coeff16hi = __lsx_vilvl_h(coeff16hi, coeff16hi);
+
+      __m128i src8, src16, mul_hi, mul_lo, t;
+
+#define ITERATION(src, accum)                                     \
+      src8 = LSX_LD(reinterpret_cast<const __m128i*>(src));       \
+      src16 = __lsx_vilvl_b(zero, src8);                          \
+      mul_hi = __lsx_vmuh_h(src16, coeff16lo);                    \
+      mul_lo = __lsx_vmul_h(src16, coeff16lo);                    \
+      t = __lsx_vilvl_h(mul_hi, mul_lo);                          \
+      accum = __lsx_vadd_w(accum, t);                             \
+      t = __lsx_vilvh_h(mul_hi, mul_lo);                          \
+      accum = __lsx_vadd_w(accum, t);                             \
+      src16 = __lsx_vilvh_b(zero, src8);                          \
+      mul_hi = __lsx_vmuh_h(src16, coeff16hi);                    \
+      mul_lo = __lsx_vmul_h(src16, coeff16hi);                    \
+      t = __lsx_vilvl_h(mul_hi, mul_lo);                          \
+      accum = __lsx_vadd_w(accum, t);                             \
+      t = __lsx_vilvh_h(mul_hi, mul_lo);                          \
+      accum = __lsx_vadd_w(accum, t)
+
+      ITERATION(src_data[0] + start, accum0);
+      ITERATION(src_data[1] + start, accum1);
+      ITERATION(src_data[2] + start, accum2);
+      ITERATION(src_data[3] + start, accum3);
+
+      start += 16;
+      filter_values += 4;
+    }
+
+    int r = filter_length & 3;
+    if (r) {
+      // Note: filter_values must be padded to align_up(filter_offset, 8);
+      __m128i coeff;
+      coeff = emulate_lsx_loadl_epi64(reinterpret_cast<const __m128i*>(filter_values));
+      // Mask out extra filter taps.
+      coeff = __lsx_vand_v(coeff, mask[r]);
+
+      __m128i coeff16lo = emulate_lsx_shufflelo_epi16_0(coeff);
+      /* c1 c1 c1 c1 c0 c0 c0 c0 */
+      coeff16lo = __lsx_vilvl_h(coeff16lo, coeff16lo);
+      __m128i coeff16hi = emulate_lsx_shufflelo_epi16_1(coeff);
+      coeff16hi = __lsx_vilvl_h(coeff16hi, coeff16hi);
+
+      __m128i src8, src16, mul_hi, mul_lo, t;
+
+      ITERATION(src_data[0] + start, accum0);
+      ITERATION(src_data[1] + start, accum1);
+      ITERATION(src_data[2] + start, accum2);
+      ITERATION(src_data[3] + start, accum3);
+    }
+
+    accum0 = emulate_lsx_srai_epi32(accum0, ConvolutionFilter1D::kShiftBits);
+    accum0 = emulate_lsx_packs_epi32(accum0, zero);
+    accum0 = emulate_lsx_packus_epi16(accum0, zero);
+    accum1 = emulate_lsx_srai_epi32(accum1, ConvolutionFilter1D::kShiftBits);
+    accum1 = emulate_lsx_packs_epi32(accum1, zero);
+    accum1 = emulate_lsx_packus_epi16(accum1, zero);
+    accum2 = emulate_lsx_srai_epi32(accum2, ConvolutionFilter1D::kShiftBits);
+    accum2 = emulate_lsx_packs_epi32(accum2, zero);
+    accum2 = emulate_lsx_packus_epi16(accum2, zero);
+    accum3 = emulate_lsx_srai_epi32(accum3, ConvolutionFilter1D::kShiftBits);
+    accum3 = emulate_lsx_packs_epi32(accum3, zero);
+    accum3 = emulate_lsx_packus_epi16(accum3, zero);
+
+    *(reinterpret_cast<int*>(out_row[0])) = __lsx_vpickve2gr_w(accum0, 0);
+    *(reinterpret_cast<int*>(out_row[1])) = __lsx_vpickve2gr_w(accum1, 0);
+    *(reinterpret_cast<int*>(out_row[2])) = __lsx_vpickve2gr_w(accum2, 0);
+    *(reinterpret_cast<int*>(out_row[3])) = __lsx_vpickve2gr_w(accum3, 0);
+
+    out_row[0] += 4;
+    out_row[1] += 4;
+    out_row[2] += 4;
+    out_row[3] += 4;
+  }
+#endif
+}
+
+// Does vertical convolution to produce one output row. The filter values and
+// length are given in the first two parameters. These are applied to each
+// of the rows pointed to in the |source_data_rows| array, with each row
+// being |pixel_width| wide.
+//
+// The output must have room for |pixel_width * 4| bytes.
+template<bool has_alpha>
+void ConvolveVertically_LSX(const ConvolutionFilter1D::Fixed* filter_values,
+                             int filter_length,
+                             unsigned char* const* source_data_rows,
+                             int pixel_width,
+                             unsigned char* out_row) {
+#if SIMD_LSX
+  int width = pixel_width & ~3;
+
+  __m128i zero = __lsx_vldi(0);
+  __m128i accum0, accum1, accum2, accum3, coeff16;
+  const __m128i* src;
+  // Output four pixels per iteration (16 bytes).
+  for (int out_x = 0; out_x < width; out_x += 4) {
+
+    // Accumulated result for each pixel. 32 bits per RGBA channel.
+    accum0 = __lsx_vldi(0);
+    accum1 = __lsx_vldi(0);
+    accum2 = __lsx_vldi(0);
+    accum3 = __lsx_vldi(0);
+    int values = 0;
+    // Convolve with one filter coefficient per iteration.
+    for (int filter_y = 0; filter_y < filter_length; filter_y++) {
+
+      // Duplicate the filter coefficient 8 times.
+      // [16] cj cj cj cj cj cj cj cj
+      values = filter_values[filter_y];
+      coeff16 = __lsx_vldrepl_h(&values, 0);
+
+      // Load four pixels (16 bytes) together.
+      // [8] a3 b3 g3 r3 a2 b2 g2 r2 a1 b1 g1 r1 a0 b0 g0 r0
+      src = reinterpret_cast<const __m128i*>(
+          &source_data_rows[filter_y][out_x << 2]);
+      __m128i src8 = LSX_LD(src);
+
+      // Unpack 1st and 2nd pixels from 8 bits to 16 bits for each channels =>
+      // multiply with current coefficient => accumulate the result.
+      // [16] a1 b1 g1 r1 a0 b0 g0 r0
+      __m128i src16 = __lsx_vilvl_b(zero, src8);
+      __m128i mul_hi = __lsx_vmuh_h(src16, coeff16);
+      __m128i mul_lo = __lsx_vmul_h(src16, coeff16);
+      // [32] a0 b0 g0 r0
+      __m128i t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum0 = __lsx_vadd_w(accum0, t);
+      // [32] a1 b1 g1 r1
+      t = __lsx_vilvh_h(mul_hi, mul_lo);
+      accum1 = __lsx_vadd_w(accum1, t);
+
+      // Unpack 3rd and 4th pixels from 8 bits to 16 bits for each channels =>
+      // multiply with current coefficient => accumulate the result.
+      // [16] a3 b3 g3 r3 a2 b2 g2 r2
+      src16 = __lsx_vilvh_b(zero, src8);
+      mul_hi = __lsx_vmuh_h(src16, coeff16);
+      mul_lo = __lsx_vmul_h(src16, coeff16);
+      // [32] a2 b2 g2 r2
+      t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum2 = __lsx_vadd_w(accum2, t);
+      // [32] a3 b3 g3 r3
+      t = __lsx_vilvh_h(mul_hi, mul_lo);
+      accum3 = __lsx_vadd_w(accum3, t);
+    }
+    // Shift right for fixed point implementation.
+    accum0 = emulate_lsx_srai_epi32(accum0, ConvolutionFilter1D::kShiftBits);
+    accum1 = emulate_lsx_srai_epi32(accum1, ConvolutionFilter1D::kShiftBits);
+    accum2 = emulate_lsx_srai_epi32(accum2, ConvolutionFilter1D::kShiftBits);
+    accum3 = emulate_lsx_srai_epi32(accum3, ConvolutionFilter1D::kShiftBits);
+
+    // Packing 32 bits |accum| to 16 bits per channel (signed saturation).
+    // [16] a1 b1 g1 r1 a0 b0 g0 r0
+    accum0 = emulate_lsx_packs_epi32(accum0, accum1);
+    // [16] a3 b3 g3 r3 a2 b2 g2 r2
+    accum2 = emulate_lsx_packs_epi32(accum2, accum3);
+
+    // Packing 16 bits |accum| to 8 bits per channel (unsigned saturation).
+    // [8] a3 b3 g3 r3 a2 b2 g2 r2 a1 b1 g1 r1 a0 b0 g0 r0
+    accum0 = emulate_lsx_packus_epi16(accum0, accum2);
+
+    if (has_alpha) {
+      // Compute the max(ri, gi, bi) for each pixel.
+      // [8] xx a3 b3 g3 xx a2 b2 g2 xx a1 b1 g1 xx a0 b0 g0
+      __m128i a = __lsx_vsrli_w(accum0, 8);
+      // [8] xx xx xx max3 xx xx xx max2 xx xx xx max1 xx xx xx max0
+      __m128i b = __lsx_vmax_bu(a, accum0);  // Max of r and g.
+      // [8] xx xx a3 b3 xx xx a2 b2 xx xx a1 b1 xx xx a0 b0
+      a = __lsx_vsrli_w(accum0, 16);
+      // [8] xx xx xx max3 xx xx xx max2 xx xx xx max1 xx xx xx max0
+      b = __lsx_vmax_bu(a, b);  // Max of r and g and b.
+      // [8] max3 00 00 00 max2 00 00 00 max1 00 00 00 max0 00 00 00
+      b = __lsx_vslli_w(b, 24);
+
+      // Make sure the value of alpha channel is always larger than maximum
+      // value of color channels.
+      accum0 = __lsx_vmax_bu(b, accum0);
+    } else {
+      // Set value of alpha channels to 0xFF.
+      unsigned int a = 0xff000000;
+      __m128i mask = __lsx_vldrepl_w(&a, 0);
+      accum0 = __lsx_vor_v(accum0, mask);
+    }
+
+    // Store the convolution result (16 bytes) and advance the pixel pointers.
+    LSX_ST(accum0, reinterpret_cast<__m128i*>(out_row));
+    out_row += 16;
+  }
+
+  // When the width of the output is not divisible by 4, We need to save one
+  // pixel (4 bytes) each time. And also the fourth pixel is always absent.
+  if (pixel_width & 3) {
+    accum0 = __lsx_vldi(0);
+    accum1 = __lsx_vldi(0);
+    accum2 = __lsx_vldi(0);
+    int values = 0;
+    for (int filter_y = 0; filter_y < filter_length; ++filter_y) {
+      values = filter_values[filter_y];
+      coeff16 = __lsx_vldrepl_h(&values, 0);
+      // [8] a3 b3 g3 r3 a2 b2 g2 r2 a1 b1 g1 r1 a0 b0 g0 r0
+      src = reinterpret_cast<const __m128i*>(
+          &source_data_rows[filter_y][width<<2]);
+      __m128i src8 = LSX_LD(src);
+      // [16] a1 b1 g1 r1 a0 b0 g0 r0
+      __m128i src16 = __lsx_vilvl_b(zero, src8);
+      __m128i mul_hi = __lsx_vmuh_h(src16, coeff16);
+      __m128i mul_lo = __lsx_vmul_h(src16, coeff16);
+      // [32] a0 b0 g0 r0
+      __m128i t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum0 = __lsx_vadd_w(t, accum0);
+      // [32] a1 b1 g1 r1
+      t = __lsx_vilvh_h(mul_hi, mul_lo);
+      accum1 = __lsx_vadd_w(accum1, t);
+      // [16] a3 b3 g3 r3 a2 b2 g2 r2
+      src16 = __lsx_vilvh_b(zero, src8);
+      mul_hi = __lsx_vmuh_h(src16, coeff16);
+      mul_lo = __lsx_vmul_h(src16, coeff16);
+      // [32] a2 b2 g2 r2
+      t = __lsx_vilvl_h(mul_hi, mul_lo);
+      accum2 = __lsx_vadd_w(accum2, t);
+    }
+
+    accum0 = emulate_lsx_srai_epi32(accum0, ConvolutionFilter1D::kShiftBits);
+    accum1 = emulate_lsx_srai_epi32(accum1, ConvolutionFilter1D::kShiftBits);
+    accum2 = emulate_lsx_srai_epi32(accum2, ConvolutionFilter1D::kShiftBits);
+    // [16] a1 b1 g1 r1 a0 b0 g0 r0
+    accum0 = emulate_lsx_packs_epi32(accum0, accum1);
+    // [16] a3 b3 g3 r3 a2 b2 g2 r2
+    accum2 = emulate_lsx_packs_epi32(accum2, zero);
+    // [8] a3 b3 g3 r3 a2 b2 g2 r2 a1 b1 g1 r1 a0 b0 g0 r0
+    accum0 = emulate_lsx_packus_epi16(accum0, accum2);
+    if (has_alpha) {
+      // [8] xx a3 b3 g3 xx a2 b2 g2 xx a1 b1 g1 xx a0 b0 g0
+      __m128i a = __lsx_vsrli_w(accum0, 8);
+      // [8] xx xx xx max3 xx xx xx max2 xx xx xx max1 xx xx xx max0
+      __m128i b = __lsx_vmax_bu(a, accum0);  // Max of r and g.
+      // [8] xx xx a3 b3 xx xx a2 b2 xx xx a1 b1 xx xx a0 b0
+      a = __lsx_vsrli_w(accum0, 16);
+      // [8] xx xx xx max3 xx xx xx max2 xx xx xx max1 xx xx xx max0
+      b = __lsx_vmax_bu(a, b);  // Max of r and g and b.
+      // [8] max3 00 00 00 max2 00 00 00 max1 00 00 00 max0 00 00 00
+      b = __lsx_vslli_w(b, 24);
+      accum0 = __lsx_vmax_bu(b, accum0);
+    } else {
+      unsigned int a = 0xff000000;
+      __m128i mask = __lsx_vldrepl_w(&a, 0);
+      accum0 = __lsx_vor_v(accum0, mask);
+    }
+
+    for (int out_x = width; out_x < pixel_width; out_x++) {
+      *(reinterpret_cast<int*>(out_row)) = __lsx_vpickve2gr_w(accum0, 0);
+      accum0 = __lsx_vbsrl_v(accum0, 4);
+      out_row += 4;
+    }
+  }
+#endif
+}
+
+void ConvolveVertically_LSX(const ConvolutionFilter1D::Fixed* filter_values,
+                             int filter_length,
+                             unsigned char* const* source_data_rows,
+                             int pixel_width,
+                             unsigned char* out_row,
+                             bool has_alpha) {
+  if (has_alpha) {
+    ConvolveVertically_LSX<true>(filter_values,
+                                  filter_length,
+                                  source_data_rows,
+                                  pixel_width,
+                                  out_row);
+  } else {
+    ConvolveVertically_LSX<false>(filter_values,
+                                   filter_length,
+                                   source_data_rows,
+                                   pixel_width,
+                                   out_row);
+  }
+}
+}  // namespace skia
diff --git a/skia/ext/convolver_LSX.h b/skia/ext/convolver_LSX.h
new file mode 100644
index 0000000000..507b6e36dc
--- /dev/null
+++ b/skia/ext/convolver_LSX.h
@@ -0,0 +1,27 @@
+// Copyright (c) 2012 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SKIA_EXT_CONVOLVER_LSX_H_
+#define SKIA_EXT_CONVOLVER_LSX_H_
+
+#include "skia/ext/convolver.h"
+
+namespace skia {
+
+void ConvolveVertically_LSX(const ConvolutionFilter1D::Fixed* filter_values,
+                             int filter_length,
+                             unsigned char* const* source_data_rows,
+                             int pixel_width,
+                             unsigned char* out_row,
+                             bool has_alpha);
+void Convolve4RowsHorizontally_LSX(const unsigned char* src_data[4],
+                                    const ConvolutionFilter1D& filter,
+                                    unsigned char* out_row[4]);
+void ConvolveHorizontally_LSX(const unsigned char* src_data,
+                               const ConvolutionFilter1D& filter,
+                               unsigned char* out_row,
+                               bool has_alpha);
+}  // namespace skia
+
+#endif  // SKIA_EXT_CONVOLVER_LSX_H_
diff --git a/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc b/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc
index f9cf9f5ae8..0566ae194c 100644
--- a/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc
+++ b/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc
@@ -169,7 +169,7 @@ class HTMLFastPathParser {
   using Span = base::span<const Char>;
   using USpan = base::span<const UChar>;
   // 32 matches that used by HTMLToken::Attribute.
-  typedef std::conditional<std::is_same_v<Char, UChar>,
+  typedef typename std::conditional<std::is_same_v<Char, UChar>,
                            UCharLiteralBuffer<32>,
                            LCharLiteralBuffer<32>>::type LiteralBufferType;
   typedef UCharLiteralBuffer<32> UCharLiteralBufferType;
diff --git a/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h b/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h
index 8bb1639676..bc455d2249 100644
--- a/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h
+++ b/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h
@@ -269,8 +269,8 @@ class CORE_EXPORT ObjectPaintPropertiesSparse : public ObjectPaintProperties {
       NodeList& nodes,
       NodeId node_id,
       const ParentType& parent,
-      NodeType::State&& state,
-      const NodeType::AnimationState& animation_state =
+      typename NodeType::State&& state,
+      const typename NodeType::AnimationState& animation_state =
           NodeType::AnimationState()) {
     // First, check if we need to add a new node.
     if (!nodes.HasField(node_id)) {
diff --git a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc
index 883d769ca4..2087a84f67 100644
--- a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc
@@ -83,12 +83,12 @@ void CanvasStyle::ApplyToFlags(cc::PaintFlags& flags,
     case kGradient:
       GetCanvasGradient()->GetGradient()->ApplyToFlags(flags, SkMatrix::I(),
                                                        ImageDrawOptions());
-      flags.setColor(SkColor4f(0.0f, 0.0f, 0.0f, global_alpha));
+      flags.setColor(SkColor4f::Make(0.0f, 0.0f, 0.0f, global_alpha));
       break;
     case kImagePattern:
       GetCanvasPattern()->GetPattern()->ApplyToFlags(
           flags, AffineTransformToSkMatrix(GetCanvasPattern()->GetTransform()));
-      flags.setColor(SkColor4f(0.0f, 0.0f, 0.0f, global_alpha));
+      flags.setColor(SkColor4f::Make(0.0f, 0.0f, 0.0f, global_alpha));
       break;
     default:
       NOTREACHED();
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index ef3439d07a..d9a179a09c 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1591,7 +1591,7 @@ component("platform") {
   if (current_cpu == "loong64") {
     cflags = [
       "-mlsx",
-      "-flax-vector-conversions",
+      "-flax-vector-conversions=all",
     ]
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_palette.h b/third_party/blink/renderer/platform/fonts/font_palette.h
index b10c3743e2..9f93afa454 100644
--- a/third_party/blink/renderer/platform/fonts/font_palette.h
+++ b/third_party/blink/renderer/platform/fonts/font_palette.h
@@ -34,6 +34,9 @@ class PLATFORM_EXPORT FontPalette : public RefCounted<FontPalette> {
   struct FontPaletteOverride {
     int index;
     Color color;
+    static FontPaletteOverride Make(int index, Color color) {
+      return {index, color};
+    }
 
     bool operator==(const FontPaletteOverride& other) const {
       return index == other.index && color == other.color;
diff --git a/third_party/blink/renderer/platform/fonts/palette_interpolation.cc b/third_party/blink/renderer/platform/fonts/palette_interpolation.cc
index 5a0121510a..48f31d58fd 100644
--- a/third_party/blink/renderer/platform/fonts/palette_interpolation.cc
+++ b/third_party/blink/renderer/platform/fonts/palette_interpolation.cc
@@ -31,7 +31,7 @@ Vector<FontPalette::FontPaletteOverride> PaletteInterpolation::MixColorRecords(
         color_interpolation_space, hue_interpolation_method, start_color,
         end_color, percentage, alpha_multiplier);
 
-    FontPalette::FontPaletteOverride result_color_record(i, result_color);
+    FontPalette::FontPaletteOverride result_color_record = FontPalette::FontPaletteOverride::Make(i, result_color);
     result_color_records.push_back(result_color_record);
   }
   return result_color_records;
diff --git a/third_party/boringssl/src/crypto/fipsmodule/rand/getrandom_fillin.h b/third_party/boringssl/src/crypto/fipsmodule/rand/getrandom_fillin.h
index 0f290e9637..5f03768be7 100644
--- a/third_party/boringssl/src/crypto/fipsmodule/rand/getrandom_fillin.h
+++ b/third_party/boringssl/src/crypto/fipsmodule/rand/getrandom_fillin.h
@@ -32,6 +32,8 @@
 #define EXPECTED_NR_getrandom 384
 #elif defined(OPENSSL_RISCV64)
 #define EXPECTED_NR_getrandom 278
+#elif defined(OPENSSL_LOONGARCH64)
+#define EXPECTED_NR_getrandom 278
 #endif
 
 #if defined(EXPECTED_NR_getrandom)
diff --git a/third_party/boringssl/src/include/openssl/base.h b/third_party/boringssl/src/include/openssl/base.h
index 2249aea6fa..4e816dd7d3 100644
--- a/third_party/boringssl/src/include/openssl/base.h
+++ b/third_party/boringssl/src/include/openssl/base.h
@@ -107,6 +107,9 @@ extern "C" {
 #define OPENSSL_RISCV64
 #elif defined(__riscv) && __SIZEOF_POINTER__ == 4
 #define OPENSSL_32_BIT
+#elif defined(__loongarch_lp64)
+#define OPENSSL_64_BIT
+#define OPENSSL_LOONGARCH64
 #elif defined(__pnacl__)
 #define OPENSSL_32_BIT
 #define OPENSSL_PNACL
diff --git a/third_party/breakpad/BUILD.gn b/third_party/breakpad/BUILD.gn
index ca8ac723da..4844448059 100644
--- a/third_party/breakpad/BUILD.gn
+++ b/third_party/breakpad/BUILD.gn
@@ -118,6 +118,8 @@ if (!is_win) {
         "breakpad/src/processor/stackwalker_arm.h",
         "breakpad/src/processor/stackwalker_arm64.cc",
         "breakpad/src/processor/stackwalker_arm64.h",
+        "breakpad/src/processor/stackwalker_loong64.cc",
+        "breakpad/src/processor/stackwalker_loong64.h",
         "breakpad/src/processor/stackwalker_mips.cc",
         "breakpad/src/processor/stackwalker_mips.h",
         "breakpad/src/processor/stackwalker_ppc.cc",
diff --git a/third_party/breakpad/breakpad/Makefile.am b/third_party/breakpad/breakpad/Makefile.am
index 58e4148310..9e25772c72 100644
--- a/third_party/breakpad/breakpad/Makefile.am
+++ b/third_party/breakpad/breakpad/Makefile.am
@@ -422,6 +422,8 @@ src_libbreakpad_a_SOURCES = \
 	src/processor/stackwalker_arm.h \
 	src/processor/stackwalker_arm64.cc \
 	src/processor/stackwalker_arm64.h \
+        src/processor/stackwalker_loong64.cc \
+        src/processor/stackwalker_loong64.h \
 	src/processor/stackwalker_address_list.cc \
 	src/processor/stackwalker_address_list.h \
 	src/processor/stackwalker_mips.cc \
@@ -948,6 +950,7 @@ src_processor_exploitability_unittest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1062,6 +1065,7 @@ src_processor_microdump_processor_unittest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1109,6 +1113,7 @@ src_processor_minidump_processor_unittest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1260,6 +1265,7 @@ src_processor_stackwalker_selftest_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1452,6 +1458,7 @@ src_processor_microdump_stackwalk_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1499,6 +1506,7 @@ src_processor_minidump_stackwalk_LDADD = \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1626,6 +1634,7 @@ EXTRA_DIST = \
 	src/processor/testdata/linux_write_to_under_4k.dmp \
 	src/processor/testdata/microdump-arm64.dmp \
 	src/processor/testdata/microdump-arm.dmp \
+	src/processor/testdata/microdump-loong64.dmp \
 	src/processor/testdata/microdump-mips32.dmp \
 	src/processor/testdata/microdump-mips64.dmp \
 	src/processor/testdata/microdump-multiple.dmp \
diff --git a/third_party/breakpad/breakpad/Makefile.in b/third_party/breakpad/breakpad/Makefile.in
index 184563836b..88fd972a7b 100644
--- a/third_party/breakpad/breakpad/Makefile.in
+++ b/third_party/breakpad/breakpad/Makefile.in
@@ -632,6 +632,7 @@ am_src_libbreakpad_a_OBJECTS =  \
 	src/processor/stackwalker_amd64.$(OBJEXT) \
 	src/processor/stackwalker_arm.$(OBJEXT) \
 	src/processor/stackwalker_arm64.$(OBJEXT) \
+	src/processor/stackwalker_loong64.$(OBJEXT) \
 	src/processor/stackwalker_address_list.$(OBJEXT) \
 	src/processor/stackwalker_mips.$(OBJEXT) \
 	src/processor/stackwalker_ppc.$(OBJEXT) \
@@ -970,6 +971,7 @@ src_processor_exploitability_unittest_DEPENDENCIES =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1020,6 +1022,7 @@ src_processor_microdump_processor_unittest_DEPENDENCIES =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1053,6 +1056,7 @@ src_processor_microdump_stackwalk_DEPENDENCIES =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1095,6 +1099,7 @@ src_processor_minidump_processor_unittest_DEPENDENCIES =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1131,6 +1136,7 @@ src_processor_minidump_stackwalk_DEPENDENCIES =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1274,6 +1280,7 @@ src_processor_stackwalker_selftest_DEPENDENCIES =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -1700,6 +1707,7 @@ am__depfiles_remade = src/client/$(DEPDIR)/minidump_file_writer.Po \
 	src/processor/$(DEPDIR)/stackwalker_amd64_unittest-stackwalker_amd64_unittest.Po \
 	src/processor/$(DEPDIR)/stackwalker_arm.Po \
 	src/processor/$(DEPDIR)/stackwalker_arm64.Po \
+	src/processor/$(DEPDIR)/stackwalker_loong64.Po \
 	src/processor/$(DEPDIR)/stackwalker_arm64_unittest-stackwalker_arm64_unittest.Po \
 	src/processor/$(DEPDIR)/stackwalker_arm_unittest-stackwalker_arm_unittest.Po \
 	src/processor/$(DEPDIR)/stackwalker_mips.Po \
@@ -2465,6 +2473,8 @@ src_libbreakpad_a_SOURCES =  \
 	src/processor/stackwalker_arm.h \
 	src/processor/stackwalker_arm64.cc \
 	src/processor/stackwalker_arm64.h \
+	src/processor/stackwalker_loong64.cc \
+	src/processor/stackwalker_loong64.h \
 	src/processor/stackwalker_address_list.cc \
 	src/processor/stackwalker_address_list.h \
 	src/processor/stackwalker_mips.cc \
@@ -2962,6 +2972,7 @@ src_processor_exploitability_unittest_LDADD =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -3079,6 +3090,7 @@ src_processor_microdump_processor_unittest_LDADD =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -3114,6 +3126,7 @@ src_processor_minidump_processor_unittest_LDADD =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -3274,6 +3287,7 @@ src_processor_stackwalker_selftest_LDADD =  \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -3481,6 +3495,7 @@ src_processor_microdump_stackwalk_LDADD = src/common/path_helper.o \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -3513,6 +3528,7 @@ src_processor_minidump_stackwalk_LDADD = src/common/path_helper.o \
 	src/processor/stackwalker_amd64.o \
 	src/processor/stackwalker_arm.o \
 	src/processor/stackwalker_arm64.o \
+	src/processor/stackwalker_loong64.o \
 	src/processor/stackwalker_mips.o \
 	src/processor/stackwalker_ppc.o \
 	src/processor/stackwalker_ppc64.o \
@@ -3628,6 +3644,7 @@ EXTRA_DIST = \
 	src/processor/testdata/linux_write_to_under_4k.dmp \
 	src/processor/testdata/microdump-arm64.dmp \
 	src/processor/testdata/microdump-arm.dmp \
+	src/processor/testdata/microdump-loong64.dmp \
 	src/processor/testdata/microdump-mips32.dmp \
 	src/processor/testdata/microdump-mips64.dmp \
 	src/processor/testdata/microdump-multiple.dmp \
@@ -4191,6 +4208,9 @@ src/processor/stackwalker_arm.$(OBJEXT):  \
 src/processor/stackwalker_arm64.$(OBJEXT):  \
 	src/processor/$(am__dirstamp) \
 	src/processor/$(DEPDIR)/$(am__dirstamp)
+src/processor/stackwalker_loong64.$(OBJEXT):  \
+	src/processor/$(am__dirstamp) \
+	src/processor/$(DEPDIR)/$(am__dirstamp)
 src/processor/stackwalker_address_list.$(OBJEXT):  \
 	src/processor/$(am__dirstamp) \
 	src/processor/$(DEPDIR)/$(am__dirstamp)
@@ -5560,6 +5580,7 @@ distclean-compile:
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_amd64_unittest-stackwalker_amd64_unittest.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_arm.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_arm64.Po@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_loong64.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_arm64_unittest-stackwalker_arm64_unittest.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_arm_unittest-stackwalker_arm_unittest.Po@am__quote@ # am--include-marker
 @AMDEP_TRUE@@am__include@ @am__quote@src/processor/$(DEPDIR)/stackwalker_mips.Po@am__quote@ # am--include-marker
@@ -9842,6 +9863,7 @@ distclean: distclean-am
 	-rm -f src/processor/$(DEPDIR)/stackwalker_amd64_unittest-stackwalker_amd64_unittest.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm64.Po
+	-rm -f src/processor/$(DEPDIR)/stackwalker_loong64.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm64_unittest-stackwalker_arm64_unittest.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm_unittest-stackwalker_arm_unittest.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_mips.Po
@@ -10202,6 +10224,7 @@ maintainer-clean: maintainer-clean-am
 	-rm -f src/processor/$(DEPDIR)/stackwalker_amd64_unittest-stackwalker_amd64_unittest.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm64.Po
+	-rm -f src/processor/$(DEPDIR)/stackwalker_loong64.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm64_unittest-stackwalker_arm64_unittest.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_arm_unittest-stackwalker_arm_unittest.Po
 	-rm -f src/processor/$(DEPDIR)/stackwalker_mips.Po
diff --git a/third_party/breakpad/breakpad/autotools/config.guess b/third_party/breakpad/breakpad/autotools/config.guess
index f7727026b7..09f1d16ad5 100755
--- a/third_party/breakpad/breakpad/autotools/config.guess
+++ b/third_party/breakpad/breakpad/autotools/config.guess
@@ -1055,6 +1055,9 @@ EOF
     mips64el:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+    loongarch64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     openrisc*:Linux:*:*)
 	echo or1k-unknown-linux-"$LIBC"
 	exit ;;
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
index ea4b6f6a29..be9588cfa3 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/raw_context_cpu.h
@@ -43,6 +43,8 @@ typedef MDRawContextARM RawContextCPU;
 typedef MDRawContextARM64_Old RawContextCPU;
 #elif defined(__mips__)
 typedef MDRawContextMIPS RawContextCPU;
+#elif defined(__loongarch64)
+typedef MDRawContextLOONG64 RawContextCPU;
 #elif defined(__riscv)
 # if __riscv_xlen == 32
 typedef MDRawContextRISCV RawContextCPU;
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
index 6288a056e0..9d01733a36 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.cc
@@ -32,6 +32,7 @@
 
 #include "client/linux/dump_writer_common/thread_info.h"
 
+#include <stdio.h>
 #include <string.h>
 #include <assert.h>
 
@@ -231,6 +232,49 @@ void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
       MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
 }
 
+#elif defined(__loongarch_lp64)
+
+#if defined(LOONGARCH_IS_LEGACY)
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return mcontext.__pc;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_LOONG64_FULL;
+
+  out->pc = mcontext.__pc;
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    out->iregs[i] = mcontext.__gregs[i];
+
+  // TODO:LOONG64 Support vector FPU
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = mcontext.__fpregs[i].__val64[0];
+
+  out->float_save.fcsr = mcontext.__fcsr;
+  out->float_save.vcsr = mcontext.__vcsr;
+  out->float_save.fcc = mcontext.__fcc;
+}
+#else
+uintptr_t ThreadInfo::GetInstructionPointer() const {
+  return regs.csr_era;
+}
+
+void ThreadInfo::FillCPUContext(RawContextCPU* out) const {
+  out->context_flags = MD_CONTEXT_LOONG64_FULL;
+
+  out->pc = regs.csr_era;
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    out->iregs[i] = regs.regs[i];
+
+  // TODO:LOONG64 Support vector FPU
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = fpregs.fpr[i];
+
+  out->float_save.fcc = fpregs.fcc;
+  out->float_save.fcsr = fpregs.fcsr;
+}
+#endif
+
 #elif defined(__mips__)
 
 uintptr_t ThreadInfo::GetInstructionPointer() const {
@@ -350,6 +394,11 @@ void ThreadInfo::GetGeneralPurposeRegisters(void** gp_regs, size_t* size) {
     *gp_regs = mcontext.__gregs;
   if (size)
     *size = sizeof(mcontext.__gregs);
+#elif defined(LOONGARCH_IS_LEGACY)
+  if (gp_regs)
+    *gp_regs = mcontext.__gregs;
+  if (size)
+    *size = sizeof(mcontext.__gregs);
 #else
   if (gp_regs)
     *gp_regs = &regs;
@@ -384,6 +433,11 @@ void ThreadInfo::GetFloatingPointRegisters(void** fp_regs, size_t* size) {
 # else
 #  error "Unexpected __riscv_flen"
 # endif
+#elif defined(LOONGARCH_IS_LEGACY)
+  if (fp_regs)
+    *fp_regs = &mcontext.__fpregs;
+  if (size)
+    *size = sizeof(mcontext.__fpregs);
 #else
   if (fp_regs)
     *fp_regs = &fpregs;
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
index af786bcc96..a1fc0dd92c 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/thread_info.h
@@ -70,6 +70,15 @@ struct ThreadInfo {
 #elif defined(__mips__) || defined(__riscv)
   // Use the structure defined in <sys/ucontext.h>.
   mcontext_t mcontext;
+#elif defined(__loongarch__)
+#if defined(LOONGARCH_IS_LEGACY)
+  // Use the structure defined in <sys/ucontext.h>.
+  mcontext_t mcontext;
+#else
+  // Use the structures defined in <sys/user.h>
+  struct user_regs_struct regs;
+  struct user_fp_struct fpregs;
+#endif
 #endif
 
   // Returns the instruction pointer (platform-dependent impl.).
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
index 7649768355..89b5fc91bb 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.cc
@@ -211,6 +211,49 @@ void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
       MD_FLOATINGSAVEAREA_ARM64_FPR_COUNT * 16);
 }
 
+#elif defined(__loongarch__)
+
+uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP];
+}
+
+uintptr_t UContextReader::GetInstructionPointer(const ucontext_t* uc) {
+  return uc->uc_mcontext.__pc;
+}
+
+#if defined(LOONGARCH_IS_LEGACY)
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc) {
+  out->context_flags = MD_CONTEXT_LOONG64_FULL;
+  out->pc = uc->uc_mcontext.__pc;
+
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    out->iregs[i] = uc->uc_mcontext.__gregs[i];
+
+  // TODO:LOONG64 Support vector FPU
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = uc->uc_mcontext.__fpregs[i].__val64[0];
+
+  out->float_save.fcsr = uc->uc_mcontext.__fcsr;
+  out->float_save.vcsr = uc->uc_mcontext.__vcsr;
+  out->float_save.fcc = uc->uc_mcontext.__fcc;
+}
+#else
+void UContextReader::FillCPUContext(RawContextCPU* out, const ucontext_t* uc, const fpstate_t* fpregs) {
+  out->context_flags = MD_CONTEXT_LOONG64_FULL;
+  out->pc = uc->uc_mcontext.__pc;
+
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    out->iregs[i] = uc->uc_mcontext.__gregs[i];
+
+  // TODO:LOONG64 Support vector FPU
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i)
+    out->float_save.regs[i] = fpregs->regs[i];
+
+  out->float_save.fcc = fpregs->fcc;
+  out->float_save.fcsr = fpregs->fcsr;
+}
+#endif
+
 #elif defined(__mips__)
 
 uintptr_t UContextReader::GetStackPointer(const ucontext_t* uc) {
diff --git a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
index 60cbf90047..ec8aeb5de8 100644
--- a/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
+++ b/third_party/breakpad/breakpad/src/client/linux/dump_writer_common/ucontext_reader.h
@@ -54,6 +54,9 @@ struct UContextReader {
 #elif defined(__aarch64__)
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
                              const struct fpsimd_context* fpregs);
+#elif defined(LOONGARCH_NOT_LEGACY)
+static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc,
+                             const fpstate_t* fpregs);
 #else
   static void FillCPUContext(RawContextCPU* out, const ucontext_t* uc);
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
index 9e23c1194e..8be082ed9f 100644
--- a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.cc
@@ -464,6 +464,16 @@ bool ExceptionHandler::HandleSignal(int /*sig*/, siginfo_t* info, void* uc) {
     memcpy(&g_crash_context_.float_state, fp_ptr,
            sizeof(g_crash_context_.float_state));
   }
+#elif defined(LOONGARCH_NOT_LEGACY)
+  ucontext_t* uc_ptr = (ucontext_t*)uc;
+  struct sctx_info* ctx_info_ptr =
+      (struct sctx_info*)&uc_ptr->uc_mcontext.__extcontext;
+  if (ctx_info_ptr->magic == FPU_CTX_MAGIC) {
+    struct fpu_context* fpu_ptr = (struct fpu_context*)(&uc_ptr->uc_mcontext.__extcontext +
+                                   sizeof(struct sctx_info));
+    memcpy(&g_crash_context_.float_state, fpu_ptr,
+           sizeof(g_crash_context_.float_state));
+  }
 #elif GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE
   ucontext_t* uc_ptr = (ucontext_t*)uc;
   if (uc_ptr->uc_mcontext.fpregs) {
@@ -701,7 +711,7 @@ bool ExceptionHandler::WriteMinidump() {
   }
 #endif
 
-#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE && !defined(__aarch64__)
+#if GOOGLE_BREAKPAD_CRASH_CONTEXT_HAS_FLOAT_STATE && !defined(__aarch64__) && !defined(LOONGARCH_NOT_LEGACY)
   memcpy(&context.float_state, context.context.uc_mcontext.fpregs,
          sizeof(context.float_state));
 #endif
@@ -728,6 +738,9 @@ bool ExceptionHandler::WriteMinidump() {
 #elif defined(__riscv)
   context.siginfo.si_addr =
       reinterpret_cast<void*>(context.context.uc_mcontext.__gregs[REG_PC]);
+#elif defined(__loongarch64)
+  context.siginfo.si_addr =
+      reinterpret_cast<void*>(context.context.uc_mcontext.__pc);
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
index f8bc1ead79..e37fc777ad 100644
--- a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
+++ b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler.h
@@ -43,7 +43,8 @@
 #include "common/using_std_string.h"
 #include "google_breakpad/common/minidump_format.h"
 
-#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__riscv)
+#if !defined(__ARM_EABI__) && !defined(__mips__) && !defined(__riscv) && \
+    !defined(LOONGARCH_IS_LEGACY)
 // FP state is not part of user ABI for Linux ARM.
 // In case of MIPS and RISCV Linux FP state is already part of ucontext_t
 // so 'float_state' is not required.
diff --git a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
index b2d8d46811..6725828435 100644
--- a/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/handler/exception_handler_unittest.cc
@@ -774,7 +774,7 @@ TEST(ExceptionHandlerTest, InstructionPointerMemoryMaxBound) {
   // Use 4k here because the OS will hand out a single page even
   // if a smaller size is requested, and this test wants to
   // test the upper bound of the memory range.
-  const uint32_t kMemorySize = 4096;  // bytes
+  const uint32_t kMemorySize = sysconf(_SC_PAGESIZE);
   const int kOffset = kMemorySize - sizeof(kIllegalInstruction);
 
   const pid_t child = fork();
diff --git a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
index 93dae35e5c..4edbbfe9b8 100644
--- a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer.cc
@@ -348,6 +348,8 @@ class MicrodumpWriter {
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__loongarch64)
+    const char kArch[] = "loongarch64";
 #else
 # error "This code has not been ported to your platform yet"
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
index b1d570eb4d..9a2099bee3 100644
--- a/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/microdump_writer/microdump_writer_unittest.cc
@@ -283,9 +283,15 @@ TEST(MicrodumpWriterTest, BasicWithMappings) {
   ASSERT_TRUE(ContainsMicrodump(buf));
 
 #ifdef __LP64__
-  ASSERT_NE(std::string::npos,
-            buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
-                     "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  if (memory_size == 4096) {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000001000 000000000000002A 0000000000001000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  } else if(memory_size == 16384) {
+    ASSERT_NE(std::string::npos,
+              buf.find("M 0000000000004000 000000000000002A 0000000000004000 "
+                       "33221100554477668899AABBCCDDEEFF0 libfoo.so"));
+  }
 #else
   ASSERT_NE(std::string::npos,
             buf.find("M 00001000 0000002A 00001000 "
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
index 4bf9094e98..c36e0d5df2 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_core_dumper.cc
@@ -118,6 +118,14 @@ bool LinuxCoreDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
 #elif defined(__riscv)
     stack_pointer = reinterpret_cast<uint8_t*>(
         info->mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP]);
+#elif defined(__loongarch__)
+#if defined(LOONGARCH_IS_LEGACY)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP]);
+#else
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->regs.regs[MD_CONTEXT_LOONG64_REG_SP]);
+#endif
 #else
 # error "This code hasn't been ported to your platform yet."
 #endif
@@ -227,7 +235,19 @@ bool LinuxCoreDumper::EnumerateThreads() {
 #elif defined(__riscv)
         memcpy(&info.mcontext.__gregs, status->pr_reg,
                sizeof(info.mcontext.__gregs));
-#else  // __riscv
+#elif defined(__loongarch__)
+#if defined(LOONGARCH_IS_LEGACY)
+       for (int i = 0; i <= 31; i++)
+          info.mcontext.__gregs[i] = status->pr_reg[i];
+        // TODO:LOONG64 Check this magic number
+        info.mcontext.__pc = status->pr_reg[32];
+#else
+       for (int i = 0; i <= 31; i++)
+          info.regs.regs[i] = status->pr_reg[i];
+        // TODO:LOONG64 Check this magic number
+        info.regs.csr_era = status->pr_reg[32];
+#endif // LOONGARCH_IS_LEGACY
+#else  // __loongarch__
         memcpy(&info.regs, status->pr_reg, sizeof(info.regs));
 #endif
         if (first_thread) {
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
index 2d5b2e52b6..30282246ba 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper.h
@@ -64,7 +64,8 @@ namespace google_breakpad {
 typedef Elf32_auxv_t elf_aux_entry;
 #elif defined(__x86_64) || defined(__aarch64__) || \
      (defined(__mips__) && _MIPS_SIM != _ABIO32) || \
-     (defined(__riscv) && __riscv_xlen == 64)
+     (defined(__riscv) && __riscv_xlen == 64) || \
+     defined(__loongarch64)
 typedef Elf64_auxv_t elf_aux_entry;
 #endif
 
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
index 5a135fda0e..7097f4304c 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_dumper_unittest_helper.cc
@@ -56,6 +56,9 @@
 #define TID_PTR_REGISTER "$1"
 #elif defined(__riscv)
 #define TID_PTR_REGISTER "x4"
+#elif defined(__loongarch64)
+// TODO:LOONG64 Check TID_PTR_REGISTER value
+#define TID_PTR_REGISTER "a3"
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
index 2adc39e122..05b8538d2d 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper.cc
@@ -297,6 +297,16 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
              reinterpret_cast<void*>(DSP_CONTROL), &info->mcontext.dsp);
 #endif
 
+#if defined(__loongarch__)
+#if defined(LOONGARCH_IS_LEGACY)
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(PC), &info->mcontext.__pc);
+#else
+  sys_ptrace(PTRACE_PEEKUSER, tid,
+             reinterpret_cast<void*>(PC), &info->regs.csr_era);
+#endif
+#endif
+
   const uint8_t* stack_pointer;
 #if defined(__i386)
   my_memcpy(&stack_pointer, &info->regs.esp, sizeof(info->regs.esp));
@@ -312,6 +322,14 @@ bool LinuxPtraceDumper::GetThreadInfoByIndex(size_t index, ThreadInfo* info) {
 #elif defined(__riscv)
   stack_pointer = reinterpret_cast<uint8_t*>(
       info->mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP]);
+#elif defined(__loongarch_lp64)
+#if defined(LOONGARCH_IS_LEGACY)
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP]);
+#else
+  stack_pointer =
+      reinterpret_cast<uint8_t*>(info->regs.regs[MD_CONTEXT_LOONG64_REG_SP]);
+#endif
 #else
 # error "This code hasn't been ported to your platform yet."
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
index 16a9daf1d0..96a86a8ec3 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/linux_ptrace_dumper_unittest.cc
@@ -470,6 +470,14 @@ TEST(LinuxPtraceDumperTest, VerifyStackReadWithMultipleThreads) {
 #elif defined(__riscv)
     pid_t* process_tid_location =
         reinterpret_cast<pid_t*>(one_thread.mcontext.__gregs[4]);
+#elif defined(__loongarch__)
+#if defined(LOONGARCH_IS_LEGACY)
+    pid_t* process_tid_location =
+        reinterpret_cast<pid_t*>(one_thread.mcontext.__gregs[7]);
+#else
+    pid_t* process_tid_location =
+        reinterpret_cast<pid_t*>(one_thread.regs.regs[7]);
+#endif
 #else
 #error This test has not been ported to this platform.
 #endif
@@ -569,6 +577,12 @@ TEST_F(LinuxPtraceDumperTest, SanitizeStackCopy) {
   uintptr_t heap_addr = thread_info.mcontext.gregs[1];
 #elif defined(__riscv)
   uintptr_t heap_addr = thread_info.mcontext.__gregs[4];
+#elif defined(__loongarch__)
+#if defined(LOONGARCH_IS_LEGACY)
+  uintptr_t heap_addr = thread_info.mcontext.__gregs[7];
+#else
+  uintptr_t heap_addr = thread_info.regs.regs[7];
+#endif
 #else
 #error This test has not been ported to this platform.
 #endif
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
index a95dd25480..d99431ae62 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.cc
@@ -953,7 +953,7 @@ class MinidumpWriter {
     dirent->location.rva = 0;
   }
 
-#if defined(__i386__) || defined(__x86_64__) || defined(__mips__)
+#if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || defined(__loongarch__)
   bool WriteCPUInformation(MDRawSystemInfo* sys_info) {
     char vendor_id[sizeof(sys_info->cpu.x86_cpu_info.vendor_id) + 1] = {0};
     static const char vendor_id_name[] = "vendor_id";
@@ -981,6 +981,8 @@ class MinidumpWriter {
 # else
 #  error "This mips ABI is currently not supported (n32)"
 #endif
+#elif defined(__loongarch64)
+        MD_CPU_ARCHITECTURE_LOONG64;
 #elif defined(__i386__)
         MD_CPU_ARCHITECTURE_X86;
 #else
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
index 24e3c7bdc2..ab9873b0b5 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer.h
@@ -47,7 +47,9 @@ class ExceptionHandler;
 
 #if defined(__aarch64__)
 typedef struct fpsimd_context fpstate_t;
-#elif !defined(__ARM_EABI__) && !defined(__mips__)
+#elif defined(LOONGARCH_NOT_LEGACY)
+typedef struct fpu_context fpstate_t;
+#elif !defined(__ARM_EABI__) && !defined(__mips__) && !defined(LOONGARCH_IS_LEGACY)
 typedef std::remove_pointer<fpregset_t>::type fpstate_t;
 #endif
 
diff --git a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
index effedc5e17..0805703cb3 100644
--- a/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
+++ b/third_party/breakpad/breakpad/src/client/linux/minidump_writer/minidump_writer_unittest.cc
@@ -723,6 +723,9 @@ TEST(MinidumpWriterTest, InvalidStackPointer) {
 #elif defined(__riscv)
   context.context.uc_mcontext.__gregs[MD_CONTEXT_RISCV_REG_SP] =
       invalid_stack_pointer;
+#elif defined(__loongarch64)
+  context.context.uc_mcontext.__gregs[MD_CONTEXT_LOONG64_REG_SP] =
+      invalid_stack_pointer;
 #else
 # error "This code has not been ported to your platform yet."
 #endif
diff --git a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc
index 4c594175e8..a221ae0afe 100644
--- a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc
+++ b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.cc
@@ -170,6 +170,23 @@ vector<string> DwarfCFIToModule::RegisterNames::RISCV() {
   return MakeVector(names, sizeof(names) / sizeof(names[0]));
 }
 
+vector<string> DwarfCFIToModule::RegisterNames::LOONG64() {
+  static const char* const kRegisterNames[] = {
+    "r0",   "r1",   "r2",  "r3",  "r4",  "r5",  "r6",  "r7",
+    "r8",   "r9",   "r10", "r11", "r12", "r13", "r14", "r15",
+    "r16",  "r17",  "r18", "r19", "r20", "r21", "r22", "r23",
+    "r24",  "r25",  "r26", "r27", "r28", "r29", "r30", "r31",
+    "f0",   "f1",   "f2",  "f3",  "f4",  "f5",  "f6",  "f7",
+    "f8",   "f9",   "f10", "f11", "f12", "f13", "f14", "f15",
+    "f16",  "f17",  "f18", "f19", "f20", "f21", "f22", "f23",
+    "f24",  "f25",  "f26", "f27", "f28", "f29", "f30", "f31",
+    "fcc0", "fcc1", "fcc2", "fcc3", "fcc4", "fcc5", "fcc6", "fcc7"
+  };
+
+  return MakeVector(kRegisterNames,
+                    sizeof(kRegisterNames) / sizeof(kRegisterNames[0]));
+}
+
 bool DwarfCFIToModule::Entry(size_t offset, uint64_t address, uint64_t length,
                              uint8_t version, const string& augmentation,
                              unsigned return_address) {
diff --git a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h
index 19297db93f..cdbf2c651b 100644
--- a/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h
+++ b/third_party/breakpad/breakpad/src/common/dwarf_cfi_to_module.h
@@ -117,6 +117,9 @@ class DwarfCFIToModule: public CallFrameInfo::Handler {
     // RISC-V.
     static vector<string> RISCV();
 
+    // LoongArch64.
+    static vector<string> LOONG64();
+
    private:
     // Given STRINGS, an array of C strings with SIZE elements, return an
     // equivalent vector<string>.
diff --git a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S
index 286047bf5a..43a4dacf7a 100644
--- a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S
+++ b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext.S
@@ -275,8 +275,8 @@ breakpad_getcontext:
 #elif defined(__mips__)
 
 // This implementation is inspired by implementation of getcontext in glibc.
-#include <asm-mips/asm.h>
-#include <asm-mips/regdef.h>
+#include <sys/asm.h>
+#include <sys/regdef.h>
 #if _MIPS_SIM == _ABIO32
 #include <asm-mips/fpregdef.h>
 #endif
@@ -444,6 +444,65 @@ NESTED (breakpad_getcontext, FRAME_SIZE, ra)
 END (breakpad_getcontext)
 #endif // _MIPS_SIM == _ABIO32
 
+#elif defined(__loongarch_lp64)
+
+#if defined(LOONGARCH_IS_LEGACY)
+#define  _NSIG                       128
+#else
+#define  _NSIG                       64
+#endif
+
+#define  __NR_rt_sigprocmask         135
+
+  .text
+  .global breakpad_getcontext
+  .hidden breakpad_getcontext
+  .type breakpad_getcontext, @function
+  .align 4
+
+breakpad_getcontext:
+  st.d $zero, $a0, MCONTEXT_GREGS_OFFSET + 4 * MCONTEXT_REG_SIZE  /* zero */
+  st.d $fp, $a0, MCONTEXT_GREGS_OFFSET + 22 * MCONTEXT_REG_SIZE
+  st.d $s0, $a0, MCONTEXT_GREGS_OFFSET + 23 * MCONTEXT_REG_SIZE
+  st.d $s1, $a0, MCONTEXT_GREGS_OFFSET + 24 * MCONTEXT_REG_SIZE
+  st.d $s2, $a0, MCONTEXT_GREGS_OFFSET + 25 * MCONTEXT_REG_SIZE
+  st.d $s3, $a0, MCONTEXT_GREGS_OFFSET + 26 * MCONTEXT_REG_SIZE
+  st.d $s4, $a0, MCONTEXT_GREGS_OFFSET + 27 * MCONTEXT_REG_SIZE
+  st.d $s5, $a0, MCONTEXT_GREGS_OFFSET + 28 * MCONTEXT_REG_SIZE
+  st.d $s6, $a0, MCONTEXT_GREGS_OFFSET + 29 * MCONTEXT_REG_SIZE
+  st.d $s7, $a0, MCONTEXT_GREGS_OFFSET + 30 * MCONTEXT_REG_SIZE
+  st.d $s8, $a0, MCONTEXT_GREGS_OFFSET + 31 * MCONTEXT_REG_SIZE
+  st.d $sp, $a0, MCONTEXT_GREGS_OFFSET + 3 * MCONTEXT_REG_SIZE
+  st.d $ra, $a0, MCONTEXT_GREGS_OFFSET + 1 * MCONTEXT_REG_SIZE
+  st.d $ra, $a0, MCONTEXT_PC_OFFSET
+
+#if defined(LOONGARCH_IS_LEGACY)
+  fst.d $fs0, $a0, MCONTEXT_GREGS_OFFSET + 24 * MCONTEXT_REG_SIZE
+  fst.d $fs1, $a0, MCONTEXT_GREGS_OFFSET + 25 * MCONTEXT_REG_SIZE
+  fst.d $fs2, $a0, MCONTEXT_GREGS_OFFSET + 26 * MCONTEXT_REG_SIZE
+  fst.d $fs3, $a0, MCONTEXT_GREGS_OFFSET + 27 * MCONTEXT_REG_SIZE
+  fst.d $fs4, $a0, MCONTEXT_GREGS_OFFSET + 28 * MCONTEXT_REG_SIZE
+  fst.d $fs5, $a0, MCONTEXT_GREGS_OFFSET + 29 * MCONTEXT_REG_SIZE
+  fst.d $fs6, $a0, MCONTEXT_GREGS_OFFSET + 30 * MCONTEXT_REG_SIZE
+  fst.d $fs7, $a0, MCONTEXT_GREGS_OFFSET + 31 * MCONTEXT_REG_SIZE
+#endif
+
+  // TODO:LOONG64 Handle fcsr/vcsr/fcc
+
+  /* rt_sigprocmask (SIG_BLOCK, NULL, &ucp->uc_sigmask, _NSIG8) */
+  addi.d $a2, $a0, UCONTEXT_SIGMASK_OFFSET
+  move  $a1, $zero
+  li.d  $a0, 0
+  li.d  $a3, _NSIG / 8
+  li.d  $a7, __NR_rt_sigprocmask
+  syscall 0
+
+  /* Return zero for success */
+  move $a0, $zero
+  jirl $zero, $ra, 0
+
+  .size breakpad_getcontext, . - breakpad_getcontext
+
 #elif defined(__x86_64__)
 /* The x64 implementation of breakpad_getcontext was derived in part
    from the implementation of libunwind which requires the following
diff --git a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc
index 5b340eb74e..9c84d95d8d 100644
--- a/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/breakpad_getcontext_unittest.cc
@@ -136,6 +136,17 @@ TEST(AndroidUContext, GRegsOffset) {
 
   ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPC_CSR),
             offsetof(ucontext_t,uc_mcontext.__fpregs.__fcsr));
+#elif defined(__loongarch_lp64)
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
+            offsetof(ucontext_t, uc_mcontext.__gregs));
+
+  // PC for loongarch is not part of gregs.
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_PC_OFFSET),
+            offsetof(ucontext_t, uc_mcontext.__pc));
+#if defined(LOONGARCH_IS_LEGACY)
+  ASSERT_EQ(static_cast<size_t>(MCONTEXT_FPREGS_OFFSET),
+            offsetof(ucontext_t, uc_mcontext.__fpregs));
+#endif
 #elif defined(__x86_64__)
 
   COMPILE_ASSERT_EQ(static_cast<size_t>(MCONTEXT_GREGS_OFFSET),
diff --git a/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc b/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc
index 86c948d95a..d401cb7405 100644
--- a/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/dump_symbols.cc
@@ -108,6 +108,11 @@ using google_breakpad::wasteful_vector;
 #define EM_AARCH64      183
 #endif
 
+// Define LOONGARCH ELF architecture if host machine does not include this define.
+#ifndef EM_LOONGARCH
+#define EM_LOONGARCH      258
+#endif
+
 //
 // FDWrapper
 //
@@ -510,6 +515,9 @@ bool DwarfCFIRegisterNames(const typename ElfClass::Ehdr* elf_header,
     case EM_RISCV:
       *register_names = DwarfCFIToModule::RegisterNames::RISCV();
       return true;
+    case EM_LOONGARCH:
+      *register_names = DwarfCFIToModule::RegisterNames::LOONG64();
+      return true;
     default:
       return false;
   }
@@ -1084,6 +1092,7 @@ const char* ElfArchitecture(const typename ElfClass::Ehdr* elf_header) {
     case EM_SPARCV9:    return "sparcv9";
     case EM_X86_64:     return "x86_64";
     case EM_RISCV:      return "riscv";
+    case EM_LOONGARCH:  return "loongarch";
     default: return NULL;
   }
 }
diff --git a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
index a7b96eb591..92de498617 100644
--- a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file.cc
@@ -72,7 +72,8 @@ bool MemoryMappedFile::Map(const char* path, size_t offset) {
 
 #if defined(__x86_64__) || defined(__aarch64__) || \
    (defined(__mips__) && _MIPS_SIM == _ABI64) || \
-   (defined(__riscv) && __riscv_xlen == 64)
+   (defined(__riscv) && __riscv_xlen == 64) || \
+   defined(__loongarch64)
 
   struct kernel_stat st;
   if (sys_fstat(fd, &st) == -1 || st.st_size < 0) {
diff --git a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
index b7a61a70e8..fc14397a5c 100644
--- a/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
+++ b/third_party/breakpad/breakpad/src/common/linux/memory_mapped_file_unittest.cc
@@ -179,9 +179,9 @@ TEST_F(MemoryMappedFileTest, RemapAfterMap) {
 TEST_F(MemoryMappedFileTest, MapWithOffset) {
   // Put more data in the test file this time. Offsets can only be
   // done on page boundaries, so we need a two page file to test this.
-  const int page_size = 4096;
-  char data1[2 * page_size];
-  size_t data1_size = sizeof(data1);
+  const int page_size = sysconf(_SC_PAGESIZE);
+  char data1[8 * 4096];
+  size_t data1_size = page_size * 2;
   for (size_t i = 0; i < data1_size; ++i) {
     data1[i] = i & 0x7f;
   }
diff --git a/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h b/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h
index 3dcdecb08b..4827cb3288 100644
--- a/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h
+++ b/third_party/breakpad/breakpad/src/common/linux/ucontext_constants.h
@@ -115,6 +115,21 @@
 #define  UCONTEXT_SIGMASK_OFFSET   640
 #endif
 
+#elif defined(__loongarch_lp64)
+
+#define  MCONTEXT_REG_SIZE         8
+
+#if defined(LOONGARCH_IS_LEGACY)
+#define  MCONTEXT_PC_OFFSET        64
+#define  MCONTEXT_GREGS_OFFSET     72
+#define  MCONTEXT_FPREGS_OFFSET    352
+#define  UCONTEXT_SIGMASK_OFFSET   1408
+#else
+#define  UCONTEXT_SIGMASK_OFFSET   40
+#define  MCONTEXT_PC_OFFSET        176
+#define  MCONTEXT_GREGS_OFFSET     184
+#endif
+
 #elif defined(__x86_64__)
 
 #define MCONTEXT_GREGS_OFFSET     40
diff --git a/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc b/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
index 8ef68913be..72bcca2be1 100644
--- a/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
+++ b/third_party/breakpad/breakpad/src/common/memory_allocator_unittest.cc
@@ -57,9 +57,15 @@ TEST(PageAllocatorTest, SmallObjects) {
 
 TEST(PageAllocatorTest, LargeObject) {
   PageAllocator allocator;
+  uint8_t* p = NULL;
 
   EXPECT_EQ(0U, allocator.pages_allocated());
-  uint8_t* p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  if (sysconf(_SC_PAGESIZE) == 16384) {
+    p = reinterpret_cast<uint8_t*>(allocator.Alloc(40000));
+  } else {
+    EXPECT_EQ(4096U, sysconf(_SC_PAGESIZE));
+    p = reinterpret_cast<uint8_t*>(allocator.Alloc(10000));
+  }
   ASSERT_FALSE(p == NULL);
   EXPECT_EQ(3U, allocator.pages_allocated());
   for (unsigned i = 1; i < 10; ++i) {
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h b/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h
index 959d15ba2f..aaf77740d0 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/common/minidump_format.h
@@ -114,6 +114,7 @@ typedef struct {
 #include "minidump_cpu_amd64.h"
 #include "minidump_cpu_arm.h"
 #include "minidump_cpu_arm64.h"
+#include "minidump_cpu_loong64.h"
 #include "minidump_cpu_mips.h"
 #include "minidump_cpu_ppc.h"
 #include "minidump_cpu_ppc64.h"
@@ -686,6 +687,7 @@ typedef enum {
   MD_CPU_ARCHITECTURE_MIPS64    = 0x8004, /* Breakpad-defined value for MIPS64 */
   MD_CPU_ARCHITECTURE_RISCV     = 0x8005, /* Breakpad-defined value for RISCV */
   MD_CPU_ARCHITECTURE_RISCV64   = 0x8006, /* Breakpad-defined value for RISCV64 */
+  MD_CPU_ARCHITECTURE_LOONG64   = 0x8007, /* Breakpad-defined value for LOONG64 */
   MD_CPU_ARCHITECTURE_UNKNOWN   = 0xffff  /* PROCESSOR_ARCHITECTURE_UNKNOWN */
 } MDCPUArchitecture;
 
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h b/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h
index 7a1c643e2d..dd3b369488 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/processor/dump_context.h
@@ -63,6 +63,7 @@ class DumpContext : public DumpObject {
   const MDRawContextX86*     GetContextX86() const;
   const MDRawContextRISCV*   GetContextRISCV() const;
   const MDRawContextRISCV64* GetContextRISCV64() const;
+  const MDRawContextLOONG64*  GetContextLOONG64() const;
 
   // A convenience method to get the instruction pointer out of the
   // MDRawContext, since it varies per-CPU architecture.
@@ -90,6 +91,7 @@ class DumpContext : public DumpObject {
   void SetContextMIPS(MDRawContextMIPS* ctx_mips);
   void SetContextRISCV(MDRawContextRISCV* riscv);
   void SetContextRISCV64(MDRawContextRISCV64* riscv64);
+  void SetContextLOONG64(MDRawContextLOONG64* ctx_loong64);
 
   // Free the CPU-specific context structure.
   void FreeContext();
@@ -110,6 +112,7 @@ class DumpContext : public DumpObject {
     MDRawContextMIPS*    ctx_mips;
     MDRawContextRISCV*   riscv;
     MDRawContextRISCV64* riscv64;
+    MDRawContextLOONG64*  ctx_loong64;
   } context_;
 
   // Store this separately because of the weirdo AMD64 context
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h b/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h
index 7c2f3e662c..6fb3647a21 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/processor/microdump.h
@@ -71,6 +71,7 @@ class MicrodumpContext : public DumpContext {
   virtual void SetContextX86(MDRawContextX86* x86);
   virtual void SetContextMIPS(MDRawContextMIPS* mips32);
   virtual void SetContextMIPS64(MDRawContextMIPS* mips64);
+  virtual void SetContextLOONG64(MDRawContextLOONG64* loong64);
 };
 
 // This class provides access to microdump memory regions.
diff --git a/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h b/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h
index 91f1d0cb17..cc0b86690e 100644
--- a/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h
+++ b/third_party/breakpad/breakpad/src/google_breakpad/processor/stack_frame_cpu.h
@@ -514,6 +514,69 @@ struct StackFrameRISCV64 : public StackFrame {
   int context_validity;
 };
 
+struct StackFrameLOONG64 : public StackFrame {
+  // A flag for each register we might know. Note that we can't use an enum
+  // here as there are 33 values to represent.
+  static const uint64_t CONTEXT_VALID_NONE = 0;
+  static const uint64_t CONTEXT_VALID_R0   = 1ULL << 0;
+  static const uint64_t CONTEXT_VALID_R1   = 1ULL << 1;
+  static const uint64_t CONTEXT_VALID_R2   = 1ULL << 2;
+  static const uint64_t CONTEXT_VALID_R3   = 1ULL << 3;
+  static const uint64_t CONTEXT_VALID_R4   = 1ULL << 4;
+  static const uint64_t CONTEXT_VALID_R5   = 1ULL << 5;
+  static const uint64_t CONTEXT_VALID_R6   = 1ULL << 6;
+  static const uint64_t CONTEXT_VALID_R7   = 1ULL << 7;
+  static const uint64_t CONTEXT_VALID_R8   = 1ULL << 8;
+  static const uint64_t CONTEXT_VALID_R9   = 1ULL << 9;
+  static const uint64_t CONTEXT_VALID_R10  = 1ULL << 10;
+  static const uint64_t CONTEXT_VALID_R11  = 1ULL << 11;
+  static const uint64_t CONTEXT_VALID_R12  = 1ULL << 12;
+  static const uint64_t CONTEXT_VALID_R13  = 1ULL << 13;
+  static const uint64_t CONTEXT_VALID_R14  = 1ULL << 14;
+  static const uint64_t CONTEXT_VALID_R15  = 1ULL << 15;
+  static const uint64_t CONTEXT_VALID_R16  = 1ULL << 16;
+  static const uint64_t CONTEXT_VALID_R17  = 1ULL << 17;
+  static const uint64_t CONTEXT_VALID_R18  = 1ULL << 18;
+  static const uint64_t CONTEXT_VALID_R19  = 1ULL << 19;
+  static const uint64_t CONTEXT_VALID_R20  = 1ULL << 20;
+  static const uint64_t CONTEXT_VALID_R21  = 1ULL << 21;
+  static const uint64_t CONTEXT_VALID_R22  = 1ULL << 22;
+  static const uint64_t CONTEXT_VALID_R23  = 1ULL << 23;
+  static const uint64_t CONTEXT_VALID_R24  = 1ULL << 24;
+  static const uint64_t CONTEXT_VALID_R25  = 1ULL << 25;
+  static const uint64_t CONTEXT_VALID_R26  = 1ULL << 26;
+  static const uint64_t CONTEXT_VALID_R27  = 1ULL << 27;
+  static const uint64_t CONTEXT_VALID_R28  = 1ULL << 28;
+  static const uint64_t CONTEXT_VALID_R29  = 1ULL << 29;
+  static const uint64_t CONTEXT_VALID_R30  = 1ULL << 30;
+  static const uint64_t CONTEXT_VALID_R31  = 1ULL << 31;
+  static const uint64_t CONTEXT_VALID_PC  = 1ULL << 32;
+  static const uint64_t CONTEXT_VALID_ALL  = ~CONTEXT_VALID_NONE;
+
+  // Aliases for registers with dedicated or conventional roles.
+  static const uint64_t CONTEXT_VALID_RA   = CONTEXT_VALID_R1;
+  static const uint64_t CONTEXT_VALID_SP   = CONTEXT_VALID_R3;
+  static const uint64_t CONTEXT_VALID_FP   = CONTEXT_VALID_R22;
+
+  StackFrameLOONG64() : context(),
+                     context_validity(CONTEXT_VALID_NONE) {}
+
+  // Return the validity flag for register xN.
+  static uint64_t RegisterValidFlag(int n) {
+    return 1ULL << n;
+  }
+
+  // Register state. This is only fully valid for the topmost frame in a
+  // stack. In other frames, the values of nonvolatile registers may be
+  // present, given sufficient debugging information. Refer to
+  // context_validity.
+  MDRawContextLOONG64 context;
+
+  // For each register in context whose value has been recovered, we set
+  // the corresponding CONTEXT_VALID_ bit in context_validity.
+  uint64_t context_validity;
+};
+
 }  // namespace google_breakpad
 
 #endif  // GOOGLE_BREAKPAD_PROCESSOR_STACK_FRAME_CPU_H__
diff --git a/third_party/breakpad/breakpad/src/processor/dump_context.cc b/third_party/breakpad/breakpad/src/processor/dump_context.cc
index ab97930f90..51b47054d3 100644
--- a/third_party/breakpad/breakpad/src/processor/dump_context.cc
+++ b/third_party/breakpad/breakpad/src/processor/dump_context.cc
@@ -161,6 +161,15 @@ const MDRawContextRISCV64* DumpContext::GetContextRISCV64() const {
   return context_.riscv64;
 }
 
+const MDRawContextLOONG64* DumpContext::GetContextLOONG64() const {
+  if (GetContextCPU() != MD_CONTEXT_LOONG64) {
+    BPLOG(ERROR) << "DumpContext cannot get loongarch64 context";
+    return NULL;
+  }
+
+  return context_.ctx_loong64;
+}
+
 bool DumpContext::GetInstructionPointer(uint64_t* ip) const {
   BPLOG_IF(ERROR, !ip) << "DumpContext::GetInstructionPointer requires |ip|";
   assert(ip);
@@ -203,6 +212,9 @@ bool DumpContext::GetInstructionPointer(uint64_t* ip) const {
   case MD_CONTEXT_RISCV64:
     *ip = GetContextRISCV64()->pc;
     break;
+  case MD_CONTEXT_LOONG64:
+    *ip = GetContextLOONG64()->pc;
+    break;
   default:
     // This should never happen.
     BPLOG(ERROR) << "Unknown CPU architecture in GetInstructionPointer";
@@ -253,6 +265,9 @@ bool DumpContext::GetStackPointer(uint64_t* sp) const {
   case MD_CONTEXT_RISCV64:
     *sp = GetContextRISCV64()->sp;
     break;
+  case MD_CONTEXT_LOONG64:
+    *sp = GetContextLOONG64()->iregs[MD_CONTEXT_LOONG64_REG_SP];
+    break;
   default:
     // This should never happen.
     BPLOG(ERROR) << "Unknown CPU architecture in GetStackPointer";
@@ -305,6 +320,10 @@ void DumpContext::SetContextRISCV64(MDRawContextRISCV64* riscv64) {
   context_.riscv64 = riscv64;
 }
 
+void DumpContext::SetContextLOONG64(MDRawContextLOONG64* ctx_loong64) {
+  context_.ctx_loong64 = ctx_loong64;
+}
+
 void DumpContext::FreeContext() {
   switch (GetContextCPU()) {
     case MD_CONTEXT_X86:
@@ -348,6 +367,10 @@ void DumpContext::FreeContext() {
       delete context_.riscv64;
       break;
 
+    case MD_CONTEXT_LOONG64:
+      delete context_.ctx_loong64;
+      break;
+
     default:
       // There is no context record (valid_ is false) or there's a
       // context record for an unknown CPU (shouldn't happen, only known
@@ -872,6 +895,30 @@ void DumpContext::Print() {
       break;
     }
 
+    case MD_CONTEXT_LOONG64: {
+      const MDRawContextLOONG64* context_loong64 = GetContextLOONG64();
+      printf("MDRawContextLOONG64\n");
+      printf("  context_flags       = 0x%x\n", context_loong64->context_flags);
+      for (unsigned int ireg_index = 0; ireg_index < MD_CONTEXT_LOONG64_GPR_COUNT;
+           ++ireg_index) {
+        printf("  iregs[%2d]            = 0x%" PRIx64 "\n", ireg_index,
+               context_loong64->iregs[ireg_index]);
+      }
+      printf("  pc                  = 0x%lx\n", context_loong64->pc);
+      printf("  float_save.fcsr     = 0x%x\n", context_loong64->float_save.fcsr);
+      printf("  float_save.vcsr     = 0x%x\n", context_loong64->float_save.vcsr);
+
+      for (unsigned int freg_index = 0;
+           freg_index < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++freg_index) {
+        // TODO:LOONG64 Support vector FPU
+        uint64_t fp_value = context_loong64->float_save.regs[freg_index];
+        printf("  float_save.regs[%2d]            = 0x%" PRIx64 "\n",
+               freg_index, fp_value);
+      }
+
+      break;
+    }
+
     default: {
       break;
     }
diff --git a/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc b/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
index 09e4690d57..3f8018a551 100644
--- a/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
+++ b/third_party/breakpad/breakpad/src/processor/exploitability_unittest.cc
@@ -61,6 +61,9 @@ class ExploitabilityLinuxTestMinidumpContext : public MinidumpContext {
 }  // namespace google_breakpad
 #endif  // __linux__
 
+// The tests are designd for x86 processors.
+#if defined(__i386__) || defined(__x86_64__)
+
 namespace {
 
 using google_breakpad::BasicSourceLineResolver;
@@ -180,3 +183,4 @@ TEST(ExploitabilityTest, TestLinuxEngine) {
 }
 
 }  // namespace
+#endif
diff --git a/third_party/breakpad/breakpad/src/processor/microdump.cc b/third_party/breakpad/breakpad/src/processor/microdump.cc
index 94d2c200ac..1a2f741e19 100644
--- a/third_party/breakpad/breakpad/src/processor/microdump.cc
+++ b/third_party/breakpad/breakpad/src/processor/microdump.cc
@@ -68,6 +68,7 @@ static const char kArm64Architecture[] = "arm64";
 static const char kX86Architecture[] = "x86";
 static const char kMipsArchitecture[] = "mips";
 static const char kMips64Architecture[] = "mips64";
+static const char kLoong64Architecture[] = "loongarch64";
 static const char kGpuUnknown[] = "UNKNOWN";
 
 template<typename T>
@@ -154,6 +155,11 @@ void MicrodumpContext::SetContextMIPS64(MDRawContextMIPS* mips64) {
   valid_ = true;
 }
 
+void MicrodumpContext::SetContextLOONG64(MDRawContextLOONG64* loong64) {
+  DumpContext::SetContextFlags(MD_CONTEXT_LOONG64);
+  DumpContext::SetContextLOONG64(loong64);
+  valid_ = true;
+}
 
 //
 // MicrodumpMemoryRegion
@@ -362,6 +368,16 @@ Microdump::Microdump(const string& contents)
         MDRawContextMIPS* mips64 = new MDRawContextMIPS();
         memcpy(mips64, &cpu_state_raw[0], cpu_state_raw.size());
         context_->SetContextMIPS64(mips64);
+      } else if (strcmp(arch.c_str(), kLoong64Architecture) == 0) {
+        if (cpu_state_raw.size() != sizeof(MDRawContextLOONG64)) {
+          std::cerr << "Malformed CPU context. Got " << cpu_state_raw.size()
+                    << " bytes instead of " << sizeof(MDRawContextLOONG64)
+                    << std::endl;
+          continue;
+        }
+        MDRawContextLOONG64* loong64 = new MDRawContextLOONG64();
+        memcpy(loong64, &cpu_state_raw[0], cpu_state_raw.size());
+        context_->SetContextLOONG64(loong64);
       } else {
         std::cerr << "Unsupported architecture: " << arch << std::endl;
       }
diff --git a/third_party/breakpad/breakpad/src/processor/minidump.cc b/third_party/breakpad/breakpad/src/processor/minidump.cc
index 83f72b97bd..00191399c3 100644
--- a/third_party/breakpad/breakpad/src/processor/minidump.cc
+++ b/third_party/breakpad/breakpad/src/processor/minidump.cc
@@ -109,6 +109,8 @@ bool IsContextSizeUnique(uint32_t context_size) {
     num_matching_contexts++;
   if (context_size == sizeof(MDRawContextRISCV64))
     num_matching_contexts++;
+  if (context_size == sizeof(MDRawContextLOONG64))
+    num_matching_contexts++;
   return num_matching_contexts == 1;
 }
 
@@ -1348,6 +1350,60 @@ bool MinidumpContext::Read(uint32_t expected_size) {
         break;
       }
 
+      case MD_CONTEXT_LOONG64: {
+        if (expected_size != sizeof(MDRawContextLOONG64)) {
+          BPLOG(ERROR) << "MinidumpContext loongarch64 size mismatch, " <<
+                       expected_size << " != " << sizeof(MDRawContextLOONG64);
+          return false;
+        }
+
+        scoped_ptr<MDRawContextLOONG64> context_loong64(new MDRawContextLOONG64());
+
+        // Set the context_flags member, which has already been read, and
+        // read the rest of the structure beginning with the first member
+        // after context_flags.
+        context_loong64->context_flags = context_flags;
+
+        size_t flags_size = sizeof(context_loong64->context_flags);
+        uint8_t* context_after_flags =
+            reinterpret_cast<uint8_t*>(context_loong64.get()) + flags_size;
+        if (!minidump_->ReadBytes(context_after_flags,
+                                  sizeof(*context_loong64) - flags_size)) {
+          BPLOG(ERROR) << "MinidumpContext could not read loongarch64 context";
+          return false;
+        }
+
+        // Do this after reading the entire MDRawContext structure because
+        // GetSystemInfo may seek minidump to a new position.
+        if (!CheckAgainstSystemInfo(cpu_type)) {
+          BPLOG(ERROR) << "MinidumpContext loongarch64 does not match system info";
+          return false;
+        }
+
+        if (minidump_->swap()) {
+          // context_loong64->context_flags was already swapped.
+          for (unsigned int ireg_index = 0;
+               ireg_index < MD_CONTEXT_LOONG64_GPR_COUNT;
+               ++ireg_index) {
+            Swap(&context_loong64->iregs[ireg_index]);
+          }
+          Swap(&context_loong64->pc);
+          Swap(&context_loong64->float_save.fcsr);
+          Swap(&context_loong64->float_save.vcsr);
+          Swap(&context_loong64->float_save.fcc);
+          for (unsigned int fpr_index = 0;
+               fpr_index < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT;
+               ++fpr_index) {
+            // TODO:LOONG64 Support vector FPU
+            // Normalize128(&context_loong64->float_save.regs[fpr_index],
+            //              minidump_->is_big_endian());
+            Swap(&context_loong64->float_save.regs[fpr_index]);
+          }
+        }
+        SetContextLOONG64(context_loong64.release());
+        break;
+      }
+
       default: {
         // Unknown context type - Don't log as an error yet. Let the
         // caller work that out.
@@ -1450,6 +1506,11 @@ bool MinidumpContext::CheckAgainstSystemInfo(uint32_t context_cpu_type) {
       if (system_info_cpu_type == MD_CPU_ARCHITECTURE_RISCV64)
         return_value = true;
       break;
+
+    case MD_CONTEXT_LOONG64:
+      if (system_info_cpu_type == MD_CPU_ARCHITECTURE_LOONG64)
+        return_value = true;
+      break;
   }
 
   BPLOG_IF(ERROR, !return_value) << "MinidumpContext CPU " <<
diff --git a/third_party/breakpad/breakpad/src/processor/minidump_processor.cc b/third_party/breakpad/breakpad/src/processor/minidump_processor.cc
index f412af6424..c8364e5a12 100644
--- a/third_party/breakpad/breakpad/src/processor/minidump_processor.cc
+++ b/third_party/breakpad/breakpad/src/processor/minidump_processor.cc
@@ -645,6 +645,11 @@ bool MinidumpProcessor::GetCPUInfo(Minidump* dump, SystemInfo* info) {
       break;
     }
 
+    case MD_CPU_ARCHITECTURE_LOONG64: {
+      info->cpu = "loongarch64";
+      break;
+    }
+
     default: {
       // Assign the numeric architecture ID into the CPU string.
       char cpu_string[7];
diff --git a/third_party/breakpad/breakpad/src/processor/stackwalker.cc b/third_party/breakpad/breakpad/src/processor/stackwalker.cc
index 1ff6cf7cb9..a7fdd5079e 100644
--- a/third_party/breakpad/breakpad/src/processor/stackwalker.cc
+++ b/third_party/breakpad/breakpad/src/processor/stackwalker.cc
@@ -60,6 +60,7 @@
 #include "processor/stackwalker_mips.h"
 #include "processor/stackwalker_riscv.h"
 #include "processor/stackwalker_riscv64.h"
+#include "processor/stackwalker_loong64.h"
 
 namespace google_breakpad {
 
@@ -290,6 +291,13 @@ Stackwalker* Stackwalker::StackwalkerForCPU(
                                                memory, modules,
                                                frame_symbolizer);
       break;
+
+    case MD_CONTEXT_LOONG64:
+      cpu_stackwalker = new StackwalkerLOONG64(system_info,
+                                            context->GetContextLOONG64(),
+                                            memory, modules,
+                                            frame_symbolizer);
+      break;
   }
 
   BPLOG_IF(ERROR, !cpu_stackwalker) << "Unknown CPU type " << HexString(cpu) <<
diff --git a/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc b/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
index 3e310bc7d8..072180b180 100644
--- a/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
+++ b/third_party/breakpad/breakpad/src/tools/linux/md2core/minidump-2-core.cc
@@ -82,6 +82,8 @@
   #define ELF_ARCH  EM_AARCH64
 #elif defined(__riscv)
   #define ELF_ARCH  EM_RISCV
+#elif defined(__loongarch64)
+  #define ELF_ARCH  EM_LOONGARCH
 #endif
 
 #if defined(__arm__)
@@ -310,7 +312,7 @@ struct CrashedProcess {
 
   struct Thread {
     pid_t tid;
-#if defined(__mips__) || defined(__riscv)
+#if defined(__mips__) || defined(__riscv) || defined(__loongarch__)
     mcontext_t mcontext;
 #else
     user_regs_struct regs;
@@ -599,6 +601,27 @@ ParseThreadRegisters(CrashedProcess::Thread* thread,
 #error "Unexpected __riscv_xlen"
 #endif
 }
+#elif defined(__loongarch_lp64)
+static void
+ ParseThreadRegisters(CrashedProcess::Thread* thread,
+                      const MinidumpMemoryRange& range) {
+  const MDRawContextLOONG64* rawregs = range.GetData<MDRawContextLOONG64>(0);
+
+  for (int i = 0; i < MD_CONTEXT_LOONG64_GPR_COUNT; ++i)
+    thread->mcontext.__gregs[i] = rawregs->iregs[i];
+
+  thread->mcontext.__pc = rawregs->pc;
+
+  for (int i = 0; i < MD_FLOATINGSAVEAREA_LOONG64_FPR_COUNT; ++i) {
+    // TODO:LOONG64 Support vector FPU
+    thread->mcontext.__fpregs[i].__val64[0] =
+        rawregs->float_save.regs[i];
+  }
+
+  thread->mcontext.__fcsr = rawregs->float_save.fcsr;
+  thread->mcontext.__vcsr = rawregs->float_save.fcsr;
+  thread->mcontext.__fcc = rawregs->float_save.fcc;
+ }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -704,6 +727,12 @@ ParseSystemInfo(const Options& options, CrashedProcess* crashinfo,
 # else
 #  error "Unexpected __riscv_xlen"
 # endif
+#elif defined(__loongarch64)
+  if (sysinfo->processor_architecture != MD_CPU_ARCHITECTURE_LOONG64) {
+    fprintf(stderr,
+            "This version of minidump-2-core only supports LoongArch (64bit).\n");
+    exit(1);
+  }
 #else
 #error "This code has not been ported to your platform yet"
 #endif
@@ -1029,6 +1058,8 @@ WriteThread(const Options& options, const CrashedProcess::Thread& thread,
   memcpy(&pr.pr_reg, &thread.mcontext.gregs, sizeof(user_regs_struct));
 #elif defined(__riscv)
   memcpy(&pr.pr_reg, &thread.mcontext.__gregs, sizeof(user_regs_struct));
+#elif defined(__loongarch__)
+  memcpy(&pr.pr_reg, &thread.mcontext.__gregs, sizeof(user_regs_struct));
 #else
   memcpy(&pr.pr_reg, &thread.regs, sizeof(user_regs_struct));
 #endif
diff --git a/third_party/crashpad/crashpad/client/crashpad_client_linux_test.cc b/third_party/crashpad/crashpad/client/crashpad_client_linux_test.cc
index 9b207db38d..98347426b1 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client_linux_test.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_linux_test.cc
@@ -510,8 +510,9 @@ class StartHandlerForSelfInChildTest : public MultiprocessExec {
 };
 
 TEST_P(StartHandlerForSelfTest, StartHandlerInChild) {
+// TODO(loongarch): Recheck CrashType::kInfiniteRecursion
 #if defined(ADDRESS_SANITIZER) || defined(MEMORY_SANITIZER) || \
-    defined(UNDEFINED_SANITIZER)
+    defined(UNDEFINED_SANITIZER) || defined(ARCH_CPU_LOONGARCH_FAMILY)
   if (Options().crash_type == CrashType::kInfiniteRecursion) {
     GTEST_SKIP();
   }
diff --git a/third_party/crashpad/crashpad/compat/non_win/winnt.h b/third_party/crashpad/crashpad/compat/non_win/winnt.h
index 5fd78b0d8e..57a972000b 100644
--- a/third_party/crashpad/crashpad/compat/non_win/winnt.h
+++ b/third_party/crashpad/crashpad/compat/non_win/winnt.h
@@ -67,6 +67,7 @@
 #define PROCESSOR_ARCHITECTURE_NEUTRAL 11
 #define PROCESSOR_ARCHITECTURE_ARM64 12
 #define PROCESSOR_ARCHITECTURE_ARM32_ON_WIN64 13
+#define PROCESSOR_ARCHITECTURE_LOONGARCH64 14
 #define PROCESSOR_ARCHITECTURE_UNKNOWN 0xffff
 //! \}
 
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context.h b/third_party/crashpad/crashpad/minidump/minidump_context.h
index 30988d8cb6..de6ef5d45b 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context.h
@@ -637,6 +637,59 @@ struct MinidumpContextMIPS64 {
   uint64_t fir;
 };
 
+//! \brief LOONGARCH64-specifc flags for
+//! MinidumpContextLOONGARCH64::context_flags.
+//! Based on minidump_cpu_loongarch64.h from breakpad
+enum MinidumpContextLOONGARCH64Flags : uint32_t {
+  //! \brief Identifies the context structure as LOONGARCH64.
+  kMinidumpContextLOONGARCH64 = 0x00800000,
+
+  //! \brief Indicates the validity of integer registers.
+  //!
+  //! Registers `0`-`31`, `pc` are valid.
+  kMinidumpContextLOONGARCH64Integer = kMinidumpContextLOONGARCH64 | 0x00000002,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Floating point registers `0`-`31`, `fcsr` and `fcc` are valid
+  kMinidumpContextLOONGARCH64FloatingPoint =
+      kMinidumpContextLOONGARCH64 | 0x00000004,
+
+  //! \brief Indicates the validity of all registers.
+  kMinidumpContextLOONGARCH64All = kMinidumpContextLOONGARCH64Integer |
+                                   kMinidumpContextLOONGARCH64FloatingPoint,
+};
+
+//! \brief A LOONGARCH64 CPU context (register state) carried in a minidump
+//! file.
+struct MinidumpContextLOONGARCH64 {
+  uint64_t context_flags;
+
+  //! \brief General purpose registers.
+  uint64_t regs[32];
+
+  //! \brief pc registers.
+  uint64_t pc;
+
+  //! \brief FPU registers.
+  union {
+    struct {
+      float _fp_fregs;
+      uint32_t _fp_pad;
+    } fregs[32];
+    double dregs[32];
+  } fpregs;
+
+  //! \brief Floating-point control and status register.
+  uint32_t fcsr;
+
+  //! \brief padding
+  uint32_t _pad;
+
+  //! \brief Floating-point status and control register.
+  uint64_t fcc;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
index 5f741ed741..9cf8187b0f 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
@@ -102,6 +102,13 @@ MinidumpContextWriter::CreateFromSnapshot(const CPUContext* context_snapshot) {
       break;
     }
 
+    case kCPUArchitectureLOONGARCH64: {
+      context = std::make_unique<MinidumpContextLOONGARCH64Writer>();
+      reinterpret_cast<MinidumpContextLOONGARCH64Writer*>(context.get())
+          ->InitializeFromSnapshot(context_snapshot->loongarch64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -556,4 +563,41 @@ size_t MinidumpContextMIPS64Writer::ContextSize() const {
   return sizeof(context_);
 }
 
+MinidumpContextLOONGARCH64Writer::MinidumpContextLOONGARCH64Writer()
+    : MinidumpContextWriter(), context_() {
+  context_.context_flags = kMinidumpContextLOONGARCH64;
+}
+
+MinidumpContextLOONGARCH64Writer::~MinidumpContextLOONGARCH64Writer() = default;
+
+void MinidumpContextLOONGARCH64Writer::InitializeFromSnapshot(
+    const CPUContextLOONGARCH64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextLOONGARCH64);
+
+  context_.context_flags = kMinidumpContextLOONGARCH64All;
+
+  static_assert(sizeof(context_.regs) == sizeof(context_snapshot->gregs),
+                "GPRs size mismatch");
+  memcpy(context_.regs, context_snapshot->gregs, sizeof(context_.regs));
+  context_.pc = context_snapshot->pc;
+
+  static_assert(sizeof(context_.fpregs) == sizeof(context_snapshot->fpregs),
+                "FPU size mismatch");
+  memcpy(context_.fpregs.dregs, context_snapshot->fpregs.dregs, sizeof(context_.fpregs));
+  context_.fcsr = context_snapshot->fcsr;
+  context_.fcc = context_snapshot->fcc;
+}
+
+bool MinidumpContextLOONGARCH64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextLOONGARCH64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
+
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
index 6660be437c..fa694b78e4 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
@@ -369,6 +369,46 @@ class MinidumpContextMIPS64Writer final : public MinidumpContextWriter {
   MinidumpContextMIPS64 context_;
 };
 
+//! \brief The writer for a MinidumpContextLOONGARCH64 structure in a minidump
+//! file.
+class MinidumpContextLOONGARCH64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextLOONGARCH64Writer();
+  ~MinidumpContextLOONGARCH64Writer() override;
+
+  //! \brief Initializes the MinidumpContextLOONGARCH based on \a
+  //! context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitializeFromSnapshot(const CPUContextLOONGARCH64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this object<E2><80><99>s private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextLOONGARCH64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextLOONGARCH64 context_;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_extensions.h b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
index f96cf25b6a..46351af83b 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_extensions.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
@@ -154,6 +154,7 @@ enum MinidumpCPUArchitecture : uint16_t {
   kMinidumpCPUArchitectureX86 = PROCESSOR_ARCHITECTURE_INTEL,
 
   kMinidumpCPUArchitectureMIPS = PROCESSOR_ARCHITECTURE_MIPS,
+  kMinidumpCPUArchitectureLOONGARCH64 = PROCESSOR_ARCHITECTURE_LOONGARCH64,
   kMinidumpCPUArchitectureAlpha = PROCESSOR_ARCHITECTURE_ALPHA,
 
   //! \brief 32-bit PowerPC.
diff --git a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 133ae3086a..3246da64f4 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -175,6 +175,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kCPU[] = "mips";
 #elif defined(ARCH_CPU_MIPS64EL)
   static constexpr char kCPU[] = "mips64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+  static constexpr char kCPU[] = "loongarch64";
 #else
 #error define kCPU for this CPU
 #endif
diff --git a/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
index 4468c41aff..9aa429400f 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
@@ -132,6 +132,9 @@ void MinidumpSystemInfoWriter::InitializeFromSnapshot(
     case kCPUArchitectureARM64:
       cpu_architecture = kMinidumpCPUArchitectureARM64;
       break;
+    case kCPUArchitectureLOONGARCH64:
+      cpu_architecture = kMinidumpCPUArchitectureLOONGARCH64;
+      break;
     default:
       NOTREACHED();
       cpu_architecture = kMinidumpCPUArchitectureUnknown;
diff --git a/third_party/crashpad/crashpad/snapshot/capture_memory.cc b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
index 0a465d22f6..abca5ac538 100644
--- a/third_party/crashpad/crashpad/snapshot/capture_memory.cc
+++ b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
@@ -117,6 +117,10 @@ void CaptureMemory::PointedToByContext(const CPUContext& context,
   for (size_t i = 0; i < std::size(context.mipsel->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.mipsel->regs[i]);
   }
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  for (size_t i = 0; i < std::size(context.loongarch64->gregs); ++i) {
+    MaybeCaptureMemoryAround(delegate, context.loongarch64->gregs[i]);
+  }
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
index 4003a9290f..b01895a50f 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
@@ -43,7 +43,10 @@ enum CPUArchitecture {
   kCPUArchitectureMIPSEL,
 
   //! \brief 64-bit MIPSEL.
-  kCPUArchitectureMIPS64EL
+  kCPUArchitectureMIPS64EL,
+
+  //! \brief 64-bit LoongArch.
+  kCPUArchitectureLOONGARCH64
 };
 
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.cc b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
index 6eaa853fd5..0ca7fd1edf 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.cc
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
@@ -170,6 +170,8 @@ uint64_t CPUContext::InstructionPointer() const {
       return arm->pc;
     case kCPUArchitectureARM64:
       return arm64->pc;
+    case kCPUArchitectureLOONGARCH64:
+      return loongarch64->pc;
     default:
       NOTREACHED();
       return ~0ull;
@@ -186,6 +188,8 @@ uint64_t CPUContext::StackPointer() const {
       return arm->sp;
     case kCPUArchitectureARM64:
       return arm64->sp;
+    case kCPUArchitectureLOONGARCH64:
+      return loongarch64->gregs[3];
     default:
       NOTREACHED();
       return ~0ull;
@@ -212,6 +216,7 @@ bool CPUContext::HasShadowStack() const {
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
     case kCPUArchitectureARM64:
+    case kCPUArchitectureLOONGARCH64:
       return false;
     case kCPUArchitectureX86_64:
       return x86_64->xstate.cet_u.cetmsr != 0;
@@ -226,6 +231,7 @@ bool CPUContext::Is64Bit() const {
     case kCPUArchitectureX86_64:
     case kCPUArchitectureARM64:
     case kCPUArchitectureMIPS64EL:
+    case kCPUArchitectureLOONGARCH64:
       return true;
     case kCPUArchitectureX86:
     case kCPUArchitectureARM:
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.h b/third_party/crashpad/crashpad/snapshot/cpu_context.h
index 7bc252be15..12ea7740d3 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.h
@@ -362,6 +362,24 @@ struct CPUContextMIPS64 {
   uint64_t fir;
 };
 
+//! \brief A context structure carrying LOONGARCH64 CPU state.
+struct CPUContextLOONGARCH64 {
+  uint64_t pc;
+  uint64_t gregs[32];
+  uint32_t flags;
+  uint32_t fcsr;
+  uint32_t vcsr;
+  uint64_t fcc;
+  union {
+    double dregs[32];
+    struct {
+      float _fp_fregs;
+      uint32_t _fp_pad;
+    } fregs[32];
+  } fpregs;
+  uint32_t reserved;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -402,6 +420,7 @@ struct CPUContext {
     CPUContextARM64* arm64;
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
+    CPUContextLOONGARCH64* loongarch64;
   };
 };
 
diff --git a/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc b/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
index 30e8b987c0..76bc5d231f 100644
--- a/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
+++ b/third_party/crashpad/crashpad/snapshot/elf/elf_image_reader.cc
@@ -593,13 +593,7 @@ bool ElfImageReader::ReadDynamicStringTableAtOffset(VMSize offset,
     return false;
   }
 
-  // GNU ld.so doesn't adjust the vdso's dynamic array entries by the load bias.
-  // If the address is too small to point into the loaded module range and is
-  // small enough to be an offset from the base of the module, adjust it now.
-  if (string_table_address < memory_.Base() &&
-      string_table_address < memory_.Size()) {
-    string_table_address += GetLoadBias();
-  }
+  string_table_address += GetLoadBias();
 
   if (!memory_.ReadCStringSizeLimited(
           string_table_address + offset, string_table_size - offset, string)) {
@@ -754,6 +748,9 @@ bool ElfImageReader::GetNumberOfSymbolEntriesFromDtHash(
     return false;
   }
 
+  // TODO(loongarch): Recheck LoadBias
+  dt_hash_address += GetLoadBias();
+
   struct {
     uint32_t nbucket;
     uint32_t nchain;
@@ -779,6 +776,9 @@ bool ElfImageReader::GetNumberOfSymbolEntriesFromDtGnuHash(
     return false;
   }
 
+  // TODO(loongarch): Recheck LoadBias
+  dt_gnu_hash_address += GetLoadBias();
+
   // See https://flapenguin.me/2017/05/10/elf-lookup-dt-gnu-hash/ and
   // https://sourceware.org/ml/binutils/2006-10/msg00377.html.
   struct {
diff --git a/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc b/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
index 4c59d74599..b717da2134 100644
--- a/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
+++ b/third_party/crashpad/crashpad/snapshot/elf/elf_symbol_table_reader.cc
@@ -72,16 +72,24 @@ bool ElfSymbolTableReader::ScanSymbolTable(const std::string& name,
   SymEnt entry;
   std::string string;
   size_t i = 0;
+
+  address += elf_reader_->GetLoadBias();
+
   while (i < num_entries_ && memory_->Read(address, sizeof(entry), &entry)) {
-    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string) &&
-        string == name) {
-      info_out->address = entry.st_value;
-      info_out->size = entry.st_size;
-      info_out->shndx = entry.st_shndx;
-      info_out->binding = GetBinding(entry);
-      info_out->type = GetType(entry);
-      info_out->visibility = GetVisibility(entry);
-      return true;
+    if (elf_reader_->ReadDynamicStringTableAtOffset(entry.st_name, &string)) {
+      // TODO(loongarch): Recheck vdso prefix
+      const char vdso_prefix[] = "__vdso_";
+      if (string.find(vdso_prefix) == 0)
+        string.erase(0, sizeof(vdso_prefix) - 1);
+      if (string == name) {
+        info_out->address = entry.st_value;
+        info_out->size = entry.st_size;
+        info_out->shndx = entry.st_shndx;
+        info_out->binding = GetBinding(entry);
+        info_out->type = GetType(entry);
+        info_out->visibility = GetVisibility(entry);
+        return true;
+      }
     }
     // TODO(scottmg): This should respect DT_SYMENT if present.
     address += sizeof(entry);
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
index 21db234324..9190ba91c7 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
@@ -266,6 +266,23 @@ void InitializeCPUContextARM64_OnlyFPSIMD(
   context->fpcr = float_context.fpcr;
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+void InitializeCPUContextLOONGARCH64(const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+    CPUContextLOONGARCH64* context) {
+  static_assert(sizeof(context->gregs) == sizeof(thread_context.gpr),
+                "registers size mismatch");
+  static_assert(sizeof(context->fpregs) == sizeof(float_context.fpr),
+                "fp registers size mismatch");
+  memcpy(&context->gregs, &thread_context.gpr, sizeof(context->gregs));
+  context->pc = thread_context.pc;
+
+  memcpy(&context->fpregs, &float_context.fpr, sizeof(context->fpregs));
+  context->fcsr = float_context.fcsr;
+  context->fcc = float_context.fcc;
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 }  // namespace internal
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
index 1ea5eecda6..aa7923e9dd 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
@@ -171,9 +171,25 @@ void InitializeCPUContextMIPS(
   context->fpcsr = float_context.fpcsr;
   context->fir = float_context.fpu_id;
 }
-
 #endif  // ARCH_CPU_MIPS_FAMILY || DOXYGEN
 
+#if defined(ARCH_CPU_LOONGARCH64) || DOXYGEN
+//! \brief Initializes a CPUContextLOONGARCH64 structure from native context
+//!     structures on Linux.
+//!
+//! This function has template specializations for LoongArch64
+//! architecture contexts, using ContextTraits32 or ContextTraits64 as template
+//! parameter, respectively.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[out] context The CPUContextLOONGARCH64 structure to initialize.
+void InitializeCPUContextLOONGARCH64(
+    const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+   CPUContextLOONGARCH64* context);
+#endif  // ARCH_CPU_LOONGARCH64 || DOXYGEN
+
 }  // namespace internal
 }  // namespace crashpad
 
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
index 4e6ec11f8b..50a405e627 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
@@ -325,6 +325,63 @@ bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
       reader, context_address, context_.mips64);
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+
+  /* WORKAROUND: signal_context isn't compatible with Mcontext64 here.
+   * singal_context is defined at sys/ucontext.h;
+   * Mcontext64 is defined at snapshot/linux/signal_context.h.
+   */
+  // typename Traits::SignalThreadContext thread_context;
+  typename Traits::SignalThreadContext thread_context;
+
+  LinuxVMAddress gregs_address = context_address +
+                                 offsetof(UContext<Traits>, mcontext) +
+                                 offsetof(typename Traits::MContext, gregs);
+
+  if (!memory->Read(gregs_address, sizeof(thread_context.gpr), &thread_context.gpr)) {
+    LOG(ERROR) << "Couldn't read gregs";
+    return false;
+  }
+
+  LinuxVMAddress pc_address = context_address +
+                              offsetof(UContext<Traits>, mcontext);
+  if (!memory->Read(pc_address, sizeof(thread_context.pc),
+                    &thread_context.pc)) {
+    LOG(ERROR) << "Couldn't read pc";
+    return false;
+  }
+
+  LinuxVMAddress fpregs_address = context_address +
+                                  offsetof(UContext<Traits>, mcontext) +
+                                  offsetof(typename Traits::MContext, fpregs);
+
+  typename Traits::SignalFloatContext fp_context;
+  if (!memory->Read(fpregs_address, sizeof(fp_context), &fp_context)) {
+    LOG(ERROR) << "Couldn't read fpregs";
+    return false;
+  }
+
+  InitializeCPUContextLOONGARCH64(thread_context, fp_context, dest_context);
+
+  return true;
+}
+
+template <>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+
+  return internal::ReadContext<ContextTraits64>(
+      reader, context_address, context_.loongarch64);
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(
@@ -354,11 +411,13 @@ bool ExceptionSnapshotLinux::Initialize(
         !ReadSiginfo<Traits64>(process_reader, siginfo_address)) {
       return false;
     }
+#if !defined(ARCH_CPU_LOONGARCH64)
   } else {
     if (!ReadContext<ContextTraits32>(process_reader, context_address) ||
         !ReadSiginfo<Traits32>(process_reader, siginfo_address)) {
       return false;
     }
+#endif
   }
 
   CaptureMemoryDelegateLinux capture_memory_delegate(
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
index 3ea3d931fe..d32c13c5f7 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
@@ -89,6 +89,8 @@ class ExceptionSnapshotLinux final : public ExceptionSnapshot {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    CPUContextLOONGARCH64 loongarch64;
 #endif
   } context_union_;
   CPUContext context_;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
index b0c75b98a0..ff1105cdcc 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
@@ -297,6 +297,26 @@ void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
             0);
 #undef CPU_ARCH_NAME
 }
+#elif defined(ARCH_CPU_LOONGARCH64)
+using NativeCPUContext = ucontext_t;
+
+void InitializeContext(NativeCPUContext* context) {
+  for (size_t reg = 0; reg < std::size(context->uc_mcontext.__gregs); ++reg) {
+    context->uc_mcontext.__gregs[reg] = reg;
+  }
+  memset(&context->uc_mcontext.__fpregs, 44, sizeof(context->uc_mcontext.__fpregs));
+}
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+  EXPECT_EQ(actual.architecture, kCPUArchitectureLOONGARCH64);
+  for (size_t reg = 0; reg < std::size(expected.uc_mcontext.__gregs); ++reg) {
+    EXPECT_EQ(actual.loongarch64->gregs[reg], expected.uc_mcontext.__gregs[reg]);
+  }
+
+  EXPECT_EQ(memcmp(&actual.loongarch64->fpregs,
+                   &expected.uc_mcontext.__fpregs,
+                   sizeof(actual.loongarch64->fpregs)),
+            0);
+}
 
 #else
 #error Port.
diff --git a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
index 8ec0edc6da..5eda8907f8 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
@@ -127,6 +127,8 @@ void ProcessReaderLinux::Thread::InitializeStack(ProcessReaderLinux* reader) {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   stack_pointer = reader->Is64Bit() ? thread_info.thread_context.t64.regs[29]
                                     : thread_info.thread_context.t32.regs[29];
+#elif defined(ARCH_CPU_LOONGARCH64)
+  stack_pointer = thread_info.thread_context.t64.gpr[3];
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
index 6ac7adea47..da306d82eb 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
@@ -422,6 +422,62 @@ static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
               "context offset mismatch");
 #endif
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+//TODO
+union __loongarch_mc_fp_state {
+     unsigned int   __val32[256 / 32];
+     unsigned long long   __val64[256 / 64];
+ };
+
+struct MContext64 {
+  uint64_t pc;
+  uint64_t gregs[32];
+  uint32_t flags;
+
+  uint32_t fcsr;
+  uint32_t vcsr;
+  uint32_t padding;
+  uint64_t fcc;
+  union __loongarch_mc_fp_state fpregs[32];
+  uint32_t __reserved;
+  uint32_t padding2[7];
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = ThreadContext::t64_t;
+  using SignalFloatContext = FloatContext::f64_t;
+  using CPUContext = CPUContextLOONGARCH64;
+};
+
+template <typename Traits>
+struct UContext {
+  typename Traits::ULong flags;
+  typename Traits::Address link;
+  SignalStack<Traits> stack;
+  uint64_t padding[3];
+  typename Traits::MContext mcontext;
+  Sigset<Traits> sigmask;
+};
+
+static_assert(offsetof(UContext<ContextTraits64>, mcontext) ==
+                  offsetof(ucontext_t, uc_mcontext),
+              "context offset mismtach");
+static_assert(offsetof(UContext<ContextTraits64>, mcontext.gregs) ==
+                  offsetof(ucontext_t, uc_mcontext.__gregs),
+              "gregs in context offset mismatch");
+static_assert(offsetof(UContext<ContextTraits64>, mcontext.fcc) ==
+                  offsetof(ucontext_t, uc_mcontext.__fcc),
+              "gregs in context offset mismatch");
+static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
+                  offsetof(ucontext_t, uc_mcontext.__fpregs),
+              "fpregs in context offset mismatch");
+static_assert(offsetof(UContext<ContextTraits64>, mcontext.__reserved) ==
+                  offsetof(ucontext_t, uc_mcontext.__reserved),
+              "reserved in context offset mismatch");
+static_assert(offsetof(UContext<ContextTraits64>, sigmask) ==
+                  offsetof(ucontext_t, uc_sigmask),
+              "sigmask offset mismatch");
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
index 8487155101..cf42090d29 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
@@ -205,6 +205,9 @@ CPUArchitecture SystemSnapshotLinux::GetCPUArchitecture() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return process_reader_->Is64Bit() ? kCPUArchitectureMIPS64EL
                                     : kCPUArchitectureMIPSEL;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  DCHECK(process_reader_->Is64Bit());
+  return kCPUArchitectureLOONGARCH64;
 #else
 #error port to your architecture
 #endif
@@ -220,6 +223,8 @@ uint32_t SystemSnapshotLinux::CPURevision() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return 0;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -240,6 +245,8 @@ std::string SystemSnapshotLinux::CPUVendor() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return std::string();
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -373,6 +380,8 @@ bool SystemSnapshotLinux::NXEnabled() const {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   // Not implementable on MIPS
   return false;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc b/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
index 7d9d08d2ed..b476d07a4d 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/test_modules.cc
@@ -110,6 +110,8 @@ bool WriteTestModule(const base::FilePath& module_path,
   module.ehdr.e_machine = EM_AARCH64;
 #elif defined(ARCH_CPU_MIPSEL) || defined(ARCH_CPU_MIPS64EL)
   module.ehdr.e_machine = EM_MIPS;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  module.ehdr.e_machine = EM_LOONGARCH;
 #endif
 
   module.ehdr.e_version = EV_CURRENT;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
index ba33401093..9cfbd0785c 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
@@ -190,6 +190,13 @@ bool ThreadSnapshotLinux::Initialize(
         thread.thread_info.float_context.f32,
         context_.mipsel);
   }
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+  InitializeCPUContextLOONGARCH64(
+      thread.thread_info.thread_context.t64,
+      thread.thread_info.float_context.f64,
+      context_.loongarch64);
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
index bd03f58200..d34c29cb91 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
@@ -74,6 +74,8 @@ class ThreadSnapshotLinux final : public ThreadSnapshot {
 #elif defined(ARCH_CPU_MIPS_FAMILY)
     CPUContextMIPS mipsel;
     CPUContextMIPS64 mips64;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    CPUContextLOONGARCH64 loongarch64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
index f2fa2ab37a..8898f95778 100644
--- a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
+++ b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
@@ -266,6 +266,30 @@ bool MinidumpContextConverter::Initialize(
     context_.mips64->fir = src->fir;
 
     memcpy(&context_.mips64->fpregs, &src->fpregs, sizeof(src->fpregs));
+  } else if (context_.architecture ==
+             CPUArchitecture::kCPUArchitectureLOONGARCH64) {
+    context_memory_.resize(sizeof(CPUContextLOONGARCH64));
+    context_.loongarch64 =
+        reinterpret_cast<CPUContextLOONGARCH64*>(context_memory_.data());
+    const MinidumpContextLOONGARCH64* src =
+        reinterpret_cast<const MinidumpContextLOONGARCH64*>(minidump_context.data());
+    if (minidump_context.size() < sizeof(MinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    if (!(src->context_flags & kMinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    for (size_t i = 0; i < std::size(src->regs); i++) {
+      context_.loongarch64->gregs[i] = src->regs[i];
+    }
+
+    context_.loongarch64->pc = src->pc;
+    context_.loongarch64->fcsr = src->fcsr;
+    context_.loongarch64->fcc = src->fcc;
+
+    memcpy(&context_.loongarch64->fpregs, &src->fpregs, sizeof(src->fpregs));
   } else {
     // Architecture is listed as "unknown".
     DLOG(ERROR) << "Unknown architecture";
diff --git a/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc b/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
index abccda3187..e321d4a597 100644
--- a/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
+++ b/third_party/crashpad/crashpad/snapshot/minidump/system_snapshot_minidump.cc
@@ -67,6 +67,8 @@ CPUArchitecture SystemSnapshotMinidump::GetCPUArchitecture() const {
       return kCPUArchitectureARM64;
     case kMinidumpCPUArchitectureMIPS:
       return kCPUArchitectureMIPSEL;
+    case kMinidumpCPUArchitectureLOONGARCH64:
+      return kCPUArchitectureLOONGARCH64;
     // No word on how MIPS64 is signalled
 
     default:
diff --git a/third_party/crashpad/crashpad/test/linux/get_tls.cc b/third_party/crashpad/crashpad/test/linux/get_tls.cc
index c8147f0dfb..c963157815 100644
--- a/third_party/crashpad/crashpad/test/linux/get_tls.cc
+++ b/third_party/crashpad/crashpad/test/linux/get_tls.cc
@@ -49,6 +49,9 @@ LinuxVMAddress GetTLS() {
       : "=r"(tls)
       :
       : "$3");
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  asm("move    %0,$tp\n\t"
+      : "=r"(tls) ::);
 #else
 #error Port.
 #endif  // ARCH_CPU_ARMEL
diff --git a/third_party/crashpad/crashpad/test/multiprocess_posix.cc b/third_party/crashpad/crashpad/test/multiprocess_posix.cc
index eb7cf9cd15..3286413801 100644
--- a/third_party/crashpad/crashpad/test/multiprocess_posix.cc
+++ b/third_party/crashpad/crashpad/test/multiprocess_posix.cc
@@ -162,7 +162,8 @@ void Multiprocess::SetExpectedChildTermination(TerminationReason reason,
 }
 
 void Multiprocess::SetExpectedChildTerminationBuiltinTrap() {
-#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY)
+#if defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_MIPS_FAMILY) || \
+    defined(ARCH_CPU_LOONG_FAMILY)
   SetExpectedChildTermination(kTerminationSignal, SIGTRAP);
 #else
   SetExpectedChildTermination(kTerminationSignal, SIGILL);
diff --git a/third_party/crashpad/crashpad/util/linux/ptracer.cc b/third_party/crashpad/crashpad/util/linux/ptracer.cc
index 25c89ea95c..f2aa3c9d6e 100644
--- a/third_party/crashpad/crashpad/util/linux/ptracer.cc
+++ b/third_party/crashpad/crashpad/util/linux/ptracer.cc
@@ -398,6 +398,48 @@ bool GetThreadArea64(pid_t tid,
   return true;
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return false;
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  iovec iov;
+  iov.iov_base = context;
+  iov.iov_len = sizeof(*context);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(NT_PRFPREG), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(context->f64)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size " << iov.iov_len
+                           << " != " << sizeof(context->f64);
+    return false;
+  }
+
+  return true;
+}
+
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  return false;
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  *address = context.t64.gpr[2];
+  return true;
+}
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/util/linux/thread_info.h b/third_party/crashpad/crashpad/util/linux/thread_info.h
index 9f60bd3ebe..0675f6a8a1 100644
--- a/third_party/crashpad/crashpad/util/linux/thread_info.h
+++ b/third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -68,7 +68,7 @@ union ThreadContext {
     uint32_t pc;
     uint32_t cpsr;
     uint32_t orig_r0;
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
     // Reflects output format of static int gpr32_get(), defined in
     // arch/mips/kernel/ptrace.c in kernel source
     uint32_t padding0_[6];
@@ -133,12 +133,18 @@ union ThreadContext {
     uint64_t cp0_badvaddr;
     uint64_t cp0_status;
     uint64_t cp0_cause;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    // Reflects user_regs_struct in sys/user.h.
+    uint64_t gpr[32];
+    uint64_t pc;
+    uint64_t badvaddr;
+    uint64_t reserved[11];
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
   } t64;
 
-#if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM64)
+#if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM64) || defined(ARCH_CPU_LOONGARCH_FAMILY)
   using NativeThreadContext = user_regs_struct;
 #elif defined(ARCH_CPU_ARMEL)
   using NativeThreadContext = user_regs;
@@ -219,6 +225,8 @@ union FloatContext {
     } fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    // TODO(loongarch): Port f32
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -253,6 +261,10 @@ union FloatContext {
     double fpregs[32];
     uint32_t fpcsr;
     uint32_t fpu_id;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    double fpr[32];
+    uint64_t fcc;
+    uint32_t fcsr;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -280,7 +292,7 @@ union FloatContext {
 #endif
 #elif defined(ARCH_CPU_ARM64)
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
 // No appropriate floating point context native type for available MIPS.
 #else
 #error Port.
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_linux.S b/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
index 9c3a726381..72fb6c0848 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_linux.S
@@ -30,7 +30,7 @@
   .globl CAPTURECONTEXT_SYMBOL2
 #if defined(__i386__) || defined(__x86_64__)
   .balign 16, 0x90
-#elif defined(__arm__) || defined(__aarch64__)
+#elif defined(__arm__) || defined(__aarch64__) || defined(__loongarch__)
   .balign 4, 0x0
   .type CAPTURECONTEXT_SYMBOL, %function
   .type CAPTURECONTEXT_SYMBOL2, %function
@@ -427,4 +427,52 @@ CAPTURECONTEXT_SYMBOL2:
   jr $ra
 
   .set at
+#elif defined(__loongarch_lp64)
+
+#define MCONTEXT_GREG_SIZE 8
+
+#define MCONTEXT_FPREG_SIZE 8
+#define MCONTEXT_PC_OFFSET 64
+#define MCONTEXT_GREGS_OFFSET 72
+#define MCONTEXT_FPREGS_OFFSET 352
+
+#define STORE_GPR(X) st.d $r##X, $a0, MCONTEXT_GREGS_OFFSET + X * MCONTEXT_GREG_SIZE
+#define STORE_FPR(X) fst.d $f##X, $a0, MCONTEXT_FPREGS_OFFSET + X * MCONTEXT_FPREG_SIZE
+#define STORE_PC st.d $ra, $a0, MCONTEXT_PC_OFFSET
+
+// TODO(loongarch): save floating-point registers on abi2.0 platform.
+  STORE_FPR(0)
+  STORE_FPR(1)
+  STORE_FPR(2)
+  STORE_FPR(3)
+  STORE_FPR(4)
+  STORE_FPR(5)
+  STORE_FPR(6)
+  STORE_FPR(7)
+  STORE_FPR(8)
+  STORE_FPR(9)
+  STORE_FPR(10)
+  STORE_FPR(11)
+  STORE_FPR(12)
+  STORE_FPR(13)
+  STORE_FPR(14)
+  STORE_FPR(15)
+  STORE_FPR(16)
+  STORE_FPR(17)
+  STORE_FPR(18)
+  STORE_FPR(19)
+  STORE_FPR(20)
+  STORE_FPR(21)
+  STORE_FPR(22)
+  STORE_FPR(23)
+  STORE_FPR(24)
+  STORE_FPR(25)
+  STORE_FPR(26)
+  STORE_FPR(27)
+  STORE_FPR(28)
+  STORE_FPR(29)
+  STORE_FPR(30)
+  STORE_FPR(31)
+
+  jirl $zero, $ra, 0
 #endif  // __i386__
diff --git a/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc b/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
index 35751bf8b2..172eac87d8 100644
--- a/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
+++ b/third_party/crashpad/crashpad/util/misc/capture_context_test_util_linux.cc
@@ -35,6 +35,8 @@ void SanityCheckContext(const NativeCPUContext& context) {
   EXPECT_EQ(context.uc_mcontext.regs[0], FromPointerCast<uintptr_t>(&context));
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   EXPECT_EQ(context.uc_mcontext.gregs[4], FromPointerCast<uintptr_t>(&context));
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  EXPECT_EQ(context.uc_mcontext.__gregs[4], FromPointerCast<uintptr_t>(&context));
 #endif
 }
 
@@ -49,6 +51,8 @@ uintptr_t ProgramCounterFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.pc;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.pc;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return context.uc_mcontext.__pc;
 #endif
 }
 
@@ -63,6 +67,8 @@ uintptr_t StackPointerFromContext(const NativeCPUContext& context) {
   return context.uc_mcontext.sp;
 #elif defined(ARCH_CPU_MIPS_FAMILY)
   return context.uc_mcontext.gregs[29];
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return context.uc_mcontext.__gregs[3];
 #endif
 }
 
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
index d5c9177f95..230f4870f7 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
+++ b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
@@ -237,6 +237,8 @@ std::string UserAgent() {
 #elif defined(ARCH_CPU_BIG_ENDIAN)
     static constexpr char arch[] = "aarch64_be";
 #endif
+#elif defined(ARCH_CPU_LOONGARCH64)
+    static constexpr char arch[] = "loongarch64";
 #else
 #error Port
 #endif
diff --git a/third_party/ffmpeg/BUILD.gn b/third_party/ffmpeg/BUILD.gn
index 91e2f508c3..72d51dd9f6 100644
--- a/third_party/ffmpeg/BUILD.gn
+++ b/third_party/ffmpeg/BUILD.gn
@@ -313,6 +313,10 @@ target(link_target_type, "ffmpeg_internal") {
         asmflags += [ "-DHAVE_VFP_ARGS=0" ]
       }
     }
+
+    if (current_cpu == "loong64") {
+      cflags += [ "-mlasx", "-mlsx", ]
+    }
   }
 
   if (is_fuchsia || (is_posix && !is_mac)) {
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config.h b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config.h
new file mode 100644
index 0000000000..84da8b7ed5
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config.h
@@ -0,0 +1,750 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_H
+#define FFMPEG_CONFIG_H
+/* #define FFMPEG_CONFIGURATION "--disable-everything --disable-all --disable-doc --disable-htmlpages --disable-manpages --disable-podpages --disable-txtpages --disable-static --enable-avcodec --enable-avformat --enable-avutil --enable-fft --enable-rdft --enable-static --enable-libopus --disable-debug --disable-bzlib --disable-error-resilience --disable-iconv --disable-network --disable-schannel --disable-sdl2 --disable-symver --disable-xlib --disable-zlib --disable-securetransport --disable-faan --disable-alsa --disable-autodetect --enable-decoder='vorbis,libopus,flac' --enable-decoder='pcm_u8,pcm_s16le,pcm_s24le,pcm_s32le,pcm_f32le,mp3' --enable-decoder='pcm_s16be,pcm_s24be,pcm_mulaw,pcm_alaw' --enable-demuxer='ogg,matroska,wav,flac,mp3,mov' --enable-parser='opus,vorbis,flac,mpegaudio,vp9' --extra-cflags=-I/mnt/zjz/playground/chromium/src/third_party/opus/src/include --disable-linux-perf --x86asmexe=nasm --optflags='\"-O2\"' --enable-decoder='theora,vp8' --enable-parser='vp3,vp8' --enable-cross-compile --arch=loongarch64 --target-os=linux --cc=/opt/llvm_chrome114/llvm_install_15.0.7-3249e9f63766-debian10/bin/clang --cxx=/opt/llvm_chrome114/llvm_install_15.0.7-3249e9f63766-debian10/bin/clang++ --ld=/opt/llvm_chrome114/llvm_install_15.0.7-3249e9f63766-debian10/bin/clang --sysroot=/mnt/zjz/playground/chromium/src/build/linux/debian_bullseye_loong64-sysroot --extra-cflags='--target=loongarch64-linux-gnu ' --extra-ldflags='--target=loongarch64-linux-gnu ' --enable-pic --extra-ldflags='-fuse-ld=lld' --enable-decoder='aac,h264' --enable-demuxer=aac --enable-parser='aac,h264'" -- elide long configuration string from binary */
+#define FFMPEG_LICENSE "LGPL version 2.1 or later"
+#define CONFIG_THIS_YEAR 2023
+#define FFMPEG_DATADIR "/usr/local/share/ffmpeg"
+#define AVCONV_DATADIR "/usr/local/share/ffmpeg"
+#define CC_IDENT "clang version 15.0.7 (ssh://luweining@rd.loongson.cn:29418/llvm-project 3249e9f63766bef04d5994c63de19991b7a5cbc2)"
+#define OS_NAME linux
+#define av_restrict restrict
+#define EXTERN_PREFIX ""
+#define EXTERN_ASM 
+#define BUILDSUF ""
+#define SLIBSUF ".so"
+#define HAVE_MMX2 HAVE_MMXEXT
+#define SWS_MAX_FILTER_SIZE 256
+#define ARCH_AARCH64 0
+#define ARCH_ALPHA 0
+#define ARCH_ARM 0
+#define ARCH_AVR32 0
+#define ARCH_AVR32_AP 0
+#define ARCH_AVR32_UC 0
+#define ARCH_BFIN 0
+#define ARCH_IA64 0
+#define ARCH_LOONGARCH 1
+#define ARCH_LOONGARCH32 0
+#define ARCH_LOONGARCH64 1
+#define ARCH_M68K 0
+#define ARCH_MIPS 0
+#define ARCH_MIPS64 0
+#define ARCH_PARISC 0
+#define ARCH_PPC 0
+#define ARCH_PPC64 0
+#define ARCH_RISCV 0
+#define ARCH_S390 0
+#define ARCH_SH4 0
+#define ARCH_SPARC 0
+#define ARCH_SPARC64 0
+#define ARCH_TILEGX 0
+#define ARCH_TILEPRO 0
+#define ARCH_TOMI 0
+#define ARCH_X86 0
+#define ARCH_X86_32 0
+#define ARCH_X86_64 0
+#define HAVE_ARMV5TE 0
+#define HAVE_ARMV6 0
+#define HAVE_ARMV6T2 0
+#define HAVE_ARMV8 0
+#define HAVE_NEON 0
+#define HAVE_VFP 0
+#define HAVE_VFPV3 0
+#define HAVE_SETEND 0
+#define HAVE_ALTIVEC 0
+#define HAVE_DCBZL 0
+#define HAVE_LDBRX 0
+#define HAVE_POWER8 0
+#define HAVE_PPC4XX 0
+#define HAVE_VSX 0
+#define HAVE_RVV 0
+#define HAVE_AESNI 0
+#define HAVE_AMD3DNOW 0
+#define HAVE_AMD3DNOWEXT 0
+#define HAVE_AVX 0
+#define HAVE_AVX2 0
+#define HAVE_AVX512 0
+#define HAVE_AVX512ICL 0
+#define HAVE_FMA3 0
+#define HAVE_FMA4 0
+#define HAVE_MMX 0
+#define HAVE_MMXEXT 0
+#define HAVE_SSE 0
+#define HAVE_SSE2 0
+#define HAVE_SSE3 0
+#define HAVE_SSE4 0
+#define HAVE_SSE42 0
+#define HAVE_SSSE3 0
+#define HAVE_XOP 0
+#define HAVE_CPUNOP 0
+#define HAVE_I686 0
+#define HAVE_MIPSFPU 0
+#define HAVE_MIPS32R2 0
+#define HAVE_MIPS32R5 0
+#define HAVE_MIPS64R2 0
+#define HAVE_MIPS32R6 0
+#define HAVE_MIPS64R6 0
+#define HAVE_MIPSDSP 0
+#define HAVE_MIPSDSPR2 0
+#define HAVE_MSA 0
+#define HAVE_LOONGSON2 0
+#define HAVE_LOONGSON3 0
+#define HAVE_MMI 0
+#define HAVE_LSX 1
+#define HAVE_LASX 1
+#define HAVE_ARMV5TE_EXTERNAL 0
+#define HAVE_ARMV6_EXTERNAL 0
+#define HAVE_ARMV6T2_EXTERNAL 0
+#define HAVE_ARMV8_EXTERNAL 0
+#define HAVE_NEON_EXTERNAL 0
+#define HAVE_VFP_EXTERNAL 0
+#define HAVE_VFPV3_EXTERNAL 0
+#define HAVE_SETEND_EXTERNAL 0
+#define HAVE_ALTIVEC_EXTERNAL 0
+#define HAVE_DCBZL_EXTERNAL 0
+#define HAVE_LDBRX_EXTERNAL 0
+#define HAVE_POWER8_EXTERNAL 0
+#define HAVE_PPC4XX_EXTERNAL 0
+#define HAVE_VSX_EXTERNAL 0
+#define HAVE_RVV_EXTERNAL 0
+#define HAVE_AESNI_EXTERNAL 0
+#define HAVE_AMD3DNOW_EXTERNAL 0
+#define HAVE_AMD3DNOWEXT_EXTERNAL 0
+#define HAVE_AVX_EXTERNAL 0
+#define HAVE_AVX2_EXTERNAL 0
+#define HAVE_AVX512_EXTERNAL 0
+#define HAVE_AVX512ICL_EXTERNAL 0
+#define HAVE_FMA3_EXTERNAL 0
+#define HAVE_FMA4_EXTERNAL 0
+#define HAVE_MMX_EXTERNAL 0
+#define HAVE_MMXEXT_EXTERNAL 0
+#define HAVE_SSE_EXTERNAL 0
+#define HAVE_SSE2_EXTERNAL 0
+#define HAVE_SSE3_EXTERNAL 0
+#define HAVE_SSE4_EXTERNAL 0
+#define HAVE_SSE42_EXTERNAL 0
+#define HAVE_SSSE3_EXTERNAL 0
+#define HAVE_XOP_EXTERNAL 0
+#define HAVE_CPUNOP_EXTERNAL 0
+#define HAVE_I686_EXTERNAL 0
+#define HAVE_MIPSFPU_EXTERNAL 0
+#define HAVE_MIPS32R2_EXTERNAL 0
+#define HAVE_MIPS32R5_EXTERNAL 0
+#define HAVE_MIPS64R2_EXTERNAL 0
+#define HAVE_MIPS32R6_EXTERNAL 0
+#define HAVE_MIPS64R6_EXTERNAL 0
+#define HAVE_MIPSDSP_EXTERNAL 0
+#define HAVE_MIPSDSPR2_EXTERNAL 0
+#define HAVE_MSA_EXTERNAL 0
+#define HAVE_LOONGSON2_EXTERNAL 0
+#define HAVE_LOONGSON3_EXTERNAL 0
+#define HAVE_MMI_EXTERNAL 0
+#define HAVE_LSX_EXTERNAL 0
+#define HAVE_LASX_EXTERNAL 0
+#define HAVE_ARMV5TE_INLINE 0
+#define HAVE_ARMV6_INLINE 0
+#define HAVE_ARMV6T2_INLINE 0
+#define HAVE_ARMV8_INLINE 0
+#define HAVE_NEON_INLINE 0
+#define HAVE_VFP_INLINE 0
+#define HAVE_VFPV3_INLINE 0
+#define HAVE_SETEND_INLINE 0
+#define HAVE_ALTIVEC_INLINE 0
+#define HAVE_DCBZL_INLINE 0
+#define HAVE_LDBRX_INLINE 0
+#define HAVE_POWER8_INLINE 0
+#define HAVE_PPC4XX_INLINE 0
+#define HAVE_VSX_INLINE 0
+#define HAVE_RVV_INLINE 0
+#define HAVE_AESNI_INLINE 0
+#define HAVE_AMD3DNOW_INLINE 0
+#define HAVE_AMD3DNOWEXT_INLINE 0
+#define HAVE_AVX_INLINE 0
+#define HAVE_AVX2_INLINE 0
+#define HAVE_AVX512_INLINE 0
+#define HAVE_AVX512ICL_INLINE 0
+#define HAVE_FMA3_INLINE 0
+#define HAVE_FMA4_INLINE 0
+#define HAVE_MMX_INLINE 0
+#define HAVE_MMXEXT_INLINE 0
+#define HAVE_SSE_INLINE 0
+#define HAVE_SSE2_INLINE 0
+#define HAVE_SSE3_INLINE 0
+#define HAVE_SSE4_INLINE 0
+#define HAVE_SSE42_INLINE 0
+#define HAVE_SSSE3_INLINE 0
+#define HAVE_XOP_INLINE 0
+#define HAVE_CPUNOP_INLINE 0
+#define HAVE_I686_INLINE 0
+#define HAVE_MIPSFPU_INLINE 0
+#define HAVE_MIPS32R2_INLINE 0
+#define HAVE_MIPS32R5_INLINE 0
+#define HAVE_MIPS64R2_INLINE 0
+#define HAVE_MIPS32R6_INLINE 0
+#define HAVE_MIPS64R6_INLINE 0
+#define HAVE_MIPSDSP_INLINE 0
+#define HAVE_MIPSDSPR2_INLINE 0
+#define HAVE_MSA_INLINE 0
+#define HAVE_LOONGSON2_INLINE 0
+#define HAVE_LOONGSON3_INLINE 0
+#define HAVE_MMI_INLINE 0
+#define HAVE_LSX_INLINE 0
+#define HAVE_LASX_INLINE 0
+#define HAVE_ALIGNED_STACK 0
+#define HAVE_FAST_64BIT 1
+#define HAVE_FAST_CLZ 1
+#define HAVE_FAST_CMOV 0
+#define HAVE_FAST_FLOAT16 0
+#define HAVE_LOCAL_ALIGNED 1
+#define HAVE_SIMD_ALIGN_16 0
+#define HAVE_SIMD_ALIGN_32 1
+#define HAVE_SIMD_ALIGN_64 0
+#define HAVE_ATOMIC_CAS_PTR 0
+#define HAVE_MACHINE_RW_BARRIER 0
+#define HAVE_MEMORYBARRIER 0
+#define HAVE_MM_EMPTY 0
+#define HAVE_RDTSC 0
+#define HAVE_SEM_TIMEDWAIT 1
+#define HAVE_SYNC_VAL_COMPARE_AND_SWAP 1
+#define HAVE_INLINE_ASM 1
+#define HAVE_SYMVER 0
+#define HAVE_X86ASM 0
+#define HAVE_BIGENDIAN 0
+#define HAVE_FAST_UNALIGNED 1
+#define HAVE_ARPA_INET_H 0
+#define HAVE_ASM_TYPES_H 1
+#define HAVE_CDIO_PARANOIA_H 0
+#define HAVE_CDIO_PARANOIA_PARANOIA_H 0
+#define HAVE_CUDA_H 0
+#define HAVE_DISPATCH_DISPATCH_H 0
+#define HAVE_DEV_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_BKTR_IOCTL_METEOR_H 0
+#define HAVE_DEV_IC_BT8XX_H 0
+#define HAVE_DEV_VIDEO_BKTR_IOCTL_BT848_H 0
+#define HAVE_DEV_VIDEO_METEOR_IOCTL_METEOR_H 0
+#define HAVE_DIRECT_H 0
+#define HAVE_DIRENT_H 1
+#define HAVE_DXGIDEBUG_H 0
+#define HAVE_DXVA_H 0
+#define HAVE_ES2_GL_H 0
+#define HAVE_GSM_H 0
+#define HAVE_IO_H 0
+#define HAVE_LINUX_DMA_BUF_H 0
+#define HAVE_LINUX_PERF_EVENT_H 1
+#define HAVE_MACHINE_IOCTL_BT848_H 0
+#define HAVE_MACHINE_IOCTL_METEOR_H 0
+#define HAVE_MALLOC_H 1
+#define HAVE_OPENCV2_CORE_CORE_C_H 0
+#define HAVE_OPENGL_GL3_H 0
+#define HAVE_POLL_H 1
+#define HAVE_SYS_PARAM_H 1
+#define HAVE_SYS_RESOURCE_H 1
+#define HAVE_SYS_SELECT_H 1
+#define HAVE_SYS_SOUNDCARD_H 1
+#define HAVE_SYS_TIME_H 1
+#define HAVE_SYS_UN_H 1
+#define HAVE_SYS_VIDEOIO_H 0
+#define HAVE_TERMIOS_H 1
+#define HAVE_UDPLITE_H 0
+#define HAVE_UNISTD_H 1
+#define HAVE_VALGRIND_VALGRIND_H 0 /* #define HAVE_VALGRIND_VALGRIND_H 0 -- forced to 0. See https://crbug.com/590440 */
+#define HAVE_WINDOWS_H 0
+#define HAVE_WINSOCK2_H 0
+#define HAVE_INTRINSICS_NEON 0
+#define HAVE_ATANF 1
+#define HAVE_ATAN2F 1
+#define HAVE_CBRT 1
+#define HAVE_CBRTF 1
+#define HAVE_COPYSIGN 1
+#define HAVE_COSF 1
+#define HAVE_ERF 1
+#define HAVE_EXP2 1
+#define HAVE_EXP2F 1
+#define HAVE_EXPF 1
+#define HAVE_HYPOT 1
+#define HAVE_ISFINITE 1
+#define HAVE_ISINF 1
+#define HAVE_ISNAN 1
+#define HAVE_LDEXPF 1
+#define HAVE_LLRINT 1
+#define HAVE_LLRINTF 1
+#define HAVE_LOG2 1
+#define HAVE_LOG2F 1
+#define HAVE_LOG10F 1
+#define HAVE_LRINT 1
+#define HAVE_LRINTF 1
+#define HAVE_POWF 1
+#define HAVE_RINT 1
+#define HAVE_ROUND 1
+#define HAVE_ROUNDF 1
+#define HAVE_SINF 1
+#define HAVE_TRUNC 1
+#define HAVE_TRUNCF 1
+#define HAVE_DOS_PATHS 0
+#define HAVE_LIBC_MSVCRT 0
+#define HAVE_MMAL_PARAMETER_VIDEO_MAX_NUM_CALLBACKS 0
+#define HAVE_SECTION_DATA_REL_RO 1
+#define HAVE_THREADS 1
+#define HAVE_UWP 0
+#define HAVE_WINRT 0
+#define HAVE_ACCESS 1
+#define HAVE_ALIGNED_MALLOC 0
+#define HAVE_ARC4RANDOM 0
+#define HAVE_CLOCK_GETTIME 1
+#define HAVE_CLOSESOCKET 0
+#define HAVE_COMMANDLINETOARGVW 0
+#define HAVE_FCNTL 1
+#define HAVE_GETADDRINFO 0
+#define HAVE_GETAUXVAL 1
+#define HAVE_GETENV 1
+#define HAVE_GETHRTIME 0
+#define HAVE_GETOPT 1
+#define HAVE_GETMODULEHANDLE 0
+#define HAVE_GETPROCESSAFFINITYMASK 0
+#define HAVE_GETPROCESSMEMORYINFO 0
+#define HAVE_GETPROCESSTIMES 0
+#define HAVE_GETRUSAGE 1
+#define HAVE_GETSTDHANDLE 0
+#define HAVE_GETSYSTEMTIMEASFILETIME 0
+#define HAVE_GETTIMEOFDAY 1
+#define HAVE_GLOB 1
+#define HAVE_GLXGETPROCADDRESS 0
+#define HAVE_GMTIME_R 1
+#define HAVE_INET_ATON 0
+#define HAVE_ISATTY 1
+#define HAVE_KBHIT 0
+#define HAVE_LOCALTIME_R 1
+#define HAVE_LSTAT 1
+#define HAVE_LZO1X_999_COMPRESS 0
+#define HAVE_MACH_ABSOLUTE_TIME 0
+#define HAVE_MAPVIEWOFFILE 0
+#define HAVE_MEMALIGN 1
+#define HAVE_MKSTEMP 1
+#define HAVE_MMAP 1
+#define HAVE_MPROTECT 1
+#define HAVE_NANOSLEEP 1
+#define HAVE_PEEKNAMEDPIPE 0
+#define HAVE_POSIX_MEMALIGN 1
+#define HAVE_PRCTL 0 /* #define HAVE_PRCTL 1 -- forced to 0 for Fuchsia */
+#define HAVE_PTHREAD_CANCEL 1
+#define HAVE_SCHED_GETAFFINITY 1
+#define HAVE_SECITEMIMPORT 0
+#define HAVE_SETCONSOLETEXTATTRIBUTE 0
+#define HAVE_SETCONSOLECTRLHANDLER 0
+#define HAVE_SETDLLDIRECTORY 0
+#define HAVE_SETMODE 0
+#define HAVE_SETRLIMIT 1
+#define HAVE_SLEEP 0
+#define HAVE_STRERROR_R 1
+#define HAVE_SYSCONF 1
+#define HAVE_SYSCTL 0 /* #define HAVE_SYSCTL 1 -- forced to 0 for Fuchsia */
+#define HAVE_USLEEP 1
+#define HAVE_UTGETOSTYPEFROMSTRING 0
+#define HAVE_VIRTUALALLOC 0
+#define HAVE_WGLGETPROCADDRESS 0
+#define HAVE_BCRYPT 0
+#define HAVE_VAAPI_DRM 0
+#define HAVE_VAAPI_X11 0
+#define HAVE_VDPAU_X11 0
+#define HAVE_PTHREADS 1
+#define HAVE_OS2THREADS 0
+#define HAVE_W32THREADS 0
+#define HAVE_AS_ARCH_DIRECTIVE 0
+#define HAVE_AS_DN_DIRECTIVE 0
+#define HAVE_AS_FPU_DIRECTIVE 0
+#define HAVE_AS_FUNC 0
+#define HAVE_AS_OBJECT_ARCH 0
+#define HAVE_ASM_MOD_Q 0
+#define HAVE_BLOCKS_EXTENSION 0
+#define HAVE_EBP_AVAILABLE 0
+#define HAVE_EBX_AVAILABLE 0
+#define HAVE_GNU_AS 0
+#define HAVE_GNU_WINDRES 0
+#define HAVE_IBM_ASM 0
+#define HAVE_INLINE_ASM_DIRECT_SYMBOL_REFS 0
+#define HAVE_INLINE_ASM_LABELS 1
+#define HAVE_INLINE_ASM_NONLOCAL_LABELS 1
+#define HAVE_PRAGMA_DEPRECATED 1
+#define HAVE_RSYNC_CONTIMEOUT 1
+#define HAVE_SYMVER_ASM_LABEL 1
+#define HAVE_SYMVER_GNU_ASM 1
+#define HAVE_VFP_ARGS 0
+#define HAVE_XFORM_ASM 0
+#define HAVE_XMM_CLOBBERS 0
+#define HAVE_DPI_AWARENESS_CONTEXT 0
+#define HAVE_IDXGIOUTPUT5 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVC 0
+#define HAVE_KCMVIDEOCODECTYPE_HEVCWITHALPHA 0
+#define HAVE_KCMVIDEOCODECTYPE_VP9 0
+#define HAVE_KCVPIXELFORMATTYPE_420YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_422YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR8BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR10BIPLANARVIDEORANGE 0
+#define HAVE_KCVPIXELFORMATTYPE_444YPCBCR16BIPLANARVIDEORANGE 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_2084_PQ 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2100_HLG 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_LINEAR 0
+#define HAVE_KCVIMAGEBUFFERYCBCRMATRIX_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERCOLORPRIMARIES_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_ITU_R_2020 0
+#define HAVE_KCVIMAGEBUFFERTRANSFERFUNCTION_SMPTE_ST_428_1 0
+#define HAVE_SOCKLEN_T 0
+#define HAVE_STRUCT_ADDRINFO 0
+#define HAVE_STRUCT_GROUP_SOURCE_REQ 0
+#define HAVE_STRUCT_IP_MREQ_SOURCE 0
+#define HAVE_STRUCT_IPV6_MREQ 0
+#define HAVE_STRUCT_MSGHDR_MSG_FLAGS 0
+#define HAVE_STRUCT_POLLFD 0
+#define HAVE_STRUCT_RUSAGE_RU_MAXRSS 1
+#define HAVE_STRUCT_SCTP_EVENT_SUBSCRIBE 0
+#define HAVE_STRUCT_SOCKADDR_IN6 0
+#define HAVE_STRUCT_SOCKADDR_SA_LEN 0
+#define HAVE_STRUCT_SOCKADDR_STORAGE 0
+#define HAVE_STRUCT_STAT_ST_MTIM_TV_NSEC 1
+#define HAVE_STRUCT_V4L2_FRMIVALENUM_DISCRETE 0
+#define HAVE_GZIP 1
+#define HAVE_LIBDRM_GETFB2 0
+#define HAVE_MAKEINFO 0
+#define HAVE_MAKEINFO_HTML 0
+#define HAVE_OPENCL_D3D11 0
+#define HAVE_OPENCL_DRM_ARM 0
+#define HAVE_OPENCL_DRM_BEIGNET 0
+#define HAVE_OPENCL_DXVA2 0
+#define HAVE_OPENCL_VAAPI_BEIGNET 0
+#define HAVE_OPENCL_VAAPI_INTEL_MEDIA 0
+#define HAVE_PERL 1
+#define HAVE_POD2MAN 1
+#define HAVE_TEXI2HTML 1
+#define HAVE_XMLLINT 1
+#define HAVE_ZLIB_GZIP 0
+#define CONFIG_DOC 0
+#define CONFIG_HTMLPAGES 0
+#define CONFIG_MANPAGES 0
+#define CONFIG_PODPAGES 0
+#define CONFIG_TXTPAGES 0
+#define CONFIG_AVIO_HTTP_SERVE_FILES_EXAMPLE 1
+#define CONFIG_AVIO_LIST_DIR_EXAMPLE 1
+#define CONFIG_AVIO_READ_CALLBACK_EXAMPLE 1
+#define CONFIG_DECODE_AUDIO_EXAMPLE 1
+#define CONFIG_DECODE_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_DECODE_FILTER_VIDEO_EXAMPLE 0
+#define CONFIG_DECODE_VIDEO_EXAMPLE 1
+#define CONFIG_DEMUX_DECODE_EXAMPLE 1
+#define CONFIG_ENCODE_AUDIO_EXAMPLE 1
+#define CONFIG_ENCODE_VIDEO_EXAMPLE 1
+#define CONFIG_EXTRACT_MVS_EXAMPLE 1
+#define CONFIG_FILTER_AUDIO_EXAMPLE 0
+#define CONFIG_HW_DECODE_EXAMPLE 1
+#define CONFIG_MUX_EXAMPLE 0
+#define CONFIG_QSV_DECODE_EXAMPLE 0
+#define CONFIG_REMUX_EXAMPLE 1
+#define CONFIG_RESAMPLE_AUDIO_EXAMPLE 0
+#define CONFIG_SCALE_VIDEO_EXAMPLE 0
+#define CONFIG_SHOW_METADATA_EXAMPLE 1
+#define CONFIG_TRANSCODE_AAC_EXAMPLE 0
+#define CONFIG_TRANSCODE_EXAMPLE 0
+#define CONFIG_VAAPI_ENCODE_EXAMPLE 0
+#define CONFIG_VAAPI_TRANSCODE_EXAMPLE 0
+#define CONFIG_QSV_TRANSCODE_EXAMPLE 0
+#define CONFIG_AVISYNTH 0
+#define CONFIG_FREI0R 0
+#define CONFIG_LIBCDIO 0
+#define CONFIG_LIBDAVS2 0
+#define CONFIG_LIBRUBBERBAND 0
+#define CONFIG_LIBVIDSTAB 0
+#define CONFIG_LIBX264 0
+#define CONFIG_LIBX265 0
+#define CONFIG_LIBXAVS 0
+#define CONFIG_LIBXAVS2 0
+#define CONFIG_LIBXVID 0
+#define CONFIG_DECKLINK 0
+#define CONFIG_LIBFDK_AAC 0
+#define CONFIG_LIBTLS 0
+#define CONFIG_GMP 0
+#define CONFIG_LIBARIBB24 0
+#define CONFIG_LIBLENSFUN 0
+#define CONFIG_LIBOPENCORE_AMRNB 0
+#define CONFIG_LIBOPENCORE_AMRWB 0
+#define CONFIG_LIBVO_AMRWBENC 0
+#define CONFIG_MBEDTLS 0
+#define CONFIG_RKMPP 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_CHROMAPRINT 0
+#define CONFIG_GCRYPT 0
+#define CONFIG_GNUTLS 0
+#define CONFIG_JNI 0
+#define CONFIG_LADSPA 0
+#define CONFIG_LCMS2 0
+#define CONFIG_LIBAOM 0
+#define CONFIG_LIBARIBCAPTION 0
+#define CONFIG_LIBASS 0
+#define CONFIG_LIBBLURAY 0
+#define CONFIG_LIBBS2B 0
+#define CONFIG_LIBCACA 0
+#define CONFIG_LIBCELT 0
+#define CONFIG_LIBCODEC2 0
+#define CONFIG_LIBDAV1D 0
+#define CONFIG_LIBDC1394 0
+#define CONFIG_LIBDRM 0
+#define CONFIG_LIBFLITE 0
+#define CONFIG_LIBFONTCONFIG 0
+#define CONFIG_LIBFREETYPE 0
+#define CONFIG_LIBFRIBIDI 0
+#define CONFIG_LIBGLSLANG 0
+#define CONFIG_LIBGME 0
+#define CONFIG_LIBGSM 0
+#define CONFIG_LIBIEC61883 0
+#define CONFIG_LIBILBC 0
+#define CONFIG_LIBJACK 0
+#define CONFIG_LIBJXL 0
+#define CONFIG_LIBKLVANC 0
+#define CONFIG_LIBKVAZAAR 0
+#define CONFIG_LIBMODPLUG 0
+#define CONFIG_LIBMP3LAME 0
+#define CONFIG_LIBMYSOFA 0
+#define CONFIG_LIBOPENCV 0
+#define CONFIG_LIBOPENH264 0
+#define CONFIG_LIBOPENJPEG 0
+#define CONFIG_LIBOPENMPT 0
+#define CONFIG_LIBOPENVINO 0
+#define CONFIG_LIBOPUS 1
+#define CONFIG_LIBPLACEBO 0
+#define CONFIG_LIBPULSE 0
+#define CONFIG_LIBRABBITMQ 0
+#define CONFIG_LIBRAV1E 0
+#define CONFIG_LIBRIST 0
+#define CONFIG_LIBRSVG 0
+#define CONFIG_LIBRTMP 0
+#define CONFIG_LIBSHADERC 0
+#define CONFIG_LIBSHINE 0
+#define CONFIG_LIBSMBCLIENT 0
+#define CONFIG_LIBSNAPPY 0
+#define CONFIG_LIBSOXR 0
+#define CONFIG_LIBSPEEX 0
+#define CONFIG_LIBSRT 0
+#define CONFIG_LIBSSH 0
+#define CONFIG_LIBSVTAV1 0
+#define CONFIG_LIBTENSORFLOW 0
+#define CONFIG_LIBTESSERACT 0
+#define CONFIG_LIBTHEORA 0
+#define CONFIG_LIBTWOLAME 0
+#define CONFIG_LIBUAVS3D 0
+#define CONFIG_LIBV4L2 0
+#define CONFIG_LIBVMAF 0
+#define CONFIG_LIBVORBIS 0
+#define CONFIG_LIBVPX 0
+#define CONFIG_LIBWEBP 0
+#define CONFIG_LIBXML2 0
+#define CONFIG_LIBZIMG 0
+#define CONFIG_LIBZMQ 0
+#define CONFIG_LIBZVBI 0
+#define CONFIG_LV2 0
+#define CONFIG_MEDIACODEC 0
+#define CONFIG_OPENAL 0
+#define CONFIG_OPENGL 0
+#define CONFIG_OPENSSL 0
+#define CONFIG_POCKETSPHINX 0
+#define CONFIG_VAPOURSYNTH 0
+#define CONFIG_ALSA 0
+#define CONFIG_APPKIT 0
+#define CONFIG_AVFOUNDATION 0
+#define CONFIG_BZLIB 0
+#define CONFIG_COREIMAGE 0
+#define CONFIG_ICONV 0
+#define CONFIG_LIBXCB 0
+#define CONFIG_LIBXCB_SHM 0
+#define CONFIG_LIBXCB_SHAPE 0
+#define CONFIG_LIBXCB_XFIXES 0
+#define CONFIG_LZMA 0
+#define CONFIG_MEDIAFOUNDATION 0
+#define CONFIG_METAL 0
+#define CONFIG_SCHANNEL 0
+#define CONFIG_SDL2 0
+#define CONFIG_SECURETRANSPORT 0
+#define CONFIG_SNDIO 0
+#define CONFIG_XLIB 0
+#define CONFIG_ZLIB 0
+#define CONFIG_CUDA_NVCC 0
+#define CONFIG_CUDA_SDK 0
+#define CONFIG_LIBNPP 0
+#define CONFIG_LIBMFX 0
+#define CONFIG_LIBVPL 0
+#define CONFIG_MMAL 0
+#define CONFIG_OMX 0
+#define CONFIG_OPENCL 0
+#define CONFIG_AMF 0
+#define CONFIG_AUDIOTOOLBOX 0
+#define CONFIG_CRYSTALHD 0
+#define CONFIG_CUDA 0
+#define CONFIG_CUDA_LLVM 0
+#define CONFIG_CUVID 0
+#define CONFIG_D3D11VA 0
+#define CONFIG_DXVA2 0
+#define CONFIG_FFNVCODEC 0
+#define CONFIG_NVDEC 0
+#define CONFIG_NVENC 0
+#define CONFIG_VAAPI 0
+#define CONFIG_VDPAU 0
+#define CONFIG_VIDEOTOOLBOX 0
+#define CONFIG_VULKAN 0
+#define CONFIG_V4L2_M2M 0
+#define CONFIG_FTRAPV 0
+#define CONFIG_GRAY 0
+#define CONFIG_HARDCODED_TABLES 0
+#define CONFIG_OMX_RPI 0
+#define CONFIG_RUNTIME_CPUDETECT 1
+#define CONFIG_SAFE_BITSTREAM_READER 1
+#define CONFIG_SHARED 0
+#define CONFIG_SMALL 0
+#define CONFIG_STATIC 1
+#define CONFIG_SWSCALE_ALPHA 1
+#define CONFIG_GPL 0
+#define CONFIG_NONFREE 0
+#define CONFIG_VERSION3 0
+#define CONFIG_AVDEVICE 0
+#define CONFIG_AVFILTER 0
+#define CONFIG_SWSCALE 0
+#define CONFIG_POSTPROC 0
+#define CONFIG_AVFORMAT 1
+#define CONFIG_AVCODEC 1
+#define CONFIG_SWRESAMPLE 0
+#define CONFIG_AVUTIL 1
+#define CONFIG_FFPLAY 0
+#define CONFIG_FFPROBE 0
+#define CONFIG_FFMPEG 0
+#define CONFIG_DCT 1
+#define CONFIG_DWT 0
+#define CONFIG_ERROR_RESILIENCE 0
+#define CONFIG_FAAN 0
+#define CONFIG_FAST_UNALIGNED 1
+#define CONFIG_FFT 1
+#define CONFIG_LSP 0
+#define CONFIG_MDCT 0
+#define CONFIG_PIXELUTILS 0
+#define CONFIG_NETWORK 0
+#define CONFIG_RDFT 1
+#define CONFIG_AUTODETECT 0
+#define CONFIG_FONTCONFIG 0
+#define CONFIG_LARGE_TESTS 1
+#define CONFIG_LINUX_PERF 0
+#define CONFIG_MACOS_KPERF 0
+#define CONFIG_MEMORY_POISONING 0
+#define CONFIG_NEON_CLOBBER_TEST 0
+#define CONFIG_OSSFUZZ 0
+#define CONFIG_PIC 1
+#define CONFIG_PTX_COMPRESSION 0
+#define CONFIG_THUMB 0
+#define CONFIG_VALGRIND_BACKTRACE 0
+#define CONFIG_XMM_CLOBBER_TEST 0
+#define CONFIG_BSFS 0
+#define CONFIG_DECODERS 1
+#define CONFIG_ENCODERS 0
+#define CONFIG_HWACCELS 0
+#define CONFIG_PARSERS 1
+#define CONFIG_INDEVS 0
+#define CONFIG_OUTDEVS 0
+#define CONFIG_FILTERS 0
+#define CONFIG_DEMUXERS 1
+#define CONFIG_MUXERS 0
+#define CONFIG_PROTOCOLS 0
+#define CONFIG_AANDCTTABLES 0
+#define CONFIG_AC3DSP 0
+#define CONFIG_ADTS_HEADER 1
+#define CONFIG_ATSC_A53 1
+#define CONFIG_AUDIO_FRAME_QUEUE 0
+#define CONFIG_AUDIODSP 0
+#define CONFIG_BLOCKDSP 0
+#define CONFIG_BSWAPDSP 0
+#define CONFIG_CABAC 1
+#define CONFIG_CBS 0
+#define CONFIG_CBS_AV1 0
+#define CONFIG_CBS_H264 0
+#define CONFIG_CBS_H265 0
+#define CONFIG_CBS_JPEG 0
+#define CONFIG_CBS_MPEG2 0
+#define CONFIG_CBS_VP9 0
+#define CONFIG_DEFLATE_WRAPPER 0
+#define CONFIG_DIRAC_PARSE 1
+#define CONFIG_DNN 0
+#define CONFIG_DOVI_RPU 0
+#define CONFIG_DVPROFILE 0
+#define CONFIG_EXIF 0
+#define CONFIG_FAANDCT 0
+#define CONFIG_FAANIDCT 0
+#define CONFIG_FDCTDSP 0
+#define CONFIG_FMTCONVERT 0
+#define CONFIG_FRAME_THREAD_ENCODER 0
+#define CONFIG_G722DSP 0
+#define CONFIG_GOLOMB 1
+#define CONFIG_GPLV3 0
+#define CONFIG_H263DSP 0
+#define CONFIG_H264CHROMA 1
+#define CONFIG_H264DSP 1
+#define CONFIG_H264PARSE 1
+#define CONFIG_H264PRED 1
+#define CONFIG_H264QPEL 1
+#define CONFIG_H264_SEI 1
+#define CONFIG_HEVCPARSE 0
+#define CONFIG_HEVC_SEI 0
+#define CONFIG_HPELDSP 1
+#define CONFIG_HUFFMAN 0
+#define CONFIG_HUFFYUVDSP 0
+#define CONFIG_HUFFYUVENCDSP 0
+#define CONFIG_IDCTDSP 0
+#define CONFIG_IIRFILTER 0
+#define CONFIG_INFLATE_WRAPPER 0
+#define CONFIG_INTRAX8 0
+#define CONFIG_ISO_MEDIA 1
+#define CONFIG_IVIDSP 0
+#define CONFIG_JPEGTABLES 0
+#define CONFIG_LGPLV3 0
+#define CONFIG_LIBX262 0
+#define CONFIG_LLAUDDSP 0
+#define CONFIG_LLVIDDSP 0
+#define CONFIG_LLVIDENCDSP 0
+#define CONFIG_LPC 0
+#define CONFIG_LZF 0
+#define CONFIG_ME_CMP 0
+#define CONFIG_MPEG_ER 0
+#define CONFIG_MPEGAUDIO 1
+#define CONFIG_MPEGAUDIODSP 1
+#define CONFIG_MPEGAUDIOHEADER 1
+#define CONFIG_MPEG4AUDIO 1
+#define CONFIG_MPEGVIDEO 0
+#define CONFIG_MPEGVIDEODEC 0
+#define CONFIG_MPEGVIDEOENC 0
+#define CONFIG_MSMPEG4DEC 0
+#define CONFIG_MSMPEG4ENC 0
+#define CONFIG_MSS34DSP 0
+#define CONFIG_PIXBLOCKDSP 0
+#define CONFIG_QPELDSP 0
+#define CONFIG_QSV 0
+#define CONFIG_QSVDEC 0
+#define CONFIG_QSVENC 0
+#define CONFIG_QSVVPP 0
+#define CONFIG_RANGECODER 0
+#define CONFIG_RIFFDEC 1
+#define CONFIG_RIFFENC 0
+#define CONFIG_RTPDEC 0
+#define CONFIG_RTPENC_CHAIN 0
+#define CONFIG_RV34DSP 0
+#define CONFIG_SCENE_SAD 0
+#define CONFIG_SINEWIN 1
+#define CONFIG_SNAPPY 0
+#define CONFIG_SRTP 0
+#define CONFIG_STARTCODE 1
+#define CONFIG_TEXTUREDSP 0
+#define CONFIG_TEXTUREDSPENC 0
+#define CONFIG_TPELDSP 0
+#define CONFIG_VAAPI_1 0
+#define CONFIG_VAAPI_ENCODE 0
+#define CONFIG_VC1DSP 0
+#define CONFIG_VIDEODSP 1
+#define CONFIG_VP3DSP 1
+#define CONFIG_VP56DSP 0
+#define CONFIG_VP8DSP 1
+#define CONFIG_WMA_FREQS 0
+#define CONFIG_WMV2DSP 0
+#endif /* FFMPEG_CONFIG_H */
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config_components.h b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config_components.h
new file mode 100644
index 0000000000..3604442a32
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/config_components.h
@@ -0,0 +1,2155 @@
+/* Automatically generated by configure - do not modify! */
+#ifndef FFMPEG_CONFIG_COMPONENTS_H
+#define FFMPEG_CONFIG_COMPONENTS_H
+#define CONFIG_AAC_ADTSTOASC_BSF 0
+#define CONFIG_AV1_FRAME_MERGE_BSF 0
+#define CONFIG_AV1_FRAME_SPLIT_BSF 0
+#define CONFIG_AV1_METADATA_BSF 0
+#define CONFIG_CHOMP_BSF 0
+#define CONFIG_DUMP_EXTRADATA_BSF 0
+#define CONFIG_DCA_CORE_BSF 0
+#define CONFIG_DTS2PTS_BSF 0
+#define CONFIG_DV_ERROR_MARKER_BSF 0
+#define CONFIG_EAC3_CORE_BSF 0
+#define CONFIG_EXTRACT_EXTRADATA_BSF 0
+#define CONFIG_FILTER_UNITS_BSF 0
+#define CONFIG_H264_METADATA_BSF 0
+#define CONFIG_H264_MP4TOANNEXB_BSF 0
+#define CONFIG_H264_REDUNDANT_PPS_BSF 0
+#define CONFIG_HAPQA_EXTRACT_BSF 0
+#define CONFIG_HEVC_METADATA_BSF 0
+#define CONFIG_HEVC_MP4TOANNEXB_BSF 0
+#define CONFIG_IMX_DUMP_HEADER_BSF 0
+#define CONFIG_MEDIA100_TO_MJPEGB_BSF 0
+#define CONFIG_MJPEG2JPEG_BSF 0
+#define CONFIG_MJPEGA_DUMP_HEADER_BSF 0
+#define CONFIG_MP3_HEADER_DECOMPRESS_BSF 0
+#define CONFIG_MPEG2_METADATA_BSF 0
+#define CONFIG_MPEG4_UNPACK_BFRAMES_BSF 0
+#define CONFIG_MOV2TEXTSUB_BSF 0
+#define CONFIG_NOISE_BSF 0
+#define CONFIG_NULL_BSF 0
+#define CONFIG_OPUS_METADATA_BSF 0
+#define CONFIG_PCM_RECHUNK_BSF 0
+#define CONFIG_PGS_FRAME_MERGE_BSF 0
+#define CONFIG_PRORES_METADATA_BSF 0
+#define CONFIG_REMOVE_EXTRADATA_BSF 0
+#define CONFIG_SETTS_BSF 0
+#define CONFIG_TEXT2MOVSUB_BSF 0
+#define CONFIG_TRACE_HEADERS_BSF 0
+#define CONFIG_TRUEHD_CORE_BSF 0
+#define CONFIG_VP9_METADATA_BSF 0
+#define CONFIG_VP9_RAW_REORDER_BSF 0
+#define CONFIG_VP9_SUPERFRAME_BSF 0
+#define CONFIG_VP9_SUPERFRAME_SPLIT_BSF 0
+#define CONFIG_AASC_DECODER 0
+#define CONFIG_AIC_DECODER 0
+#define CONFIG_ALIAS_PIX_DECODER 0
+#define CONFIG_AGM_DECODER 0
+#define CONFIG_AMV_DECODER 0
+#define CONFIG_ANM_DECODER 0
+#define CONFIG_ANSI_DECODER 0
+#define CONFIG_APNG_DECODER 0
+#define CONFIG_ARBC_DECODER 0
+#define CONFIG_ARGO_DECODER 0
+#define CONFIG_ASV1_DECODER 0
+#define CONFIG_ASV2_DECODER 0
+#define CONFIG_AURA_DECODER 0
+#define CONFIG_AURA2_DECODER 0
+#define CONFIG_AVRP_DECODER 0
+#define CONFIG_AVRN_DECODER 0
+#define CONFIG_AVS_DECODER 0
+#define CONFIG_AVUI_DECODER 0
+#define CONFIG_AYUV_DECODER 0
+#define CONFIG_BETHSOFTVID_DECODER 0
+#define CONFIG_BFI_DECODER 0
+#define CONFIG_BINK_DECODER 0
+#define CONFIG_BITPACKED_DECODER 0
+#define CONFIG_BMP_DECODER 0
+#define CONFIG_BMV_VIDEO_DECODER 0
+#define CONFIG_BRENDER_PIX_DECODER 0
+#define CONFIG_C93_DECODER 0
+#define CONFIG_CAVS_DECODER 0
+#define CONFIG_CDGRAPHICS_DECODER 0
+#define CONFIG_CDTOONS_DECODER 0
+#define CONFIG_CDXL_DECODER 0
+#define CONFIG_CFHD_DECODER 0
+#define CONFIG_CINEPAK_DECODER 0
+#define CONFIG_CLEARVIDEO_DECODER 0
+#define CONFIG_CLJR_DECODER 0
+#define CONFIG_CLLC_DECODER 0
+#define CONFIG_COMFORTNOISE_DECODER 0
+#define CONFIG_CPIA_DECODER 0
+#define CONFIG_CRI_DECODER 0
+#define CONFIG_CSCD_DECODER 0
+#define CONFIG_CYUV_DECODER 0
+#define CONFIG_DDS_DECODER 0
+#define CONFIG_DFA_DECODER 0
+#define CONFIG_DIRAC_DECODER 0
+#define CONFIG_DNXHD_DECODER 0
+#define CONFIG_DPX_DECODER 0
+#define CONFIG_DSICINVIDEO_DECODER 0
+#define CONFIG_DVAUDIO_DECODER 0
+#define CONFIG_DVVIDEO_DECODER 0
+#define CONFIG_DXA_DECODER 0
+#define CONFIG_DXTORY_DECODER 0
+#define CONFIG_DXV_DECODER 0
+#define CONFIG_EACMV_DECODER 0
+#define CONFIG_EAMAD_DECODER 0
+#define CONFIG_EATGQ_DECODER 0
+#define CONFIG_EATGV_DECODER 0
+#define CONFIG_EATQI_DECODER 0
+#define CONFIG_EIGHTBPS_DECODER 0
+#define CONFIG_EIGHTSVX_EXP_DECODER 0
+#define CONFIG_EIGHTSVX_FIB_DECODER 0
+#define CONFIG_ESCAPE124_DECODER 0
+#define CONFIG_ESCAPE130_DECODER 0
+#define CONFIG_EXR_DECODER 0
+#define CONFIG_FFV1_DECODER 0
+#define CONFIG_FFVHUFF_DECODER 0
+#define CONFIG_FIC_DECODER 0
+#define CONFIG_FITS_DECODER 0
+#define CONFIG_FLASHSV_DECODER 0
+#define CONFIG_FLASHSV2_DECODER 0
+#define CONFIG_FLIC_DECODER 0
+#define CONFIG_FLV_DECODER 0
+#define CONFIG_FMVC_DECODER 0
+#define CONFIG_FOURXM_DECODER 0
+#define CONFIG_FRAPS_DECODER 0
+#define CONFIG_FRWU_DECODER 0
+#define CONFIG_G2M_DECODER 0
+#define CONFIG_GDV_DECODER 0
+#define CONFIG_GEM_DECODER 0
+#define CONFIG_GIF_DECODER 0
+#define CONFIG_H261_DECODER 0
+#define CONFIG_H263_DECODER 0
+#define CONFIG_H263I_DECODER 0
+#define CONFIG_H263P_DECODER 0
+#define CONFIG_H263_V4L2M2M_DECODER 0
+#define CONFIG_H264_DECODER 1
+#define CONFIG_H264_CRYSTALHD_DECODER 0
+#define CONFIG_H264_V4L2M2M_DECODER 0
+#define CONFIG_H264_MEDIACODEC_DECODER 0
+#define CONFIG_H264_MMAL_DECODER 0
+#define CONFIG_H264_QSV_DECODER 0
+#define CONFIG_H264_RKMPP_DECODER 0
+#define CONFIG_HAP_DECODER 0
+#define CONFIG_HEVC_DECODER 0
+#define CONFIG_HEVC_QSV_DECODER 0
+#define CONFIG_HEVC_RKMPP_DECODER 0
+#define CONFIG_HEVC_V4L2M2M_DECODER 0
+#define CONFIG_HNM4_VIDEO_DECODER 0
+#define CONFIG_HQ_HQA_DECODER 0
+#define CONFIG_HQX_DECODER 0
+#define CONFIG_HUFFYUV_DECODER 0
+#define CONFIG_HYMT_DECODER 0
+#define CONFIG_IDCIN_DECODER 0
+#define CONFIG_IFF_ILBM_DECODER 0
+#define CONFIG_IMM4_DECODER 0
+#define CONFIG_IMM5_DECODER 0
+#define CONFIG_INDEO2_DECODER 0
+#define CONFIG_INDEO3_DECODER 0
+#define CONFIG_INDEO4_DECODER 0
+#define CONFIG_INDEO5_DECODER 0
+#define CONFIG_INTERPLAY_VIDEO_DECODER 0
+#define CONFIG_IPU_DECODER 0
+#define CONFIG_JPEG2000_DECODER 0
+#define CONFIG_JPEGLS_DECODER 0
+#define CONFIG_JV_DECODER 0
+#define CONFIG_KGV1_DECODER 0
+#define CONFIG_KMVC_DECODER 0
+#define CONFIG_LAGARITH_DECODER 0
+#define CONFIG_LOCO_DECODER 0
+#define CONFIG_LSCR_DECODER 0
+#define CONFIG_M101_DECODER 0
+#define CONFIG_MAGICYUV_DECODER 0
+#define CONFIG_MDEC_DECODER 0
+#define CONFIG_MEDIA100_DECODER 0
+#define CONFIG_MIMIC_DECODER 0
+#define CONFIG_MJPEG_DECODER 0
+#define CONFIG_MJPEGB_DECODER 0
+#define CONFIG_MMVIDEO_DECODER 0
+#define CONFIG_MOBICLIP_DECODER 0
+#define CONFIG_MOTIONPIXELS_DECODER 0
+#define CONFIG_MPEG1VIDEO_DECODER 0
+#define CONFIG_MPEG2VIDEO_DECODER 0
+#define CONFIG_MPEG4_DECODER 0
+#define CONFIG_MPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG4_V4L2M2M_DECODER 0
+#define CONFIG_MPEG4_MMAL_DECODER 0
+#define CONFIG_MPEGVIDEO_DECODER 0
+#define CONFIG_MPEG1_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_MMAL_DECODER 0
+#define CONFIG_MPEG2_CRYSTALHD_DECODER 0
+#define CONFIG_MPEG2_V4L2M2M_DECODER 0
+#define CONFIG_MPEG2_QSV_DECODER 0
+#define CONFIG_MPEG2_MEDIACODEC_DECODER 0
+#define CONFIG_MSA1_DECODER 0
+#define CONFIG_MSCC_DECODER 0
+#define CONFIG_MSMPEG4V1_DECODER 0
+#define CONFIG_MSMPEG4V2_DECODER 0
+#define CONFIG_MSMPEG4V3_DECODER 0
+#define CONFIG_MSMPEG4_CRYSTALHD_DECODER 0
+#define CONFIG_MSP2_DECODER 0
+#define CONFIG_MSRLE_DECODER 0
+#define CONFIG_MSS1_DECODER 0
+#define CONFIG_MSS2_DECODER 0
+#define CONFIG_MSVIDEO1_DECODER 0
+#define CONFIG_MSZH_DECODER 0
+#define CONFIG_MTS2_DECODER 0
+#define CONFIG_MV30_DECODER 0
+#define CONFIG_MVC1_DECODER 0
+#define CONFIG_MVC2_DECODER 0
+#define CONFIG_MVDV_DECODER 0
+#define CONFIG_MVHA_DECODER 0
+#define CONFIG_MWSC_DECODER 0
+#define CONFIG_MXPEG_DECODER 0
+#define CONFIG_NOTCHLC_DECODER 0
+#define CONFIG_NUV_DECODER 0
+#define CONFIG_PAF_VIDEO_DECODER 0
+#define CONFIG_PAM_DECODER 0
+#define CONFIG_PBM_DECODER 0
+#define CONFIG_PCX_DECODER 0
+#define CONFIG_PFM_DECODER 0
+#define CONFIG_PGM_DECODER 0
+#define CONFIG_PGMYUV_DECODER 0
+#define CONFIG_PGX_DECODER 0
+#define CONFIG_PHM_DECODER 0
+#define CONFIG_PHOTOCD_DECODER 0
+#define CONFIG_PICTOR_DECODER 0
+#define CONFIG_PIXLET_DECODER 0
+#define CONFIG_PNG_DECODER 0
+#define CONFIG_PPM_DECODER 0
+#define CONFIG_PRORES_DECODER 0
+#define CONFIG_PROSUMER_DECODER 0
+#define CONFIG_PSD_DECODER 0
+#define CONFIG_PTX_DECODER 0
+#define CONFIG_QDRAW_DECODER 0
+#define CONFIG_QOI_DECODER 0
+#define CONFIG_QPEG_DECODER 0
+#define CONFIG_QTRLE_DECODER 0
+#define CONFIG_R10K_DECODER 0
+#define CONFIG_R210_DECODER 0
+#define CONFIG_RASC_DECODER 0
+#define CONFIG_RAWVIDEO_DECODER 0
+#define CONFIG_RKA_DECODER 0
+#define CONFIG_RL2_DECODER 0
+#define CONFIG_ROQ_DECODER 0
+#define CONFIG_RPZA_DECODER 0
+#define CONFIG_RSCC_DECODER 0
+#define CONFIG_RV10_DECODER 0
+#define CONFIG_RV20_DECODER 0
+#define CONFIG_RV30_DECODER 0
+#define CONFIG_RV40_DECODER 0
+#define CONFIG_S302M_DECODER 0
+#define CONFIG_SANM_DECODER 0
+#define CONFIG_SCPR_DECODER 0
+#define CONFIG_SCREENPRESSO_DECODER 0
+#define CONFIG_SGA_DECODER 0
+#define CONFIG_SGI_DECODER 0
+#define CONFIG_SGIRLE_DECODER 0
+#define CONFIG_SHEERVIDEO_DECODER 0
+#define CONFIG_SIMBIOSIS_IMX_DECODER 0
+#define CONFIG_SMACKER_DECODER 0
+#define CONFIG_SMC_DECODER 0
+#define CONFIG_SMVJPEG_DECODER 0
+#define CONFIG_SNOW_DECODER 0
+#define CONFIG_SP5X_DECODER 0
+#define CONFIG_SPEEDHQ_DECODER 0
+#define CONFIG_SPEEX_DECODER 0
+#define CONFIG_SRGC_DECODER 0
+#define CONFIG_SUNRAST_DECODER 0
+#define CONFIG_SVQ1_DECODER 0
+#define CONFIG_SVQ3_DECODER 0
+#define CONFIG_TARGA_DECODER 0
+#define CONFIG_TARGA_Y216_DECODER 0
+#define CONFIG_TDSC_DECODER 0
+#define CONFIG_THEORA_DECODER 1
+#define CONFIG_THP_DECODER 0
+#define CONFIG_TIERTEXSEQVIDEO_DECODER 0
+#define CONFIG_TIFF_DECODER 0
+#define CONFIG_TMV_DECODER 0
+#define CONFIG_TRUEMOTION1_DECODER 0
+#define CONFIG_TRUEMOTION2_DECODER 0
+#define CONFIG_TRUEMOTION2RT_DECODER 0
+#define CONFIG_TSCC_DECODER 0
+#define CONFIG_TSCC2_DECODER 0
+#define CONFIG_TXD_DECODER 0
+#define CONFIG_ULTI_DECODER 0
+#define CONFIG_UTVIDEO_DECODER 0
+#define CONFIG_V210_DECODER 0
+#define CONFIG_V210X_DECODER 0
+#define CONFIG_V308_DECODER 0
+#define CONFIG_V408_DECODER 0
+#define CONFIG_V410_DECODER 0
+#define CONFIG_VB_DECODER 0
+#define CONFIG_VBN_DECODER 0
+#define CONFIG_VBLE_DECODER 0
+#define CONFIG_VC1_DECODER 0
+#define CONFIG_VC1_CRYSTALHD_DECODER 0
+#define CONFIG_VC1IMAGE_DECODER 0
+#define CONFIG_VC1_MMAL_DECODER 0
+#define CONFIG_VC1_QSV_DECODER 0
+#define CONFIG_VC1_V4L2M2M_DECODER 0
+#define CONFIG_VCR1_DECODER 0
+#define CONFIG_VMDVIDEO_DECODER 0
+#define CONFIG_VMNC_DECODER 0
+#define CONFIG_VP3_DECODER 1
+#define CONFIG_VP4_DECODER 0
+#define CONFIG_VP5_DECODER 0
+#define CONFIG_VP6_DECODER 0
+#define CONFIG_VP6A_DECODER 0
+#define CONFIG_VP6F_DECODER 0
+#define CONFIG_VP7_DECODER 0
+#define CONFIG_VP8_DECODER 1
+#define CONFIG_VP8_RKMPP_DECODER 0
+#define CONFIG_VP8_V4L2M2M_DECODER 0
+#define CONFIG_VP9_DECODER 0
+#define CONFIG_VP9_RKMPP_DECODER 0
+#define CONFIG_VP9_V4L2M2M_DECODER 0
+#define CONFIG_VQA_DECODER 0
+#define CONFIG_VQC_DECODER 0
+#define CONFIG_WBMP_DECODER 0
+#define CONFIG_WEBP_DECODER 0
+#define CONFIG_WCMV_DECODER 0
+#define CONFIG_WRAPPED_AVFRAME_DECODER 0
+#define CONFIG_WMV1_DECODER 0
+#define CONFIG_WMV2_DECODER 0
+#define CONFIG_WMV3_DECODER 0
+#define CONFIG_WMV3_CRYSTALHD_DECODER 0
+#define CONFIG_WMV3IMAGE_DECODER 0
+#define CONFIG_WNV1_DECODER 0
+#define CONFIG_XAN_WC3_DECODER 0
+#define CONFIG_XAN_WC4_DECODER 0
+#define CONFIG_XBM_DECODER 0
+#define CONFIG_XFACE_DECODER 0
+#define CONFIG_XL_DECODER 0
+#define CONFIG_XPM_DECODER 0
+#define CONFIG_XWD_DECODER 0
+#define CONFIG_Y41P_DECODER 0
+#define CONFIG_YLC_DECODER 0
+#define CONFIG_YOP_DECODER 0
+#define CONFIG_YUV4_DECODER 0
+#define CONFIG_ZERO12V_DECODER 0
+#define CONFIG_ZEROCODEC_DECODER 0
+#define CONFIG_ZLIB_DECODER 0
+#define CONFIG_ZMBV_DECODER 0
+#define CONFIG_AAC_DECODER 1
+#define CONFIG_AAC_FIXED_DECODER 0
+#define CONFIG_AAC_LATM_DECODER 0
+#define CONFIG_AC3_DECODER 0
+#define CONFIG_AC3_FIXED_DECODER 0
+#define CONFIG_ACELP_KELVIN_DECODER 0
+#define CONFIG_ALAC_DECODER 0
+#define CONFIG_ALS_DECODER 0
+#define CONFIG_AMRNB_DECODER 0
+#define CONFIG_AMRWB_DECODER 0
+#define CONFIG_APAC_DECODER 0
+#define CONFIG_APE_DECODER 0
+#define CONFIG_APTX_DECODER 0
+#define CONFIG_APTX_HD_DECODER 0
+#define CONFIG_ATRAC1_DECODER 0
+#define CONFIG_ATRAC3_DECODER 0
+#define CONFIG_ATRAC3AL_DECODER 0
+#define CONFIG_ATRAC3P_DECODER 0
+#define CONFIG_ATRAC3PAL_DECODER 0
+#define CONFIG_ATRAC9_DECODER 0
+#define CONFIG_BINKAUDIO_DCT_DECODER 0
+#define CONFIG_BINKAUDIO_RDFT_DECODER 0
+#define CONFIG_BMV_AUDIO_DECODER 0
+#define CONFIG_BONK_DECODER 0
+#define CONFIG_COOK_DECODER 0
+#define CONFIG_DCA_DECODER 0
+#define CONFIG_DFPWM_DECODER 0
+#define CONFIG_DOLBY_E_DECODER 0
+#define CONFIG_DSD_LSBF_DECODER 0
+#define CONFIG_DSD_MSBF_DECODER 0
+#define CONFIG_DSD_LSBF_PLANAR_DECODER 0
+#define CONFIG_DSD_MSBF_PLANAR_DECODER 0
+#define CONFIG_DSICINAUDIO_DECODER 0
+#define CONFIG_DSS_SP_DECODER 0
+#define CONFIG_DST_DECODER 0
+#define CONFIG_EAC3_DECODER 0
+#define CONFIG_EVRC_DECODER 0
+#define CONFIG_FASTAUDIO_DECODER 0
+#define CONFIG_FFWAVESYNTH_DECODER 0
+#define CONFIG_FLAC_DECODER 1
+#define CONFIG_FTR_DECODER 0
+#define CONFIG_G723_1_DECODER 0
+#define CONFIG_G729_DECODER 0
+#define CONFIG_GSM_DECODER 0
+#define CONFIG_GSM_MS_DECODER 0
+#define CONFIG_HCA_DECODER 0
+#define CONFIG_HCOM_DECODER 0
+#define CONFIG_HDR_DECODER 0
+#define CONFIG_IAC_DECODER 0
+#define CONFIG_ILBC_DECODER 0
+#define CONFIG_IMC_DECODER 0
+#define CONFIG_INTERPLAY_ACM_DECODER 0
+#define CONFIG_MACE3_DECODER 0
+#define CONFIG_MACE6_DECODER 0
+#define CONFIG_METASOUND_DECODER 0
+#define CONFIG_MISC4_DECODER 0
+#define CONFIG_MLP_DECODER 0
+#define CONFIG_MP1_DECODER 0
+#define CONFIG_MP1FLOAT_DECODER 0
+#define CONFIG_MP2_DECODER 0
+#define CONFIG_MP2FLOAT_DECODER 0
+#define CONFIG_MP3FLOAT_DECODER 0
+#define CONFIG_MP3_DECODER 1
+#define CONFIG_MP3ADUFLOAT_DECODER 0
+#define CONFIG_MP3ADU_DECODER 0
+#define CONFIG_MP3ON4FLOAT_DECODER 0
+#define CONFIG_MP3ON4_DECODER 0
+#define CONFIG_MPC7_DECODER 0
+#define CONFIG_MPC8_DECODER 0
+#define CONFIG_MSNSIREN_DECODER 0
+#define CONFIG_NELLYMOSER_DECODER 0
+#define CONFIG_ON2AVC_DECODER 0
+#define CONFIG_OPUS_DECODER 0
+#define CONFIG_PAF_AUDIO_DECODER 0
+#define CONFIG_QCELP_DECODER 0
+#define CONFIG_QDM2_DECODER 0
+#define CONFIG_QDMC_DECODER 0
+#define CONFIG_RA_144_DECODER 0
+#define CONFIG_RA_288_DECODER 0
+#define CONFIG_RALF_DECODER 0
+#define CONFIG_SBC_DECODER 0
+#define CONFIG_SHORTEN_DECODER 0
+#define CONFIG_SIPR_DECODER 0
+#define CONFIG_SIREN_DECODER 0
+#define CONFIG_SMACKAUD_DECODER 0
+#define CONFIG_SONIC_DECODER 0
+#define CONFIG_TAK_DECODER 0
+#define CONFIG_TRUEHD_DECODER 0
+#define CONFIG_TRUESPEECH_DECODER 0
+#define CONFIG_TTA_DECODER 0
+#define CONFIG_TWINVQ_DECODER 0
+#define CONFIG_VMDAUDIO_DECODER 0
+#define CONFIG_VORBIS_DECODER 1
+#define CONFIG_WAVARC_DECODER 0
+#define CONFIG_WAVPACK_DECODER 0
+#define CONFIG_WMALOSSLESS_DECODER 0
+#define CONFIG_WMAPRO_DECODER 0
+#define CONFIG_WMAV1_DECODER 0
+#define CONFIG_WMAV2_DECODER 0
+#define CONFIG_WMAVOICE_DECODER 0
+#define CONFIG_WS_SND1_DECODER 0
+#define CONFIG_XMA1_DECODER 0
+#define CONFIG_XMA2_DECODER 0
+#define CONFIG_PCM_ALAW_DECODER 1
+#define CONFIG_PCM_BLURAY_DECODER 0
+#define CONFIG_PCM_DVD_DECODER 0
+#define CONFIG_PCM_F16LE_DECODER 0
+#define CONFIG_PCM_F24LE_DECODER 0
+#define CONFIG_PCM_F32BE_DECODER 0
+#define CONFIG_PCM_F32LE_DECODER 1
+#define CONFIG_PCM_F64BE_DECODER 0
+#define CONFIG_PCM_F64LE_DECODER 0
+#define CONFIG_PCM_LXF_DECODER 0
+#define CONFIG_PCM_MULAW_DECODER 1
+#define CONFIG_PCM_S8_DECODER 0
+#define CONFIG_PCM_S8_PLANAR_DECODER 0
+#define CONFIG_PCM_S16BE_DECODER 1
+#define CONFIG_PCM_S16BE_PLANAR_DECODER 0
+#define CONFIG_PCM_S16LE_DECODER 1
+#define CONFIG_PCM_S16LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S24BE_DECODER 1
+#define CONFIG_PCM_S24DAUD_DECODER 0
+#define CONFIG_PCM_S24LE_DECODER 1
+#define CONFIG_PCM_S24LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S32BE_DECODER 0
+#define CONFIG_PCM_S32LE_DECODER 1
+#define CONFIG_PCM_S32LE_PLANAR_DECODER 0
+#define CONFIG_PCM_S64BE_DECODER 0
+#define CONFIG_PCM_S64LE_DECODER 0
+#define CONFIG_PCM_SGA_DECODER 0
+#define CONFIG_PCM_U8_DECODER 1
+#define CONFIG_PCM_U16BE_DECODER 0
+#define CONFIG_PCM_U16LE_DECODER 0
+#define CONFIG_PCM_U24BE_DECODER 0
+#define CONFIG_PCM_U24LE_DECODER 0
+#define CONFIG_PCM_U32BE_DECODER 0
+#define CONFIG_PCM_U32LE_DECODER 0
+#define CONFIG_PCM_VIDC_DECODER 0
+#define CONFIG_CBD2_DPCM_DECODER 0
+#define CONFIG_DERF_DPCM_DECODER 0
+#define CONFIG_GREMLIN_DPCM_DECODER 0
+#define CONFIG_INTERPLAY_DPCM_DECODER 0
+#define CONFIG_ROQ_DPCM_DECODER 0
+#define CONFIG_SDX2_DPCM_DECODER 0
+#define CONFIG_SOL_DPCM_DECODER 0
+#define CONFIG_XAN_DPCM_DECODER 0
+#define CONFIG_WADY_DPCM_DECODER 0
+#define CONFIG_ADPCM_4XM_DECODER 0
+#define CONFIG_ADPCM_ADX_DECODER 0
+#define CONFIG_ADPCM_AFC_DECODER 0
+#define CONFIG_ADPCM_AGM_DECODER 0
+#define CONFIG_ADPCM_AICA_DECODER 0
+#define CONFIG_ADPCM_ARGO_DECODER 0
+#define CONFIG_ADPCM_CT_DECODER 0
+#define CONFIG_ADPCM_DTK_DECODER 0
+#define CONFIG_ADPCM_EA_DECODER 0
+#define CONFIG_ADPCM_EA_MAXIS_XA_DECODER 0
+#define CONFIG_ADPCM_EA_R1_DECODER 0
+#define CONFIG_ADPCM_EA_R2_DECODER 0
+#define CONFIG_ADPCM_EA_R3_DECODER 0
+#define CONFIG_ADPCM_EA_XAS_DECODER 0
+#define CONFIG_ADPCM_G722_DECODER 0
+#define CONFIG_ADPCM_G726_DECODER 0
+#define CONFIG_ADPCM_G726LE_DECODER 0
+#define CONFIG_ADPCM_IMA_ACORN_DECODER 0
+#define CONFIG_ADPCM_IMA_AMV_DECODER 0
+#define CONFIG_ADPCM_IMA_ALP_DECODER 0
+#define CONFIG_ADPCM_IMA_APC_DECODER 0
+#define CONFIG_ADPCM_IMA_APM_DECODER 0
+#define CONFIG_ADPCM_IMA_CUNNING_DECODER 0
+#define CONFIG_ADPCM_IMA_DAT4_DECODER 0
+#define CONFIG_ADPCM_IMA_DK3_DECODER 0
+#define CONFIG_ADPCM_IMA_DK4_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_EACS_DECODER 0
+#define CONFIG_ADPCM_IMA_EA_SEAD_DECODER 0
+#define CONFIG_ADPCM_IMA_ISS_DECODER 0
+#define CONFIG_ADPCM_IMA_MOFLEX_DECODER 0
+#define CONFIG_ADPCM_IMA_MTF_DECODER 0
+#define CONFIG_ADPCM_IMA_OKI_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_DECODER 0
+#define CONFIG_ADPCM_IMA_RAD_DECODER 0
+#define CONFIG_ADPCM_IMA_SSI_DECODER 0
+#define CONFIG_ADPCM_IMA_SMJPEG_DECODER 0
+#define CONFIG_ADPCM_IMA_WAV_DECODER 0
+#define CONFIG_ADPCM_IMA_WS_DECODER 0
+#define CONFIG_ADPCM_MS_DECODER 0
+#define CONFIG_ADPCM_MTAF_DECODER 0
+#define CONFIG_ADPCM_PSX_DECODER 0
+#define CONFIG_ADPCM_SBPRO_2_DECODER 0
+#define CONFIG_ADPCM_SBPRO_3_DECODER 0
+#define CONFIG_ADPCM_SBPRO_4_DECODER 0
+#define CONFIG_ADPCM_SWF_DECODER 0
+#define CONFIG_ADPCM_THP_DECODER 0
+#define CONFIG_ADPCM_THP_LE_DECODER 0
+#define CONFIG_ADPCM_VIMA_DECODER 0
+#define CONFIG_ADPCM_XA_DECODER 0
+#define CONFIG_ADPCM_XMD_DECODER 0
+#define CONFIG_ADPCM_YAMAHA_DECODER 0
+#define CONFIG_ADPCM_ZORK_DECODER 0
+#define CONFIG_SSA_DECODER 0
+#define CONFIG_ASS_DECODER 0
+#define CONFIG_CCAPTION_DECODER 0
+#define CONFIG_DVBSUB_DECODER 0
+#define CONFIG_DVDSUB_DECODER 0
+#define CONFIG_JACOSUB_DECODER 0
+#define CONFIG_MICRODVD_DECODER 0
+#define CONFIG_MOVTEXT_DECODER 0
+#define CONFIG_MPL2_DECODER 0
+#define CONFIG_PGSSUB_DECODER 0
+#define CONFIG_PJS_DECODER 0
+#define CONFIG_REALTEXT_DECODER 0
+#define CONFIG_SAMI_DECODER 0
+#define CONFIG_SRT_DECODER 0
+#define CONFIG_STL_DECODER 0
+#define CONFIG_SUBRIP_DECODER 0
+#define CONFIG_SUBVIEWER_DECODER 0
+#define CONFIG_SUBVIEWER1_DECODER 0
+#define CONFIG_TEXT_DECODER 0
+#define CONFIG_VPLAYER_DECODER 0
+#define CONFIG_WEBVTT_DECODER 0
+#define CONFIG_XSUB_DECODER 0
+#define CONFIG_AAC_AT_DECODER 0
+#define CONFIG_AC3_AT_DECODER 0
+#define CONFIG_ADPCM_IMA_QT_AT_DECODER 0
+#define CONFIG_ALAC_AT_DECODER 0
+#define CONFIG_AMR_NB_AT_DECODER 0
+#define CONFIG_EAC3_AT_DECODER 0
+#define CONFIG_GSM_MS_AT_DECODER 0
+#define CONFIG_ILBC_AT_DECODER 0
+#define CONFIG_MP1_AT_DECODER 0
+#define CONFIG_MP2_AT_DECODER 0
+#define CONFIG_MP3_AT_DECODER 0
+#define CONFIG_PCM_ALAW_AT_DECODER 0
+#define CONFIG_PCM_MULAW_AT_DECODER 0
+#define CONFIG_QDMC_AT_DECODER 0
+#define CONFIG_QDM2_AT_DECODER 0
+#define CONFIG_LIBARIBCAPTION_DECODER 0
+#define CONFIG_LIBARIBB24_DECODER 0
+#define CONFIG_LIBCELT_DECODER 0
+#define CONFIG_LIBCODEC2_DECODER 0
+#define CONFIG_LIBDAV1D_DECODER 0
+#define CONFIG_LIBDAVS2_DECODER 0
+#define CONFIG_LIBFDK_AAC_DECODER 0
+#define CONFIG_LIBGSM_DECODER 0
+#define CONFIG_LIBGSM_MS_DECODER 0
+#define CONFIG_LIBILBC_DECODER 0
+#define CONFIG_LIBJXL_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_DECODER 0
+#define CONFIG_LIBOPENCORE_AMRWB_DECODER 0
+#define CONFIG_LIBOPENJPEG_DECODER 0
+#define CONFIG_LIBOPUS_DECODER 1
+#define CONFIG_LIBRSVG_DECODER 0
+#define CONFIG_LIBSPEEX_DECODER 0
+#define CONFIG_LIBUAVS3D_DECODER 0
+#define CONFIG_LIBVORBIS_DECODER 0
+#define CONFIG_LIBVPX_VP8_DECODER 0
+#define CONFIG_LIBVPX_VP9_DECODER 0
+#define CONFIG_LIBZVBI_TELETEXT_DECODER 0
+#define CONFIG_BINTEXT_DECODER 0
+#define CONFIG_XBIN_DECODER 0
+#define CONFIG_IDF_DECODER 0
+#define CONFIG_LIBAOM_AV1_DECODER 0
+#define CONFIG_AV1_DECODER 0
+#define CONFIG_AV1_CUVID_DECODER 0
+#define CONFIG_AV1_MEDIACODEC_DECODER 0
+#define CONFIG_AV1_QSV_DECODER 0
+#define CONFIG_LIBOPENH264_DECODER 0
+#define CONFIG_H264_CUVID_DECODER 0
+#define CONFIG_HEVC_CUVID_DECODER 0
+#define CONFIG_HEVC_MEDIACODEC_DECODER 0
+#define CONFIG_MJPEG_CUVID_DECODER 0
+#define CONFIG_MJPEG_QSV_DECODER 0
+#define CONFIG_MPEG1_CUVID_DECODER 0
+#define CONFIG_MPEG2_CUVID_DECODER 0
+#define CONFIG_MPEG4_CUVID_DECODER 0
+#define CONFIG_MPEG4_MEDIACODEC_DECODER 0
+#define CONFIG_VC1_CUVID_DECODER 0
+#define CONFIG_VP8_CUVID_DECODER 0
+#define CONFIG_VP8_MEDIACODEC_DECODER 0
+#define CONFIG_VP8_QSV_DECODER 0
+#define CONFIG_VP9_CUVID_DECODER 0
+#define CONFIG_VP9_MEDIACODEC_DECODER 0
+#define CONFIG_VP9_QSV_DECODER 0
+#define CONFIG_VNULL_DECODER 0
+#define CONFIG_ANULL_DECODER 0
+#define CONFIG_A64MULTI_ENCODER 0
+#define CONFIG_A64MULTI5_ENCODER 0
+#define CONFIG_ALIAS_PIX_ENCODER 0
+#define CONFIG_AMV_ENCODER 0
+#define CONFIG_APNG_ENCODER 0
+#define CONFIG_ASV1_ENCODER 0
+#define CONFIG_ASV2_ENCODER 0
+#define CONFIG_AVRP_ENCODER 0
+#define CONFIG_AVUI_ENCODER 0
+#define CONFIG_AYUV_ENCODER 0
+#define CONFIG_BITPACKED_ENCODER 0
+#define CONFIG_BMP_ENCODER 0
+#define CONFIG_CFHD_ENCODER 0
+#define CONFIG_CINEPAK_ENCODER 0
+#define CONFIG_CLJR_ENCODER 0
+#define CONFIG_COMFORTNOISE_ENCODER 0
+#define CONFIG_DNXHD_ENCODER 0
+#define CONFIG_DPX_ENCODER 0
+#define CONFIG_DVVIDEO_ENCODER 0
+#define CONFIG_EXR_ENCODER 0
+#define CONFIG_FFV1_ENCODER 0
+#define CONFIG_FFVHUFF_ENCODER 0
+#define CONFIG_FITS_ENCODER 0
+#define CONFIG_FLASHSV_ENCODER 0
+#define CONFIG_FLASHSV2_ENCODER 0
+#define CONFIG_FLV_ENCODER 0
+#define CONFIG_GIF_ENCODER 0
+#define CONFIG_H261_ENCODER 0
+#define CONFIG_H263_ENCODER 0
+#define CONFIG_H263P_ENCODER 0
+#define CONFIG_H264_MEDIACODEC_ENCODER 0
+#define CONFIG_HAP_ENCODER 0
+#define CONFIG_HUFFYUV_ENCODER 0
+#define CONFIG_JPEG2000_ENCODER 0
+#define CONFIG_JPEGLS_ENCODER 0
+#define CONFIG_LJPEG_ENCODER 0
+#define CONFIG_MAGICYUV_ENCODER 0
+#define CONFIG_MJPEG_ENCODER 0
+#define CONFIG_MPEG1VIDEO_ENCODER 0
+#define CONFIG_MPEG2VIDEO_ENCODER 0
+#define CONFIG_MPEG4_ENCODER 0
+#define CONFIG_MSMPEG4V2_ENCODER 0
+#define CONFIG_MSMPEG4V3_ENCODER 0
+#define CONFIG_MSVIDEO1_ENCODER 0
+#define CONFIG_PAM_ENCODER 0
+#define CONFIG_PBM_ENCODER 0
+#define CONFIG_PCX_ENCODER 0
+#define CONFIG_PFM_ENCODER 0
+#define CONFIG_PGM_ENCODER 0
+#define CONFIG_PGMYUV_ENCODER 0
+#define CONFIG_PHM_ENCODER 0
+#define CONFIG_PNG_ENCODER 0
+#define CONFIG_PPM_ENCODER 0
+#define CONFIG_PRORES_ENCODER 0
+#define CONFIG_PRORES_AW_ENCODER 0
+#define CONFIG_PRORES_KS_ENCODER 0
+#define CONFIG_QOI_ENCODER 0
+#define CONFIG_QTRLE_ENCODER 0
+#define CONFIG_R10K_ENCODER 0
+#define CONFIG_R210_ENCODER 0
+#define CONFIG_RAWVIDEO_ENCODER 0
+#define CONFIG_ROQ_ENCODER 0
+#define CONFIG_RPZA_ENCODER 0
+#define CONFIG_RV10_ENCODER 0
+#define CONFIG_RV20_ENCODER 0
+#define CONFIG_S302M_ENCODER 0
+#define CONFIG_SGI_ENCODER 0
+#define CONFIG_SMC_ENCODER 0
+#define CONFIG_SNOW_ENCODER 0
+#define CONFIG_SPEEDHQ_ENCODER 0
+#define CONFIG_SUNRAST_ENCODER 0
+#define CONFIG_SVQ1_ENCODER 0
+#define CONFIG_TARGA_ENCODER 0
+#define CONFIG_TIFF_ENCODER 0
+#define CONFIG_UTVIDEO_ENCODER 0
+#define CONFIG_V210_ENCODER 0
+#define CONFIG_V308_ENCODER 0
+#define CONFIG_V408_ENCODER 0
+#define CONFIG_V410_ENCODER 0
+#define CONFIG_VBN_ENCODER 0
+#define CONFIG_VC2_ENCODER 0
+#define CONFIG_WBMP_ENCODER 0
+#define CONFIG_WRAPPED_AVFRAME_ENCODER 0
+#define CONFIG_WMV1_ENCODER 0
+#define CONFIG_WMV2_ENCODER 0
+#define CONFIG_XBM_ENCODER 0
+#define CONFIG_XFACE_ENCODER 0
+#define CONFIG_XWD_ENCODER 0
+#define CONFIG_Y41P_ENCODER 0
+#define CONFIG_YUV4_ENCODER 0
+#define CONFIG_ZLIB_ENCODER 0
+#define CONFIG_ZMBV_ENCODER 0
+#define CONFIG_AAC_ENCODER 0
+#define CONFIG_AC3_ENCODER 0
+#define CONFIG_AC3_FIXED_ENCODER 0
+#define CONFIG_ALAC_ENCODER 0
+#define CONFIG_APTX_ENCODER 0
+#define CONFIG_APTX_HD_ENCODER 0
+#define CONFIG_DCA_ENCODER 0
+#define CONFIG_DFPWM_ENCODER 0
+#define CONFIG_EAC3_ENCODER 0
+#define CONFIG_FLAC_ENCODER 0
+#define CONFIG_G723_1_ENCODER 0
+#define CONFIG_HDR_ENCODER 0
+#define CONFIG_MLP_ENCODER 0
+#define CONFIG_MP2_ENCODER 0
+#define CONFIG_MP2FIXED_ENCODER 0
+#define CONFIG_NELLYMOSER_ENCODER 0
+#define CONFIG_OPUS_ENCODER 0
+#define CONFIG_RA_144_ENCODER 0
+#define CONFIG_SBC_ENCODER 0
+#define CONFIG_SONIC_ENCODER 0
+#define CONFIG_SONIC_LS_ENCODER 0
+#define CONFIG_TRUEHD_ENCODER 0
+#define CONFIG_TTA_ENCODER 0
+#define CONFIG_VORBIS_ENCODER 0
+#define CONFIG_WAVPACK_ENCODER 0
+#define CONFIG_WMAV1_ENCODER 0
+#define CONFIG_WMAV2_ENCODER 0
+#define CONFIG_PCM_ALAW_ENCODER 0
+#define CONFIG_PCM_BLURAY_ENCODER 0
+#define CONFIG_PCM_DVD_ENCODER 0
+#define CONFIG_PCM_F32BE_ENCODER 0
+#define CONFIG_PCM_F32LE_ENCODER 0
+#define CONFIG_PCM_F64BE_ENCODER 0
+#define CONFIG_PCM_F64LE_ENCODER 0
+#define CONFIG_PCM_MULAW_ENCODER 0
+#define CONFIG_PCM_S8_ENCODER 0
+#define CONFIG_PCM_S8_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16BE_ENCODER 0
+#define CONFIG_PCM_S16BE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S16LE_ENCODER 0
+#define CONFIG_PCM_S16LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S24BE_ENCODER 0
+#define CONFIG_PCM_S24DAUD_ENCODER 0
+#define CONFIG_PCM_S24LE_ENCODER 0
+#define CONFIG_PCM_S24LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S32BE_ENCODER 0
+#define CONFIG_PCM_S32LE_ENCODER 0
+#define CONFIG_PCM_S32LE_PLANAR_ENCODER 0
+#define CONFIG_PCM_S64BE_ENCODER 0
+#define CONFIG_PCM_S64LE_ENCODER 0
+#define CONFIG_PCM_U8_ENCODER 0
+#define CONFIG_PCM_U16BE_ENCODER 0
+#define CONFIG_PCM_U16LE_ENCODER 0
+#define CONFIG_PCM_U24BE_ENCODER 0
+#define CONFIG_PCM_U24LE_ENCODER 0
+#define CONFIG_PCM_U32BE_ENCODER 0
+#define CONFIG_PCM_U32LE_ENCODER 0
+#define CONFIG_PCM_VIDC_ENCODER 0
+#define CONFIG_ROQ_DPCM_ENCODER 0
+#define CONFIG_ADPCM_ADX_ENCODER 0
+#define CONFIG_ADPCM_ARGO_ENCODER 0
+#define CONFIG_ADPCM_G722_ENCODER 0
+#define CONFIG_ADPCM_G726_ENCODER 0
+#define CONFIG_ADPCM_G726LE_ENCODER 0
+#define CONFIG_ADPCM_IMA_AMV_ENCODER 0
+#define CONFIG_ADPCM_IMA_ALP_ENCODER 0
+#define CONFIG_ADPCM_IMA_APM_ENCODER 0
+#define CONFIG_ADPCM_IMA_QT_ENCODER 0
+#define CONFIG_ADPCM_IMA_SSI_ENCODER 0
+#define CONFIG_ADPCM_IMA_WAV_ENCODER 0
+#define CONFIG_ADPCM_IMA_WS_ENCODER 0
+#define CONFIG_ADPCM_MS_ENCODER 0
+#define CONFIG_ADPCM_SWF_ENCODER 0
+#define CONFIG_ADPCM_YAMAHA_ENCODER 0
+#define CONFIG_SSA_ENCODER 0
+#define CONFIG_ASS_ENCODER 0
+#define CONFIG_DVBSUB_ENCODER 0
+#define CONFIG_DVDSUB_ENCODER 0
+#define CONFIG_MOVTEXT_ENCODER 0
+#define CONFIG_SRT_ENCODER 0
+#define CONFIG_SUBRIP_ENCODER 0
+#define CONFIG_TEXT_ENCODER 0
+#define CONFIG_TTML_ENCODER 0
+#define CONFIG_WEBVTT_ENCODER 0
+#define CONFIG_XSUB_ENCODER 0
+#define CONFIG_AAC_AT_ENCODER 0
+#define CONFIG_ALAC_AT_ENCODER 0
+#define CONFIG_ILBC_AT_ENCODER 0
+#define CONFIG_PCM_ALAW_AT_ENCODER 0
+#define CONFIG_PCM_MULAW_AT_ENCODER 0
+#define CONFIG_LIBAOM_AV1_ENCODER 0
+#define CONFIG_LIBCODEC2_ENCODER 0
+#define CONFIG_LIBFDK_AAC_ENCODER 0
+#define CONFIG_LIBGSM_ENCODER 0
+#define CONFIG_LIBGSM_MS_ENCODER 0
+#define CONFIG_LIBILBC_ENCODER 0
+#define CONFIG_LIBJXL_ENCODER 0
+#define CONFIG_LIBMP3LAME_ENCODER 0
+#define CONFIG_LIBOPENCORE_AMRNB_ENCODER 0
+#define CONFIG_LIBOPENJPEG_ENCODER 0
+#define CONFIG_LIBOPUS_ENCODER 0
+#define CONFIG_LIBRAV1E_ENCODER 0
+#define CONFIG_LIBSHINE_ENCODER 0
+#define CONFIG_LIBSPEEX_ENCODER 0
+#define CONFIG_LIBSVTAV1_ENCODER 0
+#define CONFIG_LIBTHEORA_ENCODER 0
+#define CONFIG_LIBTWOLAME_ENCODER 0
+#define CONFIG_LIBVO_AMRWBENC_ENCODER 0
+#define CONFIG_LIBVORBIS_ENCODER 0
+#define CONFIG_LIBVPX_VP8_ENCODER 0
+#define CONFIG_LIBVPX_VP9_ENCODER 0
+#define CONFIG_LIBWEBP_ANIM_ENCODER 0
+#define CONFIG_LIBWEBP_ENCODER 0
+#define CONFIG_LIBX262_ENCODER 0
+#define CONFIG_LIBX264_ENCODER 0
+#define CONFIG_LIBX264RGB_ENCODER 0
+#define CONFIG_LIBX265_ENCODER 0
+#define CONFIG_LIBXAVS_ENCODER 0
+#define CONFIG_LIBXAVS2_ENCODER 0
+#define CONFIG_LIBXVID_ENCODER 0
+#define CONFIG_AAC_MF_ENCODER 0
+#define CONFIG_AC3_MF_ENCODER 0
+#define CONFIG_H263_V4L2M2M_ENCODER 0
+#define CONFIG_AV1_NVENC_ENCODER 0
+#define CONFIG_AV1_QSV_ENCODER 0
+#define CONFIG_AV1_AMF_ENCODER 0
+#define CONFIG_LIBOPENH264_ENCODER 0
+#define CONFIG_H264_AMF_ENCODER 0
+#define CONFIG_H264_MF_ENCODER 0
+#define CONFIG_H264_NVENC_ENCODER 0
+#define CONFIG_H264_OMX_ENCODER 0
+#define CONFIG_H264_QSV_ENCODER 0
+#define CONFIG_H264_V4L2M2M_ENCODER 0
+#define CONFIG_H264_VAAPI_ENCODER 0
+#define CONFIG_H264_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_HEVC_AMF_ENCODER 0
+#define CONFIG_HEVC_MEDIACODEC_ENCODER 0
+#define CONFIG_HEVC_MF_ENCODER 0
+#define CONFIG_HEVC_NVENC_ENCODER 0
+#define CONFIG_HEVC_QSV_ENCODER 0
+#define CONFIG_HEVC_V4L2M2M_ENCODER 0
+#define CONFIG_HEVC_VAAPI_ENCODER 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_LIBKVAZAAR_ENCODER 0
+#define CONFIG_MJPEG_QSV_ENCODER 0
+#define CONFIG_MJPEG_VAAPI_ENCODER 0
+#define CONFIG_MP3_MF_ENCODER 0
+#define CONFIG_MPEG2_QSV_ENCODER 0
+#define CONFIG_MPEG2_VAAPI_ENCODER 0
+#define CONFIG_MPEG4_OMX_ENCODER 0
+#define CONFIG_MPEG4_V4L2M2M_ENCODER 0
+#define CONFIG_PRORES_VIDEOTOOLBOX_ENCODER 0
+#define CONFIG_VP8_V4L2M2M_ENCODER 0
+#define CONFIG_VP8_VAAPI_ENCODER 0
+#define CONFIG_VP9_VAAPI_ENCODER 0
+#define CONFIG_VP9_QSV_ENCODER 0
+#define CONFIG_VNULL_ENCODER 0
+#define CONFIG_ANULL_ENCODER 0
+#define CONFIG_AV1_D3D11VA_HWACCEL 0
+#define CONFIG_AV1_D3D11VA2_HWACCEL 0
+#define CONFIG_AV1_DXVA2_HWACCEL 0
+#define CONFIG_AV1_NVDEC_HWACCEL 0
+#define CONFIG_AV1_VAAPI_HWACCEL 0
+#define CONFIG_AV1_VDPAU_HWACCEL 0
+#define CONFIG_H263_VAAPI_HWACCEL 0
+#define CONFIG_H263_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_H264_D3D11VA_HWACCEL 0
+#define CONFIG_H264_D3D11VA2_HWACCEL 0
+#define CONFIG_H264_DXVA2_HWACCEL 0
+#define CONFIG_H264_NVDEC_HWACCEL 0
+#define CONFIG_H264_VAAPI_HWACCEL 0
+#define CONFIG_H264_VDPAU_HWACCEL 0
+#define CONFIG_H264_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA_HWACCEL 0
+#define CONFIG_HEVC_D3D11VA2_HWACCEL 0
+#define CONFIG_HEVC_DXVA2_HWACCEL 0
+#define CONFIG_HEVC_NVDEC_HWACCEL 0
+#define CONFIG_HEVC_VAAPI_HWACCEL 0
+#define CONFIG_HEVC_VDPAU_HWACCEL 0
+#define CONFIG_HEVC_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MJPEG_NVDEC_HWACCEL 0
+#define CONFIG_MJPEG_VAAPI_HWACCEL 0
+#define CONFIG_MPEG1_NVDEC_HWACCEL 0
+#define CONFIG_MPEG1_VDPAU_HWACCEL 0
+#define CONFIG_MPEG1_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA_HWACCEL 0
+#define CONFIG_MPEG2_D3D11VA2_HWACCEL 0
+#define CONFIG_MPEG2_NVDEC_HWACCEL 0
+#define CONFIG_MPEG2_DXVA2_HWACCEL 0
+#define CONFIG_MPEG2_VAAPI_HWACCEL 0
+#define CONFIG_MPEG2_VDPAU_HWACCEL 0
+#define CONFIG_MPEG2_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_MPEG4_NVDEC_HWACCEL 0
+#define CONFIG_MPEG4_VAAPI_HWACCEL 0
+#define CONFIG_MPEG4_VDPAU_HWACCEL 0
+#define CONFIG_MPEG4_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_PRORES_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_VC1_D3D11VA_HWACCEL 0
+#define CONFIG_VC1_D3D11VA2_HWACCEL 0
+#define CONFIG_VC1_DXVA2_HWACCEL 0
+#define CONFIG_VC1_NVDEC_HWACCEL 0
+#define CONFIG_VC1_VAAPI_HWACCEL 0
+#define CONFIG_VC1_VDPAU_HWACCEL 0
+#define CONFIG_VP8_NVDEC_HWACCEL 0
+#define CONFIG_VP8_VAAPI_HWACCEL 0
+#define CONFIG_VP9_D3D11VA_HWACCEL 0
+#define CONFIG_VP9_D3D11VA2_HWACCEL 0
+#define CONFIG_VP9_DXVA2_HWACCEL 0
+#define CONFIG_VP9_NVDEC_HWACCEL 0
+#define CONFIG_VP9_VAAPI_HWACCEL 0
+#define CONFIG_VP9_VDPAU_HWACCEL 0
+#define CONFIG_VP9_VIDEOTOOLBOX_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA_HWACCEL 0
+#define CONFIG_WMV3_D3D11VA2_HWACCEL 0
+#define CONFIG_WMV3_DXVA2_HWACCEL 0
+#define CONFIG_WMV3_NVDEC_HWACCEL 0
+#define CONFIG_WMV3_VAAPI_HWACCEL 0
+#define CONFIG_WMV3_VDPAU_HWACCEL 0
+#define CONFIG_AAC_PARSER 1
+#define CONFIG_AAC_LATM_PARSER 0
+#define CONFIG_AC3_PARSER 0
+#define CONFIG_ADX_PARSER 0
+#define CONFIG_AMR_PARSER 0
+#define CONFIG_AV1_PARSER 0
+#define CONFIG_AVS2_PARSER 0
+#define CONFIG_AVS3_PARSER 0
+#define CONFIG_BMP_PARSER 0
+#define CONFIG_CAVSVIDEO_PARSER 0
+#define CONFIG_COOK_PARSER 0
+#define CONFIG_CRI_PARSER 0
+#define CONFIG_DCA_PARSER 0
+#define CONFIG_DIRAC_PARSER 0
+#define CONFIG_DNXHD_PARSER 0
+#define CONFIG_DOLBY_E_PARSER 0
+#define CONFIG_DPX_PARSER 0
+#define CONFIG_DVAUDIO_PARSER 0
+#define CONFIG_DVBSUB_PARSER 0
+#define CONFIG_DVDSUB_PARSER 0
+#define CONFIG_DVD_NAV_PARSER 0
+#define CONFIG_FLAC_PARSER 1
+#define CONFIG_FTR_PARSER 0
+#define CONFIG_G723_1_PARSER 0
+#define CONFIG_G729_PARSER 0
+#define CONFIG_GIF_PARSER 0
+#define CONFIG_GSM_PARSER 0
+#define CONFIG_H261_PARSER 0
+#define CONFIG_H263_PARSER 0
+#define CONFIG_H264_PARSER 1
+#define CONFIG_HEVC_PARSER 0
+#define CONFIG_HDR_PARSER 0
+#define CONFIG_IPU_PARSER 0
+#define CONFIG_JPEG2000_PARSER 0
+#define CONFIG_MISC4_PARSER 0
+#define CONFIG_MJPEG_PARSER 0
+#define CONFIG_MLP_PARSER 0
+#define CONFIG_MPEG4VIDEO_PARSER 0
+#define CONFIG_MPEGAUDIO_PARSER 1
+#define CONFIG_MPEGVIDEO_PARSER 0
+#define CONFIG_OPUS_PARSER 1
+#define CONFIG_PNG_PARSER 0
+#define CONFIG_PNM_PARSER 0
+#define CONFIG_QOI_PARSER 0
+#define CONFIG_RV30_PARSER 0
+#define CONFIG_RV40_PARSER 0
+#define CONFIG_SBC_PARSER 0
+#define CONFIG_SIPR_PARSER 0
+#define CONFIG_TAK_PARSER 0
+#define CONFIG_VC1_PARSER 0
+#define CONFIG_VORBIS_PARSER 1
+#define CONFIG_VP3_PARSER 1
+#define CONFIG_VP8_PARSER 1
+#define CONFIG_VP9_PARSER 1
+#define CONFIG_WEBP_PARSER 0
+#define CONFIG_XBM_PARSER 0
+#define CONFIG_XMA_PARSER 0
+#define CONFIG_XWD_PARSER 0
+#define CONFIG_ALSA_INDEV 0
+#define CONFIG_ANDROID_CAMERA_INDEV 0
+#define CONFIG_AVFOUNDATION_INDEV 0
+#define CONFIG_BKTR_INDEV 0
+#define CONFIG_DECKLINK_INDEV 0
+#define CONFIG_DSHOW_INDEV 0
+#define CONFIG_FBDEV_INDEV 0
+#define CONFIG_GDIGRAB_INDEV 0
+#define CONFIG_IEC61883_INDEV 0
+#define CONFIG_JACK_INDEV 0
+#define CONFIG_KMSGRAB_INDEV 0
+#define CONFIG_LAVFI_INDEV 0
+#define CONFIG_OPENAL_INDEV 0
+#define CONFIG_OSS_INDEV 0
+#define CONFIG_PULSE_INDEV 0
+#define CONFIG_SNDIO_INDEV 0
+#define CONFIG_V4L2_INDEV 0
+#define CONFIG_VFWCAP_INDEV 0
+#define CONFIG_XCBGRAB_INDEV 0
+#define CONFIG_LIBCDIO_INDEV 0
+#define CONFIG_LIBDC1394_INDEV 0
+#define CONFIG_ALSA_OUTDEV 0
+#define CONFIG_AUDIOTOOLBOX_OUTDEV 0
+#define CONFIG_CACA_OUTDEV 0
+#define CONFIG_DECKLINK_OUTDEV 0
+#define CONFIG_FBDEV_OUTDEV 0
+#define CONFIG_OPENGL_OUTDEV 0
+#define CONFIG_OSS_OUTDEV 0
+#define CONFIG_PULSE_OUTDEV 0
+#define CONFIG_SDL2_OUTDEV 0
+#define CONFIG_SNDIO_OUTDEV 0
+#define CONFIG_V4L2_OUTDEV 0
+#define CONFIG_XV_OUTDEV 0
+#define CONFIG_ABENCH_FILTER 0
+#define CONFIG_ACOMPRESSOR_FILTER 0
+#define CONFIG_ACONTRAST_FILTER 0
+#define CONFIG_ACOPY_FILTER 0
+#define CONFIG_ACUE_FILTER 0
+#define CONFIG_ACROSSFADE_FILTER 0
+#define CONFIG_ACROSSOVER_FILTER 0
+#define CONFIG_ACRUSHER_FILTER 0
+#define CONFIG_ADECLICK_FILTER 0
+#define CONFIG_ADECLIP_FILTER 0
+#define CONFIG_ADECORRELATE_FILTER 0
+#define CONFIG_ADELAY_FILTER 0
+#define CONFIG_ADENORM_FILTER 0
+#define CONFIG_ADERIVATIVE_FILTER 0
+#define CONFIG_ADRC_FILTER 0
+#define CONFIG_ADYNAMICEQUALIZER_FILTER 0
+#define CONFIG_ADYNAMICSMOOTH_FILTER 0
+#define CONFIG_AECHO_FILTER 0
+#define CONFIG_AEMPHASIS_FILTER 0
+#define CONFIG_AEVAL_FILTER 0
+#define CONFIG_AEXCITER_FILTER 0
+#define CONFIG_AFADE_FILTER 0
+#define CONFIG_AFFTDN_FILTER 0
+#define CONFIG_AFFTFILT_FILTER 0
+#define CONFIG_AFIR_FILTER 0
+#define CONFIG_AFORMAT_FILTER 0
+#define CONFIG_AFREQSHIFT_FILTER 0
+#define CONFIG_AFWTDN_FILTER 0
+#define CONFIG_AGATE_FILTER 0
+#define CONFIG_AIIR_FILTER 0
+#define CONFIG_AINTEGRAL_FILTER 0
+#define CONFIG_AINTERLEAVE_FILTER 0
+#define CONFIG_ALATENCY_FILTER 0
+#define CONFIG_ALIMITER_FILTER 0
+#define CONFIG_ALLPASS_FILTER 0
+#define CONFIG_ALOOP_FILTER 0
+#define CONFIG_AMERGE_FILTER 0
+#define CONFIG_AMETADATA_FILTER 0
+#define CONFIG_AMIX_FILTER 0
+#define CONFIG_AMULTIPLY_FILTER 0
+#define CONFIG_ANEQUALIZER_FILTER 0
+#define CONFIG_ANLMDN_FILTER 0
+#define CONFIG_ANLMF_FILTER 0
+#define CONFIG_ANLMS_FILTER 0
+#define CONFIG_ANULL_FILTER 0
+#define CONFIG_APAD_FILTER 0
+#define CONFIG_APERMS_FILTER 0
+#define CONFIG_APHASER_FILTER 0
+#define CONFIG_APHASESHIFT_FILTER 0
+#define CONFIG_APSYCLIP_FILTER 0
+#define CONFIG_APULSATOR_FILTER 0
+#define CONFIG_AREALTIME_FILTER 0
+#define CONFIG_ARESAMPLE_FILTER 0
+#define CONFIG_AREVERSE_FILTER 0
+#define CONFIG_ARNNDN_FILTER 0
+#define CONFIG_ASDR_FILTER 0
+#define CONFIG_ASEGMENT_FILTER 0
+#define CONFIG_ASELECT_FILTER 0
+#define CONFIG_ASENDCMD_FILTER 0
+#define CONFIG_ASETNSAMPLES_FILTER 0
+#define CONFIG_ASETPTS_FILTER 0
+#define CONFIG_ASETRATE_FILTER 0
+#define CONFIG_ASETTB_FILTER 0
+#define CONFIG_ASHOWINFO_FILTER 0
+#define CONFIG_ASIDEDATA_FILTER 0
+#define CONFIG_ASOFTCLIP_FILTER 0
+#define CONFIG_ASPECTRALSTATS_FILTER 0
+#define CONFIG_ASPLIT_FILTER 0
+#define CONFIG_ASR_FILTER 0
+#define CONFIG_ASTATS_FILTER 0
+#define CONFIG_ASTREAMSELECT_FILTER 0
+#define CONFIG_ASUBBOOST_FILTER 0
+#define CONFIG_ASUBCUT_FILTER 0
+#define CONFIG_ASUPERCUT_FILTER 0
+#define CONFIG_ASUPERPASS_FILTER 0
+#define CONFIG_ASUPERSTOP_FILTER 0
+#define CONFIG_ATEMPO_FILTER 0
+#define CONFIG_ATILT_FILTER 0
+#define CONFIG_ATRIM_FILTER 0
+#define CONFIG_AXCORRELATE_FILTER 0
+#define CONFIG_AZMQ_FILTER 0
+#define CONFIG_BANDPASS_FILTER 0
+#define CONFIG_BANDREJECT_FILTER 0
+#define CONFIG_BASS_FILTER 0
+#define CONFIG_BIQUAD_FILTER 0
+#define CONFIG_BS2B_FILTER 0
+#define CONFIG_CHANNELMAP_FILTER 0
+#define CONFIG_CHANNELSPLIT_FILTER 0
+#define CONFIG_CHORUS_FILTER 0
+#define CONFIG_COMPAND_FILTER 0
+#define CONFIG_COMPENSATIONDELAY_FILTER 0
+#define CONFIG_CROSSFEED_FILTER 0
+#define CONFIG_CRYSTALIZER_FILTER 0
+#define CONFIG_DCSHIFT_FILTER 0
+#define CONFIG_DEESSER_FILTER 0
+#define CONFIG_DIALOGUENHANCE_FILTER 0
+#define CONFIG_DRMETER_FILTER 0
+#define CONFIG_DYNAUDNORM_FILTER 0
+#define CONFIG_EARWAX_FILTER 0
+#define CONFIG_EBUR128_FILTER 0
+#define CONFIG_EQUALIZER_FILTER 0
+#define CONFIG_EXTRASTEREO_FILTER 0
+#define CONFIG_FIREQUALIZER_FILTER 0
+#define CONFIG_FLANGER_FILTER 0
+#define CONFIG_HAAS_FILTER 0
+#define CONFIG_HDCD_FILTER 0
+#define CONFIG_HEADPHONE_FILTER 0
+#define CONFIG_HIGHPASS_FILTER 0
+#define CONFIG_HIGHSHELF_FILTER 0
+#define CONFIG_JOIN_FILTER 0
+#define CONFIG_LADSPA_FILTER 0
+#define CONFIG_LOUDNORM_FILTER 0
+#define CONFIG_LOWPASS_FILTER 0
+#define CONFIG_LOWSHELF_FILTER 0
+#define CONFIG_LV2_FILTER 0
+#define CONFIG_MCOMPAND_FILTER 0
+#define CONFIG_PAN_FILTER 0
+#define CONFIG_REPLAYGAIN_FILTER 0
+#define CONFIG_RUBBERBAND_FILTER 0
+#define CONFIG_SIDECHAINCOMPRESS_FILTER 0
+#define CONFIG_SIDECHAINGATE_FILTER 0
+#define CONFIG_SILENCEDETECT_FILTER 0
+#define CONFIG_SILENCEREMOVE_FILTER 0
+#define CONFIG_SOFALIZER_FILTER 0
+#define CONFIG_SPEECHNORM_FILTER 0
+#define CONFIG_STEREOTOOLS_FILTER 0
+#define CONFIG_STEREOWIDEN_FILTER 0
+#define CONFIG_SUPEREQUALIZER_FILTER 0
+#define CONFIG_SURROUND_FILTER 0
+#define CONFIG_TILTSHELF_FILTER 0
+#define CONFIG_TREBLE_FILTER 0
+#define CONFIG_TREMOLO_FILTER 0
+#define CONFIG_VIBRATO_FILTER 0
+#define CONFIG_VIRTUALBASS_FILTER 0
+#define CONFIG_VOLUME_FILTER 0
+#define CONFIG_VOLUMEDETECT_FILTER 0
+#define CONFIG_AEVALSRC_FILTER 0
+#define CONFIG_AFDELAYSRC_FILTER 0
+#define CONFIG_AFIRSRC_FILTER 0
+#define CONFIG_ANOISESRC_FILTER 0
+#define CONFIG_ANULLSRC_FILTER 0
+#define CONFIG_FLITE_FILTER 0
+#define CONFIG_HILBERT_FILTER 0
+#define CONFIG_SINC_FILTER 0
+#define CONFIG_SINE_FILTER 0
+#define CONFIG_ANULLSINK_FILTER 0
+#define CONFIG_ADDROI_FILTER 0
+#define CONFIG_ALPHAEXTRACT_FILTER 0
+#define CONFIG_ALPHAMERGE_FILTER 0
+#define CONFIG_AMPLIFY_FILTER 0
+#define CONFIG_ASS_FILTER 0
+#define CONFIG_ATADENOISE_FILTER 0
+#define CONFIG_AVGBLUR_FILTER 0
+#define CONFIG_AVGBLUR_OPENCL_FILTER 0
+#define CONFIG_AVGBLUR_VULKAN_FILTER 0
+#define CONFIG_BACKGROUNDKEY_FILTER 0
+#define CONFIG_BBOX_FILTER 0
+#define CONFIG_BENCH_FILTER 0
+#define CONFIG_BILATERAL_FILTER 0
+#define CONFIG_BILATERAL_CUDA_FILTER 0
+#define CONFIG_BITPLANENOISE_FILTER 0
+#define CONFIG_BLACKDETECT_FILTER 0
+#define CONFIG_BLACKFRAME_FILTER 0
+#define CONFIG_BLEND_FILTER 0
+#define CONFIG_BLEND_VULKAN_FILTER 0
+#define CONFIG_BLOCKDETECT_FILTER 0
+#define CONFIG_BLURDETECT_FILTER 0
+#define CONFIG_BM3D_FILTER 0
+#define CONFIG_BOXBLUR_FILTER 0
+#define CONFIG_BOXBLUR_OPENCL_FILTER 0
+#define CONFIG_BWDIF_FILTER 0
+#define CONFIG_CAS_FILTER 0
+#define CONFIG_CHROMABER_VULKAN_FILTER 0
+#define CONFIG_CHROMAHOLD_FILTER 0
+#define CONFIG_CHROMAKEY_FILTER 0
+#define CONFIG_CHROMAKEY_CUDA_FILTER 0
+#define CONFIG_CHROMANR_FILTER 0
+#define CONFIG_CHROMASHIFT_FILTER 0
+#define CONFIG_CIESCOPE_FILTER 0
+#define CONFIG_CODECVIEW_FILTER 0
+#define CONFIG_COLORBALANCE_FILTER 0
+#define CONFIG_COLORCHANNELMIXER_FILTER 0
+#define CONFIG_COLORCONTRAST_FILTER 0
+#define CONFIG_COLORCORRECT_FILTER 0
+#define CONFIG_COLORIZE_FILTER 0
+#define CONFIG_COLORKEY_FILTER 0
+#define CONFIG_COLORKEY_OPENCL_FILTER 0
+#define CONFIG_COLORHOLD_FILTER 0
+#define CONFIG_COLORLEVELS_FILTER 0
+#define CONFIG_COLORMAP_FILTER 0
+#define CONFIG_COLORMATRIX_FILTER 0
+#define CONFIG_COLORSPACE_FILTER 0
+#define CONFIG_COLORSPACE_CUDA_FILTER 0
+#define CONFIG_COLORTEMPERATURE_FILTER 0
+#define CONFIG_CONVOLUTION_FILTER 0
+#define CONFIG_CONVOLUTION_OPENCL_FILTER 0
+#define CONFIG_CONVOLVE_FILTER 0
+#define CONFIG_COPY_FILTER 0
+#define CONFIG_COREIMAGE_FILTER 0
+#define CONFIG_CORR_FILTER 0
+#define CONFIG_COVER_RECT_FILTER 0
+#define CONFIG_CROP_FILTER 0
+#define CONFIG_CROPDETECT_FILTER 0
+#define CONFIG_CUE_FILTER 0
+#define CONFIG_CURVES_FILTER 0
+#define CONFIG_DATASCOPE_FILTER 0
+#define CONFIG_DBLUR_FILTER 0
+#define CONFIG_DCTDNOIZ_FILTER 0
+#define CONFIG_DEBAND_FILTER 0
+#define CONFIG_DEBLOCK_FILTER 0
+#define CONFIG_DECIMATE_FILTER 0
+#define CONFIG_DECONVOLVE_FILTER 0
+#define CONFIG_DEDOT_FILTER 0
+#define CONFIG_DEFLATE_FILTER 0
+#define CONFIG_DEFLICKER_FILTER 0
+#define CONFIG_DEINTERLACE_QSV_FILTER 0
+#define CONFIG_DEINTERLACE_VAAPI_FILTER 0
+#define CONFIG_DEJUDDER_FILTER 0
+#define CONFIG_DELOGO_FILTER 0
+#define CONFIG_DENOISE_VAAPI_FILTER 0
+#define CONFIG_DERAIN_FILTER 0
+#define CONFIG_DESHAKE_FILTER 0
+#define CONFIG_DESHAKE_OPENCL_FILTER 0
+#define CONFIG_DESPILL_FILTER 0
+#define CONFIG_DETELECINE_FILTER 0
+#define CONFIG_DILATION_FILTER 0
+#define CONFIG_DILATION_OPENCL_FILTER 0
+#define CONFIG_DISPLACE_FILTER 0
+#define CONFIG_DNN_CLASSIFY_FILTER 0
+#define CONFIG_DNN_DETECT_FILTER 0
+#define CONFIG_DNN_PROCESSING_FILTER 0
+#define CONFIG_DOUBLEWEAVE_FILTER 0
+#define CONFIG_DRAWBOX_FILTER 0
+#define CONFIG_DRAWGRAPH_FILTER 0
+#define CONFIG_DRAWGRID_FILTER 0
+#define CONFIG_DRAWTEXT_FILTER 0
+#define CONFIG_EDGEDETECT_FILTER 0
+#define CONFIG_ELBG_FILTER 0
+#define CONFIG_ENTROPY_FILTER 0
+#define CONFIG_EPX_FILTER 0
+#define CONFIG_EQ_FILTER 0
+#define CONFIG_EROSION_FILTER 0
+#define CONFIG_EROSION_OPENCL_FILTER 0
+#define CONFIG_ESTDIF_FILTER 0
+#define CONFIG_EXPOSURE_FILTER 0
+#define CONFIG_EXTRACTPLANES_FILTER 0
+#define CONFIG_FADE_FILTER 0
+#define CONFIG_FEEDBACK_FILTER 0
+#define CONFIG_FFTDNOIZ_FILTER 0
+#define CONFIG_FFTFILT_FILTER 0
+#define CONFIG_FIELD_FILTER 0
+#define CONFIG_FIELDHINT_FILTER 0
+#define CONFIG_FIELDMATCH_FILTER 0
+#define CONFIG_FIELDORDER_FILTER 0
+#define CONFIG_FILLBORDERS_FILTER 0
+#define CONFIG_FIND_RECT_FILTER 0
+#define CONFIG_FLIP_VULKAN_FILTER 0
+#define CONFIG_FLOODFILL_FILTER 0
+#define CONFIG_FORMAT_FILTER 0
+#define CONFIG_FPS_FILTER 0
+#define CONFIG_FRAMEPACK_FILTER 0
+#define CONFIG_FRAMERATE_FILTER 0
+#define CONFIG_FRAMESTEP_FILTER 0
+#define CONFIG_FREEZEDETECT_FILTER 0
+#define CONFIG_FREEZEFRAMES_FILTER 0
+#define CONFIG_FREI0R_FILTER 0
+#define CONFIG_FSPP_FILTER 0
+#define CONFIG_GBLUR_FILTER 0
+#define CONFIG_GBLUR_VULKAN_FILTER 0
+#define CONFIG_GEQ_FILTER 0
+#define CONFIG_GRADFUN_FILTER 0
+#define CONFIG_GRAPHMONITOR_FILTER 0
+#define CONFIG_GRAYWORLD_FILTER 0
+#define CONFIG_GREYEDGE_FILTER 0
+#define CONFIG_GUIDED_FILTER 0
+#define CONFIG_HALDCLUT_FILTER 0
+#define CONFIG_HFLIP_FILTER 0
+#define CONFIG_HFLIP_VULKAN_FILTER 0
+#define CONFIG_HISTEQ_FILTER 0
+#define CONFIG_HISTOGRAM_FILTER 0
+#define CONFIG_HQDN3D_FILTER 0
+#define CONFIG_HQX_FILTER 0
+#define CONFIG_HSTACK_FILTER 0
+#define CONFIG_HSVHOLD_FILTER 0
+#define CONFIG_HSVKEY_FILTER 0
+#define CONFIG_HUE_FILTER 0
+#define CONFIG_HUESATURATION_FILTER 0
+#define CONFIG_HWDOWNLOAD_FILTER 0
+#define CONFIG_HWMAP_FILTER 0
+#define CONFIG_HWUPLOAD_FILTER 0
+#define CONFIG_HWUPLOAD_CUDA_FILTER 0
+#define CONFIG_HYSTERESIS_FILTER 0
+#define CONFIG_ICCDETECT_FILTER 0
+#define CONFIG_ICCGEN_FILTER 0
+#define CONFIG_IDENTITY_FILTER 0
+#define CONFIG_IDET_FILTER 0
+#define CONFIG_IL_FILTER 0
+#define CONFIG_INFLATE_FILTER 0
+#define CONFIG_INTERLACE_FILTER 0
+#define CONFIG_INTERLEAVE_FILTER 0
+#define CONFIG_KERNDEINT_FILTER 0
+#define CONFIG_KIRSCH_FILTER 0
+#define CONFIG_LAGFUN_FILTER 0
+#define CONFIG_LATENCY_FILTER 0
+#define CONFIG_LENSCORRECTION_FILTER 0
+#define CONFIG_LENSFUN_FILTER 0
+#define CONFIG_LIBPLACEBO_FILTER 0
+#define CONFIG_LIBVMAF_FILTER 0
+#define CONFIG_LIMITDIFF_FILTER 0
+#define CONFIG_LIMITER_FILTER 0
+#define CONFIG_LOOP_FILTER 0
+#define CONFIG_LUMAKEY_FILTER 0
+#define CONFIG_LUT_FILTER 0
+#define CONFIG_LUT1D_FILTER 0
+#define CONFIG_LUT2_FILTER 0
+#define CONFIG_LUT3D_FILTER 0
+#define CONFIG_LUTRGB_FILTER 0
+#define CONFIG_LUTYUV_FILTER 0
+#define CONFIG_MASKEDCLAMP_FILTER 0
+#define CONFIG_MASKEDMAX_FILTER 0
+#define CONFIG_MASKEDMERGE_FILTER 0
+#define CONFIG_MASKEDMIN_FILTER 0
+#define CONFIG_MASKEDTHRESHOLD_FILTER 0
+#define CONFIG_MASKFUN_FILTER 0
+#define CONFIG_MCDEINT_FILTER 0
+#define CONFIG_MEDIAN_FILTER 0
+#define CONFIG_MERGEPLANES_FILTER 0
+#define CONFIG_MESTIMATE_FILTER 0
+#define CONFIG_METADATA_FILTER 0
+#define CONFIG_MIDEQUALIZER_FILTER 0
+#define CONFIG_MINTERPOLATE_FILTER 0
+#define CONFIG_MIX_FILTER 0
+#define CONFIG_MONOCHROME_FILTER 0
+#define CONFIG_MORPHO_FILTER 0
+#define CONFIG_MPDECIMATE_FILTER 0
+#define CONFIG_MSAD_FILTER 0
+#define CONFIG_MULTIPLY_FILTER 0
+#define CONFIG_NEGATE_FILTER 0
+#define CONFIG_NLMEANS_FILTER 0
+#define CONFIG_NLMEANS_OPENCL_FILTER 0
+#define CONFIG_NNEDI_FILTER 0
+#define CONFIG_NOFORMAT_FILTER 0
+#define CONFIG_NOISE_FILTER 0
+#define CONFIG_NORMALIZE_FILTER 0
+#define CONFIG_NULL_FILTER 0
+#define CONFIG_OCR_FILTER 0
+#define CONFIG_OCV_FILTER 0
+#define CONFIG_OSCILLOSCOPE_FILTER 0
+#define CONFIG_OVERLAY_FILTER 0
+#define CONFIG_OVERLAY_OPENCL_FILTER 0
+#define CONFIG_OVERLAY_QSV_FILTER 0
+#define CONFIG_OVERLAY_VAAPI_FILTER 0
+#define CONFIG_OVERLAY_VULKAN_FILTER 0
+#define CONFIG_OVERLAY_CUDA_FILTER 0
+#define CONFIG_OWDENOISE_FILTER 0
+#define CONFIG_PAD_FILTER 0
+#define CONFIG_PAD_OPENCL_FILTER 0
+#define CONFIG_PALETTEGEN_FILTER 0
+#define CONFIG_PALETTEUSE_FILTER 0
+#define CONFIG_PERMS_FILTER 0
+#define CONFIG_PERSPECTIVE_FILTER 0
+#define CONFIG_PHASE_FILTER 0
+#define CONFIG_PHOTOSENSITIVITY_FILTER 0
+#define CONFIG_PIXDESCTEST_FILTER 0
+#define CONFIG_PIXELIZE_FILTER 0
+#define CONFIG_PIXSCOPE_FILTER 0
+#define CONFIG_PP_FILTER 0
+#define CONFIG_PP7_FILTER 0
+#define CONFIG_PREMULTIPLY_FILTER 0
+#define CONFIG_PREWITT_FILTER 0
+#define CONFIG_PREWITT_OPENCL_FILTER 0
+#define CONFIG_PROCAMP_VAAPI_FILTER 0
+#define CONFIG_PROGRAM_OPENCL_FILTER 0
+#define CONFIG_PSEUDOCOLOR_FILTER 0
+#define CONFIG_PSNR_FILTER 0
+#define CONFIG_PULLUP_FILTER 0
+#define CONFIG_QP_FILTER 0
+#define CONFIG_RANDOM_FILTER 0
+#define CONFIG_READEIA608_FILTER 0
+#define CONFIG_READVITC_FILTER 0
+#define CONFIG_REALTIME_FILTER 0
+#define CONFIG_REMAP_FILTER 0
+#define CONFIG_REMAP_OPENCL_FILTER 0
+#define CONFIG_REMOVEGRAIN_FILTER 0
+#define CONFIG_REMOVELOGO_FILTER 0
+#define CONFIG_REPEATFIELDS_FILTER 0
+#define CONFIG_REVERSE_FILTER 0
+#define CONFIG_RGBASHIFT_FILTER 0
+#define CONFIG_ROBERTS_FILTER 0
+#define CONFIG_ROBERTS_OPENCL_FILTER 0
+#define CONFIG_ROTATE_FILTER 0
+#define CONFIG_SAB_FILTER 0
+#define CONFIG_SCALE_FILTER 0
+#define CONFIG_SCALE_CUDA_FILTER 0
+#define CONFIG_SCALE_NPP_FILTER 0
+#define CONFIG_SCALE_QSV_FILTER 0
+#define CONFIG_SCALE_VAAPI_FILTER 0
+#define CONFIG_SCALE_VULKAN_FILTER 0
+#define CONFIG_SCALE2REF_FILTER 0
+#define CONFIG_SCALE2REF_NPP_FILTER 0
+#define CONFIG_SCDET_FILTER 0
+#define CONFIG_SCHARR_FILTER 0
+#define CONFIG_SCROLL_FILTER 0
+#define CONFIG_SEGMENT_FILTER 0
+#define CONFIG_SELECT_FILTER 0
+#define CONFIG_SELECTIVECOLOR_FILTER 0
+#define CONFIG_SENDCMD_FILTER 0
+#define CONFIG_SEPARATEFIELDS_FILTER 0
+#define CONFIG_SETDAR_FILTER 0
+#define CONFIG_SETFIELD_FILTER 0
+#define CONFIG_SETPARAMS_FILTER 0
+#define CONFIG_SETPTS_FILTER 0
+#define CONFIG_SETRANGE_FILTER 0
+#define CONFIG_SETSAR_FILTER 0
+#define CONFIG_SETTB_FILTER 0
+#define CONFIG_SHARPEN_NPP_FILTER 0
+#define CONFIG_SHARPNESS_VAAPI_FILTER 0
+#define CONFIG_SHEAR_FILTER 0
+#define CONFIG_SHOWINFO_FILTER 0
+#define CONFIG_SHOWPALETTE_FILTER 0
+#define CONFIG_SHUFFLEFRAMES_FILTER 0
+#define CONFIG_SHUFFLEPIXELS_FILTER 0
+#define CONFIG_SHUFFLEPLANES_FILTER 0
+#define CONFIG_SIDEDATA_FILTER 0
+#define CONFIG_SIGNALSTATS_FILTER 0
+#define CONFIG_SIGNATURE_FILTER 0
+#define CONFIG_SITI_FILTER 0
+#define CONFIG_SMARTBLUR_FILTER 0
+#define CONFIG_SOBEL_FILTER 0
+#define CONFIG_SOBEL_OPENCL_FILTER 0
+#define CONFIG_SPLIT_FILTER 0
+#define CONFIG_SPP_FILTER 0
+#define CONFIG_SR_FILTER 0
+#define CONFIG_SSIM_FILTER 0
+#define CONFIG_SSIM360_FILTER 0
+#define CONFIG_STEREO3D_FILTER 0
+#define CONFIG_STREAMSELECT_FILTER 0
+#define CONFIG_SUBTITLES_FILTER 0
+#define CONFIG_SUPER2XSAI_FILTER 0
+#define CONFIG_SWAPRECT_FILTER 0
+#define CONFIG_SWAPUV_FILTER 0
+#define CONFIG_TBLEND_FILTER 0
+#define CONFIG_TELECINE_FILTER 0
+#define CONFIG_THISTOGRAM_FILTER 0
+#define CONFIG_THRESHOLD_FILTER 0
+#define CONFIG_THUMBNAIL_FILTER 0
+#define CONFIG_THUMBNAIL_CUDA_FILTER 0
+#define CONFIG_TILE_FILTER 0
+#define CONFIG_TINTERLACE_FILTER 0
+#define CONFIG_TLUT2_FILTER 0
+#define CONFIG_TMEDIAN_FILTER 0
+#define CONFIG_TMIDEQUALIZER_FILTER 0
+#define CONFIG_TMIX_FILTER 0
+#define CONFIG_TONEMAP_FILTER 0
+#define CONFIG_TONEMAP_OPENCL_FILTER 0
+#define CONFIG_TONEMAP_VAAPI_FILTER 0
+#define CONFIG_TPAD_FILTER 0
+#define CONFIG_TRANSPOSE_FILTER 0
+#define CONFIG_TRANSPOSE_NPP_FILTER 0
+#define CONFIG_TRANSPOSE_OPENCL_FILTER 0
+#define CONFIG_TRANSPOSE_VAAPI_FILTER 0
+#define CONFIG_TRANSPOSE_VULKAN_FILTER 0
+#define CONFIG_TRIM_FILTER 0
+#define CONFIG_UNPREMULTIPLY_FILTER 0
+#define CONFIG_UNSHARP_FILTER 0
+#define CONFIG_UNSHARP_OPENCL_FILTER 0
+#define CONFIG_UNTILE_FILTER 0
+#define CONFIG_USPP_FILTER 0
+#define CONFIG_V360_FILTER 0
+#define CONFIG_VAGUEDENOISER_FILTER 0
+#define CONFIG_VARBLUR_FILTER 0
+#define CONFIG_VECTORSCOPE_FILTER 0
+#define CONFIG_VFLIP_FILTER 0
+#define CONFIG_VFLIP_VULKAN_FILTER 0
+#define CONFIG_VFRDET_FILTER 0
+#define CONFIG_VIBRANCE_FILTER 0
+#define CONFIG_VIDSTABDETECT_FILTER 0
+#define CONFIG_VIDSTABTRANSFORM_FILTER 0
+#define CONFIG_VIF_FILTER 0
+#define CONFIG_VIGNETTE_FILTER 0
+#define CONFIG_VMAFMOTION_FILTER 0
+#define CONFIG_VPP_QSV_FILTER 0
+#define CONFIG_VSTACK_FILTER 0
+#define CONFIG_W3FDIF_FILTER 0
+#define CONFIG_WAVEFORM_FILTER 0
+#define CONFIG_WEAVE_FILTER 0
+#define CONFIG_XBR_FILTER 0
+#define CONFIG_XCORRELATE_FILTER 0
+#define CONFIG_XFADE_FILTER 0
+#define CONFIG_XFADE_OPENCL_FILTER 0
+#define CONFIG_XMEDIAN_FILTER 0
+#define CONFIG_XSTACK_FILTER 0
+#define CONFIG_YADIF_FILTER 0
+#define CONFIG_YADIF_CUDA_FILTER 0
+#define CONFIG_YADIF_VIDEOTOOLBOX_FILTER 0
+#define CONFIG_YAEPBLUR_FILTER 0
+#define CONFIG_ZMQ_FILTER 0
+#define CONFIG_ZOOMPAN_FILTER 0
+#define CONFIG_ZSCALE_FILTER 0
+#define CONFIG_HSTACK_VAAPI_FILTER 0
+#define CONFIG_VSTACK_VAAPI_FILTER 0
+#define CONFIG_XSTACK_VAAPI_FILTER 0
+#define CONFIG_HSTACK_QSV_FILTER 0
+#define CONFIG_VSTACK_QSV_FILTER 0
+#define CONFIG_XSTACK_QSV_FILTER 0
+#define CONFIG_ALLRGB_FILTER 0
+#define CONFIG_ALLYUV_FILTER 0
+#define CONFIG_CELLAUTO_FILTER 0
+#define CONFIG_COLOR_FILTER 0
+#define CONFIG_COLORCHART_FILTER 0
+#define CONFIG_COLORSPECTRUM_FILTER 0
+#define CONFIG_COREIMAGESRC_FILTER 0
+#define CONFIG_DDAGRAB_FILTER 0
+#define CONFIG_FREI0R_SRC_FILTER 0
+#define CONFIG_GRADIENTS_FILTER 0
+#define CONFIG_HALDCLUTSRC_FILTER 0
+#define CONFIG_LIFE_FILTER 0
+#define CONFIG_MANDELBROT_FILTER 0
+#define CONFIG_MPTESTSRC_FILTER 0
+#define CONFIG_NULLSRC_FILTER 0
+#define CONFIG_OPENCLSRC_FILTER 0
+#define CONFIG_PAL75BARS_FILTER 0
+#define CONFIG_PAL100BARS_FILTER 0
+#define CONFIG_RGBTESTSRC_FILTER 0
+#define CONFIG_SIERPINSKI_FILTER 0
+#define CONFIG_SMPTEBARS_FILTER 0
+#define CONFIG_SMPTEHDBARS_FILTER 0
+#define CONFIG_TESTSRC_FILTER 0
+#define CONFIG_TESTSRC2_FILTER 0
+#define CONFIG_YUVTESTSRC_FILTER 0
+#define CONFIG_NULLSINK_FILTER 0
+#define CONFIG_A3DSCOPE_FILTER 0
+#define CONFIG_ABITSCOPE_FILTER 0
+#define CONFIG_ADRAWGRAPH_FILTER 0
+#define CONFIG_AGRAPHMONITOR_FILTER 0
+#define CONFIG_AHISTOGRAM_FILTER 0
+#define CONFIG_APHASEMETER_FILTER 0
+#define CONFIG_AVECTORSCOPE_FILTER 0
+#define CONFIG_CONCAT_FILTER 0
+#define CONFIG_SHOWCQT_FILTER 0
+#define CONFIG_SHOWCWT_FILTER 0
+#define CONFIG_SHOWFREQS_FILTER 0
+#define CONFIG_SHOWSPATIAL_FILTER 0
+#define CONFIG_SHOWSPECTRUM_FILTER 0
+#define CONFIG_SHOWSPECTRUMPIC_FILTER 0
+#define CONFIG_SHOWVOLUME_FILTER 0
+#define CONFIG_SHOWWAVES_FILTER 0
+#define CONFIG_SHOWWAVESPIC_FILTER 0
+#define CONFIG_SPECTRUMSYNTH_FILTER 0
+#define CONFIG_AVSYNCTEST_FILTER 0
+#define CONFIG_AMOVIE_FILTER 0
+#define CONFIG_MOVIE_FILTER 0
+#define CONFIG_AFIFO_FILTER 0
+#define CONFIG_FIFO_FILTER 0
+#define CONFIG_AA_DEMUXER 0
+#define CONFIG_AAC_DEMUXER 1
+#define CONFIG_AAX_DEMUXER 0
+#define CONFIG_AC3_DEMUXER 0
+#define CONFIG_ACE_DEMUXER 0
+#define CONFIG_ACM_DEMUXER 0
+#define CONFIG_ACT_DEMUXER 0
+#define CONFIG_ADF_DEMUXER 0
+#define CONFIG_ADP_DEMUXER 0
+#define CONFIG_ADS_DEMUXER 0
+#define CONFIG_ADX_DEMUXER 0
+#define CONFIG_AEA_DEMUXER 0
+#define CONFIG_AFC_DEMUXER 0
+#define CONFIG_AIFF_DEMUXER 0
+#define CONFIG_AIX_DEMUXER 0
+#define CONFIG_ALP_DEMUXER 0
+#define CONFIG_AMR_DEMUXER 0
+#define CONFIG_AMRNB_DEMUXER 0
+#define CONFIG_AMRWB_DEMUXER 0
+#define CONFIG_ANM_DEMUXER 0
+#define CONFIG_APAC_DEMUXER 0
+#define CONFIG_APC_DEMUXER 0
+#define CONFIG_APE_DEMUXER 0
+#define CONFIG_APM_DEMUXER 0
+#define CONFIG_APNG_DEMUXER 0
+#define CONFIG_APTX_DEMUXER 0
+#define CONFIG_APTX_HD_DEMUXER 0
+#define CONFIG_AQTITLE_DEMUXER 0
+#define CONFIG_ARGO_ASF_DEMUXER 0
+#define CONFIG_ARGO_BRP_DEMUXER 0
+#define CONFIG_ARGO_CVG_DEMUXER 0
+#define CONFIG_ASF_DEMUXER 0
+#define CONFIG_ASF_O_DEMUXER 0
+#define CONFIG_ASS_DEMUXER 0
+#define CONFIG_AST_DEMUXER 0
+#define CONFIG_AU_DEMUXER 0
+#define CONFIG_AV1_DEMUXER 0
+#define CONFIG_AVI_DEMUXER 0
+#define CONFIG_AVISYNTH_DEMUXER 0
+#define CONFIG_AVR_DEMUXER 0
+#define CONFIG_AVS_DEMUXER 0
+#define CONFIG_AVS2_DEMUXER 0
+#define CONFIG_AVS3_DEMUXER 0
+#define CONFIG_BETHSOFTVID_DEMUXER 0
+#define CONFIG_BFI_DEMUXER 0
+#define CONFIG_BINTEXT_DEMUXER 0
+#define CONFIG_BINK_DEMUXER 0
+#define CONFIG_BINKA_DEMUXER 0
+#define CONFIG_BIT_DEMUXER 0
+#define CONFIG_BITPACKED_DEMUXER 0
+#define CONFIG_BMV_DEMUXER 0
+#define CONFIG_BFSTM_DEMUXER 0
+#define CONFIG_BRSTM_DEMUXER 0
+#define CONFIG_BOA_DEMUXER 0
+#define CONFIG_BONK_DEMUXER 0
+#define CONFIG_C93_DEMUXER 0
+#define CONFIG_CAF_DEMUXER 0
+#define CONFIG_CAVSVIDEO_DEMUXER 0
+#define CONFIG_CDG_DEMUXER 0
+#define CONFIG_CDXL_DEMUXER 0
+#define CONFIG_CINE_DEMUXER 0
+#define CONFIG_CODEC2_DEMUXER 0
+#define CONFIG_CODEC2RAW_DEMUXER 0
+#define CONFIG_CONCAT_DEMUXER 0
+#define CONFIG_DASH_DEMUXER 0
+#define CONFIG_DATA_DEMUXER 0
+#define CONFIG_DAUD_DEMUXER 0
+#define CONFIG_DCSTR_DEMUXER 0
+#define CONFIG_DERF_DEMUXER 0
+#define CONFIG_DFA_DEMUXER 0
+#define CONFIG_DFPWM_DEMUXER 0
+#define CONFIG_DHAV_DEMUXER 0
+#define CONFIG_DIRAC_DEMUXER 0
+#define CONFIG_DNXHD_DEMUXER 0
+#define CONFIG_DSF_DEMUXER 0
+#define CONFIG_DSICIN_DEMUXER 0
+#define CONFIG_DSS_DEMUXER 0
+#define CONFIG_DTS_DEMUXER 0
+#define CONFIG_DTSHD_DEMUXER 0
+#define CONFIG_DV_DEMUXER 0
+#define CONFIG_DVBSUB_DEMUXER 0
+#define CONFIG_DVBTXT_DEMUXER 0
+#define CONFIG_DXA_DEMUXER 0
+#define CONFIG_EA_DEMUXER 0
+#define CONFIG_EA_CDATA_DEMUXER 0
+#define CONFIG_EAC3_DEMUXER 0
+#define CONFIG_EPAF_DEMUXER 0
+#define CONFIG_FFMETADATA_DEMUXER 0
+#define CONFIG_FILMSTRIP_DEMUXER 0
+#define CONFIG_FITS_DEMUXER 0
+#define CONFIG_FLAC_DEMUXER 1
+#define CONFIG_FLIC_DEMUXER 0
+#define CONFIG_FLV_DEMUXER 0
+#define CONFIG_LIVE_FLV_DEMUXER 0
+#define CONFIG_FOURXM_DEMUXER 0
+#define CONFIG_FRM_DEMUXER 0
+#define CONFIG_FSB_DEMUXER 0
+#define CONFIG_FWSE_DEMUXER 0
+#define CONFIG_G722_DEMUXER 0
+#define CONFIG_G723_1_DEMUXER 0
+#define CONFIG_G726_DEMUXER 0
+#define CONFIG_G726LE_DEMUXER 0
+#define CONFIG_G729_DEMUXER 0
+#define CONFIG_GDV_DEMUXER 0
+#define CONFIG_GENH_DEMUXER 0
+#define CONFIG_GIF_DEMUXER 0
+#define CONFIG_GSM_DEMUXER 0
+#define CONFIG_GXF_DEMUXER 0
+#define CONFIG_H261_DEMUXER 0
+#define CONFIG_H263_DEMUXER 0
+#define CONFIG_H264_DEMUXER 0
+#define CONFIG_HCA_DEMUXER 0
+#define CONFIG_HCOM_DEMUXER 0
+#define CONFIG_HEVC_DEMUXER 0
+#define CONFIG_HLS_DEMUXER 0
+#define CONFIG_HNM_DEMUXER 0
+#define CONFIG_ICO_DEMUXER 0
+#define CONFIG_IDCIN_DEMUXER 0
+#define CONFIG_IDF_DEMUXER 0
+#define CONFIG_IFF_DEMUXER 0
+#define CONFIG_IFV_DEMUXER 0
+#define CONFIG_ILBC_DEMUXER 0
+#define CONFIG_IMAGE2_DEMUXER 0
+#define CONFIG_IMAGE2PIPE_DEMUXER 0
+#define CONFIG_IMAGE2_ALIAS_PIX_DEMUXER 0
+#define CONFIG_IMAGE2_BRENDER_PIX_DEMUXER 0
+#define CONFIG_IMF_DEMUXER 0
+#define CONFIG_INGENIENT_DEMUXER 0
+#define CONFIG_IPMOVIE_DEMUXER 0
+#define CONFIG_IPU_DEMUXER 0
+#define CONFIG_IRCAM_DEMUXER 0
+#define CONFIG_ISS_DEMUXER 0
+#define CONFIG_IV8_DEMUXER 0
+#define CONFIG_IVF_DEMUXER 0
+#define CONFIG_IVR_DEMUXER 0
+#define CONFIG_JACOSUB_DEMUXER 0
+#define CONFIG_JV_DEMUXER 0
+#define CONFIG_KUX_DEMUXER 0
+#define CONFIG_KVAG_DEMUXER 0
+#define CONFIG_LAF_DEMUXER 0
+#define CONFIG_LMLM4_DEMUXER 0
+#define CONFIG_LOAS_DEMUXER 0
+#define CONFIG_LUODAT_DEMUXER 0
+#define CONFIG_LRC_DEMUXER 0
+#define CONFIG_LVF_DEMUXER 0
+#define CONFIG_LXF_DEMUXER 0
+#define CONFIG_M4V_DEMUXER 0
+#define CONFIG_MCA_DEMUXER 0
+#define CONFIG_MCC_DEMUXER 0
+#define CONFIG_MATROSKA_DEMUXER 1
+#define CONFIG_MGSTS_DEMUXER 0
+#define CONFIG_MICRODVD_DEMUXER 0
+#define CONFIG_MJPEG_DEMUXER 0
+#define CONFIG_MJPEG_2000_DEMUXER 0
+#define CONFIG_MLP_DEMUXER 0
+#define CONFIG_MLV_DEMUXER 0
+#define CONFIG_MM_DEMUXER 0
+#define CONFIG_MMF_DEMUXER 0
+#define CONFIG_MODS_DEMUXER 0
+#define CONFIG_MOFLEX_DEMUXER 0
+#define CONFIG_MOV_DEMUXER 1
+#define CONFIG_MP3_DEMUXER 1
+#define CONFIG_MPC_DEMUXER 0
+#define CONFIG_MPC8_DEMUXER 0
+#define CONFIG_MPEGPS_DEMUXER 0
+#define CONFIG_MPEGTS_DEMUXER 0
+#define CONFIG_MPEGTSRAW_DEMUXER 0
+#define CONFIG_MPEGVIDEO_DEMUXER 0
+#define CONFIG_MPJPEG_DEMUXER 0
+#define CONFIG_MPL2_DEMUXER 0
+#define CONFIG_MPSUB_DEMUXER 0
+#define CONFIG_MSF_DEMUXER 0
+#define CONFIG_MSNWC_TCP_DEMUXER 0
+#define CONFIG_MSP_DEMUXER 0
+#define CONFIG_MTAF_DEMUXER 0
+#define CONFIG_MTV_DEMUXER 0
+#define CONFIG_MUSX_DEMUXER 0
+#define CONFIG_MV_DEMUXER 0
+#define CONFIG_MVI_DEMUXER 0
+#define CONFIG_MXF_DEMUXER 0
+#define CONFIG_MXG_DEMUXER 0
+#define CONFIG_NC_DEMUXER 0
+#define CONFIG_NISTSPHERE_DEMUXER 0
+#define CONFIG_NSP_DEMUXER 0
+#define CONFIG_NSV_DEMUXER 0
+#define CONFIG_NUT_DEMUXER 0
+#define CONFIG_NUV_DEMUXER 0
+#define CONFIG_OBU_DEMUXER 0
+#define CONFIG_OGG_DEMUXER 1
+#define CONFIG_OMA_DEMUXER 0
+#define CONFIG_PAF_DEMUXER 0
+#define CONFIG_PCM_ALAW_DEMUXER 0
+#define CONFIG_PCM_MULAW_DEMUXER 0
+#define CONFIG_PCM_VIDC_DEMUXER 0
+#define CONFIG_PCM_F64BE_DEMUXER 0
+#define CONFIG_PCM_F64LE_DEMUXER 0
+#define CONFIG_PCM_F32BE_DEMUXER 0
+#define CONFIG_PCM_F32LE_DEMUXER 0
+#define CONFIG_PCM_S32BE_DEMUXER 0
+#define CONFIG_PCM_S32LE_DEMUXER 0
+#define CONFIG_PCM_S24BE_DEMUXER 0
+#define CONFIG_PCM_S24LE_DEMUXER 0
+#define CONFIG_PCM_S16BE_DEMUXER 0
+#define CONFIG_PCM_S16LE_DEMUXER 0
+#define CONFIG_PCM_S8_DEMUXER 0
+#define CONFIG_PCM_U32BE_DEMUXER 0
+#define CONFIG_PCM_U32LE_DEMUXER 0
+#define CONFIG_PCM_U24BE_DEMUXER 0
+#define CONFIG_PCM_U24LE_DEMUXER 0
+#define CONFIG_PCM_U16BE_DEMUXER 0
+#define CONFIG_PCM_U16LE_DEMUXER 0
+#define CONFIG_PCM_U8_DEMUXER 0
+#define CONFIG_PJS_DEMUXER 0
+#define CONFIG_PMP_DEMUXER 0
+#define CONFIG_PP_BNK_DEMUXER 0
+#define CONFIG_PVA_DEMUXER 0
+#define CONFIG_PVF_DEMUXER 0
+#define CONFIG_QCP_DEMUXER 0
+#define CONFIG_R3D_DEMUXER 0
+#define CONFIG_RAWVIDEO_DEMUXER 0
+#define CONFIG_REALTEXT_DEMUXER 0
+#define CONFIG_REDSPARK_DEMUXER 0
+#define CONFIG_RKA_DEMUXER 0
+#define CONFIG_RL2_DEMUXER 0
+#define CONFIG_RM_DEMUXER 0
+#define CONFIG_ROQ_DEMUXER 0
+#define CONFIG_RPL_DEMUXER 0
+#define CONFIG_RSD_DEMUXER 0
+#define CONFIG_RSO_DEMUXER 0
+#define CONFIG_RTP_DEMUXER 0
+#define CONFIG_RTSP_DEMUXER 0
+#define CONFIG_S337M_DEMUXER 0
+#define CONFIG_SAMI_DEMUXER 0
+#define CONFIG_SAP_DEMUXER 0
+#define CONFIG_SBC_DEMUXER 0
+#define CONFIG_SBG_DEMUXER 0
+#define CONFIG_SCC_DEMUXER 0
+#define CONFIG_SCD_DEMUXER 0
+#define CONFIG_SDNS_DEMUXER 0
+#define CONFIG_SDP_DEMUXER 0
+#define CONFIG_SDR2_DEMUXER 0
+#define CONFIG_SDS_DEMUXER 0
+#define CONFIG_SDX_DEMUXER 0
+#define CONFIG_SEGAFILM_DEMUXER 0
+#define CONFIG_SER_DEMUXER 0
+#define CONFIG_SGA_DEMUXER 0
+#define CONFIG_SHORTEN_DEMUXER 0
+#define CONFIG_SIFF_DEMUXER 0
+#define CONFIG_SIMBIOSIS_IMX_DEMUXER 0
+#define CONFIG_SLN_DEMUXER 0
+#define CONFIG_SMACKER_DEMUXER 0
+#define CONFIG_SMJPEG_DEMUXER 0
+#define CONFIG_SMUSH_DEMUXER 0
+#define CONFIG_SOL_DEMUXER 0
+#define CONFIG_SOX_DEMUXER 0
+#define CONFIG_SPDIF_DEMUXER 0
+#define CONFIG_SRT_DEMUXER 0
+#define CONFIG_STR_DEMUXER 0
+#define CONFIG_STL_DEMUXER 0
+#define CONFIG_SUBVIEWER1_DEMUXER 0
+#define CONFIG_SUBVIEWER_DEMUXER 0
+#define CONFIG_SUP_DEMUXER 0
+#define CONFIG_SVAG_DEMUXER 0
+#define CONFIG_SVS_DEMUXER 0
+#define CONFIG_SWF_DEMUXER 0
+#define CONFIG_TAK_DEMUXER 0
+#define CONFIG_TEDCAPTIONS_DEMUXER 0
+#define CONFIG_THP_DEMUXER 0
+#define CONFIG_THREEDOSTR_DEMUXER 0
+#define CONFIG_TIERTEXSEQ_DEMUXER 0
+#define CONFIG_TMV_DEMUXER 0
+#define CONFIG_TRUEHD_DEMUXER 0
+#define CONFIG_TTA_DEMUXER 0
+#define CONFIG_TXD_DEMUXER 0
+#define CONFIG_TTY_DEMUXER 0
+#define CONFIG_TY_DEMUXER 0
+#define CONFIG_V210_DEMUXER 0
+#define CONFIG_V210X_DEMUXER 0
+#define CONFIG_VAG_DEMUXER 0
+#define CONFIG_VC1_DEMUXER 0
+#define CONFIG_VC1T_DEMUXER 0
+#define CONFIG_VIVIDAS_DEMUXER 0
+#define CONFIG_VIVO_DEMUXER 0
+#define CONFIG_VMD_DEMUXER 0
+#define CONFIG_VOBSUB_DEMUXER 0
+#define CONFIG_VOC_DEMUXER 0
+#define CONFIG_VPK_DEMUXER 0
+#define CONFIG_VPLAYER_DEMUXER 0
+#define CONFIG_VQF_DEMUXER 0
+#define CONFIG_W64_DEMUXER 0
+#define CONFIG_WADY_DEMUXER 0
+#define CONFIG_WAVARC_DEMUXER 0
+#define CONFIG_WAV_DEMUXER 1
+#define CONFIG_WC3_DEMUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_DEMUXER 0
+#define CONFIG_WEBVTT_DEMUXER 0
+#define CONFIG_WSAUD_DEMUXER 0
+#define CONFIG_WSD_DEMUXER 0
+#define CONFIG_WSVQA_DEMUXER 0
+#define CONFIG_WTV_DEMUXER 0
+#define CONFIG_WVE_DEMUXER 0
+#define CONFIG_WV_DEMUXER 0
+#define CONFIG_XA_DEMUXER 0
+#define CONFIG_XBIN_DEMUXER 0
+#define CONFIG_XMD_DEMUXER 0
+#define CONFIG_XMV_DEMUXER 0
+#define CONFIG_XVAG_DEMUXER 0
+#define CONFIG_XWMA_DEMUXER 0
+#define CONFIG_YOP_DEMUXER 0
+#define CONFIG_YUV4MPEGPIPE_DEMUXER 0
+#define CONFIG_IMAGE_BMP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_CRI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DDS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_DPX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_EXR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_GEM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_GIF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_HDR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_J2K_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEGLS_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_JPEGXL_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PAM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PBM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PCX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PFM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGMYUV_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PGX_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PHM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PHOTOCD_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PICTOR_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PNG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_PSD_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_QDRAW_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_QOI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SGI_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SVG_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_SUNRAST_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_TIFF_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_VBN_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_WEBP_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XBM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XPM_PIPE_DEMUXER 0
+#define CONFIG_IMAGE_XWD_PIPE_DEMUXER 0
+#define CONFIG_LIBGME_DEMUXER 0
+#define CONFIG_LIBMODPLUG_DEMUXER 0
+#define CONFIG_LIBOPENMPT_DEMUXER 0
+#define CONFIG_VAPOURSYNTH_DEMUXER 0
+#define CONFIG_A64_MUXER 0
+#define CONFIG_AC3_MUXER 0
+#define CONFIG_ADTS_MUXER 0
+#define CONFIG_ADX_MUXER 0
+#define CONFIG_AIFF_MUXER 0
+#define CONFIG_ALP_MUXER 0
+#define CONFIG_AMR_MUXER 0
+#define CONFIG_AMV_MUXER 0
+#define CONFIG_APM_MUXER 0
+#define CONFIG_APNG_MUXER 0
+#define CONFIG_APTX_MUXER 0
+#define CONFIG_APTX_HD_MUXER 0
+#define CONFIG_ARGO_ASF_MUXER 0
+#define CONFIG_ARGO_CVG_MUXER 0
+#define CONFIG_ASF_MUXER 0
+#define CONFIG_ASS_MUXER 0
+#define CONFIG_AST_MUXER 0
+#define CONFIG_ASF_STREAM_MUXER 0
+#define CONFIG_AU_MUXER 0
+#define CONFIG_AVI_MUXER 0
+#define CONFIG_AVIF_MUXER 0
+#define CONFIG_AVM2_MUXER 0
+#define CONFIG_AVS2_MUXER 0
+#define CONFIG_AVS3_MUXER 0
+#define CONFIG_BIT_MUXER 0
+#define CONFIG_CAF_MUXER 0
+#define CONFIG_CAVSVIDEO_MUXER 0
+#define CONFIG_CODEC2_MUXER 0
+#define CONFIG_CODEC2RAW_MUXER 0
+#define CONFIG_CRC_MUXER 0
+#define CONFIG_DASH_MUXER 0
+#define CONFIG_DATA_MUXER 0
+#define CONFIG_DAUD_MUXER 0
+#define CONFIG_DFPWM_MUXER 0
+#define CONFIG_DIRAC_MUXER 0
+#define CONFIG_DNXHD_MUXER 0
+#define CONFIG_DTS_MUXER 0
+#define CONFIG_DV_MUXER 0
+#define CONFIG_EAC3_MUXER 0
+#define CONFIG_F4V_MUXER 0
+#define CONFIG_FFMETADATA_MUXER 0
+#define CONFIG_FIFO_MUXER 0
+#define CONFIG_FIFO_TEST_MUXER 0
+#define CONFIG_FILMSTRIP_MUXER 0
+#define CONFIG_FITS_MUXER 0
+#define CONFIG_FLAC_MUXER 0
+#define CONFIG_FLV_MUXER 0
+#define CONFIG_FRAMECRC_MUXER 0
+#define CONFIG_FRAMEHASH_MUXER 0
+#define CONFIG_FRAMEMD5_MUXER 0
+#define CONFIG_G722_MUXER 0
+#define CONFIG_G723_1_MUXER 0
+#define CONFIG_G726_MUXER 0
+#define CONFIG_G726LE_MUXER 0
+#define CONFIG_GIF_MUXER 0
+#define CONFIG_GSM_MUXER 0
+#define CONFIG_GXF_MUXER 0
+#define CONFIG_H261_MUXER 0
+#define CONFIG_H263_MUXER 0
+#define CONFIG_H264_MUXER 0
+#define CONFIG_HASH_MUXER 0
+#define CONFIG_HDS_MUXER 0
+#define CONFIG_HEVC_MUXER 0
+#define CONFIG_HLS_MUXER 0
+#define CONFIG_ICO_MUXER 0
+#define CONFIG_ILBC_MUXER 0
+#define CONFIG_IMAGE2_MUXER 0
+#define CONFIG_IMAGE2PIPE_MUXER 0
+#define CONFIG_IPOD_MUXER 0
+#define CONFIG_IRCAM_MUXER 0
+#define CONFIG_ISMV_MUXER 0
+#define CONFIG_IVF_MUXER 0
+#define CONFIG_JACOSUB_MUXER 0
+#define CONFIG_KVAG_MUXER 0
+#define CONFIG_LATM_MUXER 0
+#define CONFIG_LRC_MUXER 0
+#define CONFIG_M4V_MUXER 0
+#define CONFIG_MD5_MUXER 0
+#define CONFIG_MATROSKA_MUXER 0
+#define CONFIG_MATROSKA_AUDIO_MUXER 0
+#define CONFIG_MICRODVD_MUXER 0
+#define CONFIG_MJPEG_MUXER 0
+#define CONFIG_MLP_MUXER 0
+#define CONFIG_MMF_MUXER 0
+#define CONFIG_MOV_MUXER 0
+#define CONFIG_MP2_MUXER 0
+#define CONFIG_MP3_MUXER 0
+#define CONFIG_MP4_MUXER 0
+#define CONFIG_MPEG1SYSTEM_MUXER 0
+#define CONFIG_MPEG1VCD_MUXER 0
+#define CONFIG_MPEG1VIDEO_MUXER 0
+#define CONFIG_MPEG2DVD_MUXER 0
+#define CONFIG_MPEG2SVCD_MUXER 0
+#define CONFIG_MPEG2VIDEO_MUXER 0
+#define CONFIG_MPEG2VOB_MUXER 0
+#define CONFIG_MPEGTS_MUXER 0
+#define CONFIG_MPJPEG_MUXER 0
+#define CONFIG_MXF_MUXER 0
+#define CONFIG_MXF_D10_MUXER 0
+#define CONFIG_MXF_OPATOM_MUXER 0
+#define CONFIG_NULL_MUXER 0
+#define CONFIG_NUT_MUXER 0
+#define CONFIG_OBU_MUXER 0
+#define CONFIG_OGA_MUXER 0
+#define CONFIG_OGG_MUXER 0
+#define CONFIG_OGV_MUXER 0
+#define CONFIG_OMA_MUXER 0
+#define CONFIG_OPUS_MUXER 0
+#define CONFIG_PCM_ALAW_MUXER 0
+#define CONFIG_PCM_MULAW_MUXER 0
+#define CONFIG_PCM_VIDC_MUXER 0
+#define CONFIG_PCM_F64BE_MUXER 0
+#define CONFIG_PCM_F64LE_MUXER 0
+#define CONFIG_PCM_F32BE_MUXER 0
+#define CONFIG_PCM_F32LE_MUXER 0
+#define CONFIG_PCM_S32BE_MUXER 0
+#define CONFIG_PCM_S32LE_MUXER 0
+#define CONFIG_PCM_S24BE_MUXER 0
+#define CONFIG_PCM_S24LE_MUXER 0
+#define CONFIG_PCM_S16BE_MUXER 0
+#define CONFIG_PCM_S16LE_MUXER 0
+#define CONFIG_PCM_S8_MUXER 0
+#define CONFIG_PCM_U32BE_MUXER 0
+#define CONFIG_PCM_U32LE_MUXER 0
+#define CONFIG_PCM_U24BE_MUXER 0
+#define CONFIG_PCM_U24LE_MUXER 0
+#define CONFIG_PCM_U16BE_MUXER 0
+#define CONFIG_PCM_U16LE_MUXER 0
+#define CONFIG_PCM_U8_MUXER 0
+#define CONFIG_PSP_MUXER 0
+#define CONFIG_RAWVIDEO_MUXER 0
+#define CONFIG_RM_MUXER 0
+#define CONFIG_ROQ_MUXER 0
+#define CONFIG_RSO_MUXER 0
+#define CONFIG_RTP_MUXER 0
+#define CONFIG_RTP_MPEGTS_MUXER 0
+#define CONFIG_RTSP_MUXER 0
+#define CONFIG_SAP_MUXER 0
+#define CONFIG_SBC_MUXER 0
+#define CONFIG_SCC_MUXER 0
+#define CONFIG_SEGAFILM_MUXER 0
+#define CONFIG_SEGMENT_MUXER 0
+#define CONFIG_STREAM_SEGMENT_MUXER 0
+#define CONFIG_SMJPEG_MUXER 0
+#define CONFIG_SMOOTHSTREAMING_MUXER 0
+#define CONFIG_SOX_MUXER 0
+#define CONFIG_SPX_MUXER 0
+#define CONFIG_SPDIF_MUXER 0
+#define CONFIG_SRT_MUXER 0
+#define CONFIG_STREAMHASH_MUXER 0
+#define CONFIG_SUP_MUXER 0
+#define CONFIG_SWF_MUXER 0
+#define CONFIG_TEE_MUXER 0
+#define CONFIG_TG2_MUXER 0
+#define CONFIG_TGP_MUXER 0
+#define CONFIG_MKVTIMESTAMP_V2_MUXER 0
+#define CONFIG_TRUEHD_MUXER 0
+#define CONFIG_TTA_MUXER 0
+#define CONFIG_TTML_MUXER 0
+#define CONFIG_UNCODEDFRAMECRC_MUXER 0
+#define CONFIG_VC1_MUXER 0
+#define CONFIG_VC1T_MUXER 0
+#define CONFIG_VOC_MUXER 0
+#define CONFIG_W64_MUXER 0
+#define CONFIG_WAV_MUXER 0
+#define CONFIG_WEBM_MUXER 0
+#define CONFIG_WEBM_DASH_MANIFEST_MUXER 0
+#define CONFIG_WEBM_CHUNK_MUXER 0
+#define CONFIG_WEBP_MUXER 0
+#define CONFIG_WEBVTT_MUXER 0
+#define CONFIG_WSAUD_MUXER 0
+#define CONFIG_WTV_MUXER 0
+#define CONFIG_WV_MUXER 0
+#define CONFIG_YUV4MPEGPIPE_MUXER 0
+#define CONFIG_CHROMAPRINT_MUXER 0
+#define CONFIG_ASYNC_PROTOCOL 0
+#define CONFIG_BLURAY_PROTOCOL 0
+#define CONFIG_CACHE_PROTOCOL 0
+#define CONFIG_CONCAT_PROTOCOL 0
+#define CONFIG_CONCATF_PROTOCOL 0
+#define CONFIG_CRYPTO_PROTOCOL 0
+#define CONFIG_DATA_PROTOCOL 0
+#define CONFIG_FD_PROTOCOL 0
+#define CONFIG_FFRTMPCRYPT_PROTOCOL 0
+#define CONFIG_FFRTMPHTTP_PROTOCOL 0
+#define CONFIG_FILE_PROTOCOL 0
+#define CONFIG_FTP_PROTOCOL 0
+#define CONFIG_GOPHER_PROTOCOL 0
+#define CONFIG_GOPHERS_PROTOCOL 0
+#define CONFIG_HLS_PROTOCOL 0
+#define CONFIG_HTTP_PROTOCOL 0
+#define CONFIG_HTTPPROXY_PROTOCOL 0
+#define CONFIG_HTTPS_PROTOCOL 0
+#define CONFIG_ICECAST_PROTOCOL 0
+#define CONFIG_MMSH_PROTOCOL 0
+#define CONFIG_MMST_PROTOCOL 0
+#define CONFIG_MD5_PROTOCOL 0
+#define CONFIG_PIPE_PROTOCOL 0
+#define CONFIG_PROMPEG_PROTOCOL 0
+#define CONFIG_RTMP_PROTOCOL 0
+#define CONFIG_RTMPE_PROTOCOL 0
+#define CONFIG_RTMPS_PROTOCOL 0
+#define CONFIG_RTMPT_PROTOCOL 0
+#define CONFIG_RTMPTE_PROTOCOL 0
+#define CONFIG_RTMPTS_PROTOCOL 0
+#define CONFIG_RTP_PROTOCOL 0
+#define CONFIG_SCTP_PROTOCOL 0
+#define CONFIG_SRTP_PROTOCOL 0
+#define CONFIG_SUBFILE_PROTOCOL 0
+#define CONFIG_TEE_PROTOCOL 0
+#define CONFIG_TCP_PROTOCOL 0
+#define CONFIG_TLS_PROTOCOL 0
+#define CONFIG_UDP_PROTOCOL 0
+#define CONFIG_UDPLITE_PROTOCOL 0
+#define CONFIG_UNIX_PROTOCOL 0
+#define CONFIG_LIBAMQP_PROTOCOL 0
+#define CONFIG_LIBRIST_PROTOCOL 0
+#define CONFIG_LIBRTMP_PROTOCOL 0
+#define CONFIG_LIBRTMPE_PROTOCOL 0
+#define CONFIG_LIBRTMPS_PROTOCOL 0
+#define CONFIG_LIBRTMPT_PROTOCOL 0
+#define CONFIG_LIBRTMPTE_PROTOCOL 0
+#define CONFIG_LIBSRT_PROTOCOL 0
+#define CONFIG_LIBSSH_PROTOCOL 0
+#define CONFIG_LIBSMBCLIENT_PROTOCOL 0
+#define CONFIG_LIBZMQ_PROTOCOL 0
+#define CONFIG_IPFS_GATEWAY_PROTOCOL 0
+#define CONFIG_IPNS_GATEWAY_PROTOCOL 0
+#endif /* FFMPEG_CONFIG_COMPONENTS_H */
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/bsf_list.c b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/bsf_list.c
new file mode 100644
index 0000000000..7ff70c6e2d
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/bsf_list.c
@@ -0,0 +1,2 @@
+static const FFBitStreamFilter * const bitstream_filters[] = {
+    NULL };
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/codec_list.c b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/codec_list.c
new file mode 100644
index 0000000000..cbd7f3945a
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/codec_list.c
@@ -0,0 +1,20 @@
+static const FFCodec * const codec_list[] = {
+    &ff_h264_decoder,
+    &ff_theora_decoder,
+    &ff_vp3_decoder,
+    &ff_vp8_decoder,
+    &ff_aac_decoder,
+    &ff_flac_decoder,
+    &ff_mp3_decoder,
+    &ff_vorbis_decoder,
+    &ff_pcm_alaw_decoder,
+    &ff_pcm_f32le_decoder,
+    &ff_pcm_mulaw_decoder,
+    &ff_pcm_s16be_decoder,
+    &ff_pcm_s16le_decoder,
+    &ff_pcm_s24be_decoder,
+    &ff_pcm_s24le_decoder,
+    &ff_pcm_s32le_decoder,
+    &ff_pcm_u8_decoder,
+    &ff_libopus_decoder,
+    NULL };
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/parser_list.c b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/parser_list.c
new file mode 100644
index 0000000000..50acddb28e
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavcodec/parser_list.c
@@ -0,0 +1,11 @@
+static const AVCodecParser * const parser_list[] = {
+    &ff_aac_parser,
+    &ff_flac_parser,
+    &ff_h264_parser,
+    &ff_mpegaudio_parser,
+    &ff_opus_parser,
+    &ff_vorbis_parser,
+    &ff_vp3_parser,
+    &ff_vp8_parser,
+    &ff_vp9_parser,
+    NULL };
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/demuxer_list.c b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/demuxer_list.c
new file mode 100644
index 0000000000..920b22bfa7
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/demuxer_list.c
@@ -0,0 +1,9 @@
+static const AVInputFormat * const demuxer_list[] = {
+    &ff_aac_demuxer,
+    &ff_flac_demuxer,
+    &ff_matroska_demuxer,
+    &ff_mov_demuxer,
+    &ff_mp3_demuxer,
+    &ff_ogg_demuxer,
+    &ff_wav_demuxer,
+    NULL };
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/muxer_list.c b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/muxer_list.c
new file mode 100644
index 0000000000..ae54c39f23
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/muxer_list.c
@@ -0,0 +1,2 @@
+static const FFOutputFormat * const muxer_list[] = {
+    NULL };
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/protocol_list.c b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/protocol_list.c
new file mode 100644
index 0000000000..247e1e4c3a
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavformat/protocol_list.c
@@ -0,0 +1,2 @@
+static const URLProtocol * const url_protocols[] = {
+    NULL };
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/avconfig.h b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/avconfig.h
new file mode 100644
index 0000000000..c289fbb551
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/avconfig.h
@@ -0,0 +1,6 @@
+/* Generated by ffmpeg configure */
+#ifndef AVUTIL_AVCONFIG_H
+#define AVUTIL_AVCONFIG_H
+#define AV_HAVE_BIGENDIAN 0
+#define AV_HAVE_FAST_UNALIGNED 1
+#endif /* AVUTIL_AVCONFIG_H */
diff --git a/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/ffversion.h b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/ffversion.h
new file mode 100644
index 0000000000..bbe1c8337c
--- /dev/null
+++ b/third_party/ffmpeg/chromium/config/Chrome/linux/loong64/libavutil/ffversion.h
@@ -0,0 +1,5 @@
+/* Automatically generated by version.sh, do not manually edit! */
+#ifndef AVUTIL_FFVERSION_H
+#define AVUTIL_FFVERSION_H
+#define FFMPEG_VERSION "git-2024-01-31-ac5b3876f"
+#endif /* AVUTIL_FFVERSION_H */
diff --git a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
index 19d0a0f7bc..b09def6b30 100755
--- a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
+++ b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
@@ -40,7 +40,7 @@ BRANDINGS = [
 ARCH_MAP = {
     'android': ['ia32', 'x64', 'arm-neon', 'arm64'],
     'linux': [
-        'ia32', 'x64', 'noasm-x64', 'arm', 'arm-neon', 'arm64'
+        'ia32', 'x64', 'noasm-x64', 'arm', 'arm-neon', 'arm64', 'loong64'
     ],
     'mac': ['x64', 'arm64'],
     'win': ['ia32', 'x64', 'arm64'],
@@ -63,12 +63,13 @@ Platform specific build notes:
   linux ia32/x64:
     Script can run on a normal Ubuntu box.
 
-  linux arm/arm-neon/arm64/mipsel/mips64el:
+  linux arm/arm-neon/arm64/mipsel/mips64el/loong64:
     Script can run on a normal Ubuntu with ARM/ARM64 or MIPS32/MIPS64 ready Chromium checkout:
       build/linux/sysroot_scripts/install-sysroot.py --arch=arm
       build/linux/sysroot_scripts/install-sysroot.py --arch=arm64
       build/linux/sysroot_scripts/install-sysroot.py --arch=mips
       build/linux/sysroot_scripts/install-sysroot.py --arch=mips64el
+      build/linux/sysroot_scripts/install-sysroot.py --arch=loong64
 
   mac:
     Script must be run on Linux or macOS.  Additionally, ensure the Chromium
@@ -136,6 +137,8 @@ def DetermineHostOsAndArch():
     host_arch = 'x64'
   elif platform.machine() == 'aarch64':
     host_arch = 'arm64'
+  elif platform.machine() == 'loongarch64':
+    host_arch = 'loong64'
   elif platform.machine() == 'mips32':
     host_arch = 'mipsel'
   elif platform.machine() == 'mips64':
@@ -911,6 +914,23 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
             '--extra-cflags=--target=mips64el-linux-gnuabi64',
             '--extra-ldflags=--target=mips64el-linux-gnuabi64',
         ])
+    elif target_arch == 'loong64':
+      if target_os == 'linux':
+        configure_flags['Common'].extend([
+            '--enable-cross-compile',
+            '--arch=loongarch64',
+            '--target-os=linux',
+            '--cc=' + os.path.join(CHROMIUM_ROOT_DIR,
+                CHROMIUM_ROOT_DIR, 'third_party/llvm-build/Release+Asserts/bin/clang'),
+            '--cxx=' + os.path.join(CHROMIUM_ROOT_DIR,
+                CHROMIUM_ROOT_DIR, 'third_party/llvm-build/Release+Asserts/bin/clang++'),
+            '--ld=' + os.path.join(CHROMIUM_ROOT_DIR,
+                CHROMIUM_ROOT_DIR, 'third_party/llvm-build/Release+Asserts/bin/clang'),
+            '--sysroot=' + os.path.join(CHROMIUM_ROOT_DIR,
+                CHROMIUM_ROOT_DIR, 'build/linux/debian_bullseye_loong64-sysroot'),
+            '--extra-cflags=--target=loongarch64-linux-gnu ',
+            '--extra-ldflags=--target=loongarch64-linux-gnu ',
+        ])
     else:
       print(
           'Error: Unknown target arch %r for target OS %r!' % (target_arch,
diff --git a/third_party/ffmpeg/chromium/scripts/copy_config.sh b/third_party/ffmpeg/chromium/scripts/copy_config.sh
index a18048cf04..d816451520 100755
--- a/third_party/ffmpeg/chromium/scripts/copy_config.sh
+++ b/third_party/ffmpeg/chromium/scripts/copy_config.sh
@@ -10,7 +10,7 @@ for os in android linux linux-noasm mac win; do
     # Copy config files for various architectures:
     #   - ia32/x64 have config.asm, config.h
     #   - arm/arm-neon have config.h
-    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el; do
+    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el loong64; do
       # Don't waste time on non-existent configs, if no config.h then skip.
       [ ! -e "build.$arch.$os/$target/config.h" ] && continue
       for f in config.h config_components.h config.asm libavutil/avconfig.h libavutil/ffversion.h libavcodec/bsf_list.c libavcodec/codec_list.c libavcodec/parser_list.c libavformat/demuxer_list.c libavformat/muxer_list.c libavformat/protocol_list.c; do
diff --git a/third_party/ffmpeg/chromium/scripts/generate_gn.py b/third_party/ffmpeg/chromium/scripts/generate_gn.py
index c7869a7d01..adfb5a2fcc 100755
--- a/third_party/ffmpeg/chromium/scripts/generate_gn.py
+++ b/third_party/ffmpeg/chromium/scripts/generate_gn.py
@@ -78,7 +78,7 @@ _Attrs = ('ARCHITECTURE', 'TARGET', 'PLATFORM')
 Attr = collections.namedtuple('Attr', _Attrs)(*_Attrs)
 SUPPORT_MATRIX = {
     Attr.ARCHITECTURE:
-        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon']),
+        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon', 'loong64']),
     Attr.TARGET:
         set(['Chromium', 'Chrome', 'ChromeOS']),
     Attr.PLATFORM:
diff --git a/third_party/ffmpeg/ffmpeg_generated.gni b/third_party/ffmpeg/ffmpeg_generated.gni
index 375489c10e..8faa5157a7 100644
--- a/third_party/ffmpeg/ffmpeg_generated.gni
+++ b/third_party/ffmpeg/ffmpeg_generated.gni
@@ -650,3 +650,37 @@ if (use_linux_config && current_cpu == "x64" && ffmpeg_branding == "ChromeOS") {
   ]
 }
 
+if (use_linux_config && current_cpu == "loong64") {
+  ffmpeg_c_sources += [
+    "libavcodec/loongarch/h264_intrapred_init_loongarch.c",
+    "libavcodec/loongarch/h264_intrapred_lasx.c",
+    "libavcodec/loongarch/hpeldsp_init_loongarch.c",
+    "libavcodec/loongarch/hpeldsp_lasx.c",
+    "libavcodec/loongarch/videodsp_init.c",
+    "libavcodec/loongarch/vp8_lpf_lsx.c",
+    "libavcodec/loongarch/vp8_mc_lsx.c",
+    "libavcodec/loongarch/vp8dsp_init_loongarch.c",
+    "libavutil/loongarch/cpu.c",
+  ]
+}
+
+if ((use_linux_config && current_cpu == "loong64" && ffmpeg_branding == "Chrome") || (use_linux_config && current_cpu == "loong64" && ffmpeg_branding == "ChromeOS")) {
+  ffmpeg_c_sources += [
+    "libavcodec/loongarch/h264_deblock_lasx.c",
+    "libavcodec/loongarch/h264chroma_init_loongarch.c",
+    "libavcodec/loongarch/h264chroma_lasx.c",
+    "libavcodec/loongarch/h264dsp_init_loongarch.c",
+    "libavcodec/loongarch/h264dsp_lasx.c",
+    "libavcodec/loongarch/h264idct_lasx.c",
+    "libavcodec/loongarch/h264qpel_init_loongarch.c",
+    "libavcodec/loongarch/h264qpel_lasx.c",
+  ]
+}
+
+if (use_linux_config && current_cpu == "loong64" && ffmpeg_branding == "ChromeOS") {
+  ffmpeg_c_sources += [
+    "libavcodec/loongarch/idctdsp_init_loongarch.c",
+    "libavcodec/loongarch/idctdsp_lasx.c",
+    "libavcodec/loongarch/simple_idct_lasx.c",
+  ]
+}
diff --git a/third_party/libvpx/source/libvpx/test/predict_test.cc b/third_party/libvpx/source/libvpx/test/predict_test.cc
index 7472970576..c14440e260 100644
--- a/third_party/libvpx/source/libvpx/test/predict_test.cc
+++ b/third_party/libvpx/source/libvpx/test/predict_test.cc
@@ -350,6 +350,14 @@ INSTANTIATE_TEST_SUITE_P(
                       make_tuple(4, 4, &vp8_sixtap_predict4x4_mmi)));
 #endif
 
+#if HAVE_LSX
+INSTANTIATE_TEST_SUITE_P(
+    LSX, SixtapPredictTest,
+    ::testing::Values(make_tuple(16, 16, &vp8_sixtap_predict16x16_lsx),
+                      make_tuple(8, 8, &vp8_sixtap_predict8x8_lsx),
+                      make_tuple(4, 4, &vp8_sixtap_predict4x4_lsx)));
+#endif
+
 class BilinearPredictTest : public PredictTestBase {};
 
 TEST_P(BilinearPredictTest, TestWithRandomData) {
diff --git a/third_party/libvpx/source/libvpx/test/test_intra_pred_speed.cc b/third_party/libvpx/source/libvpx/test/test_intra_pred_speed.cc
index 15303816b9..b013e0bd5d 100644
--- a/third_party/libvpx/source/libvpx/test/test_intra_pred_speed.cc
+++ b/third_party/libvpx/source/libvpx/test/test_intra_pred_speed.cc
@@ -348,6 +348,15 @@ INTRA_PRED_TEST(VSX, TestIntraPred32, vpx_dc_predictor_32x32_vsx,
                 vpx_tm_predictor_32x32_vsx)
 #endif  // HAVE_VSX
 
+#if HAVE_LSX
+INTRA_PRED_TEST(LSX, TestIntraPred8, vpx_dc_predictor_8x8_lsx, nullptr, nullptr,
+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
+                nullptr, nullptr, nullptr)
+INTRA_PRED_TEST(LSX, TestIntraPred16, vpx_dc_predictor_16x16_lsx, nullptr,
+                nullptr, nullptr, nullptr, nullptr, nullptr, nullptr, nullptr,
+                nullptr, nullptr, nullptr, nullptr)
+#endif  // HAVE_LSX
+
 // -----------------------------------------------------------------------------
 
 #if CONFIG_VP9_HIGHBITDEPTH
diff --git a/third_party/libvpx/source/libvpx/test/vp9_intrapred_test.cc b/third_party/libvpx/source/libvpx/test/vp9_intrapred_test.cc
index 6de7cf8d0f..22139b3379 100644
--- a/third_party/libvpx/source/libvpx/test/vp9_intrapred_test.cc
+++ b/third_party/libvpx/source/libvpx/test/vp9_intrapred_test.cc
@@ -489,6 +489,15 @@ INSTANTIATE_TEST_SUITE_P(
                                      &vpx_v_predictor_32x32_c, 32, 8)));
 #endif  // HAVE_VSX
 
+#if HAVE_LSX
+INSTANTIATE_TEST_SUITE_P(
+    LSX, VP9IntraPredTest,
+    ::testing::Values(IntraPredParam(&vpx_dc_predictor_8x8_lsx,
+                                     &vpx_dc_predictor_8x8_c, 8, 8),
+                      IntraPredParam(&vpx_dc_predictor_16x16_lsx,
+                                     &vpx_dc_predictor_16x16_c, 16, 8)));
+#endif  // HAVE_LSX
+
 #if CONFIG_VP9_HIGHBITDEPTH
 typedef void (*HighbdIntraPred)(uint16_t *dst, ptrdiff_t stride,
                                 const uint16_t *above, const uint16_t *left,
diff --git a/third_party/libvpx/source/libvpx/test/vp9_quantize_test.cc b/third_party/libvpx/source/libvpx/test/vp9_quantize_test.cc
index 5e3a7c2701..170932ab02 100644
--- a/third_party/libvpx/source/libvpx/test/vp9_quantize_test.cc
+++ b/third_party/libvpx/source/libvpx/test/vp9_quantize_test.cc
@@ -727,13 +727,13 @@ INSTANTIATE_TEST_SUITE_P(
 #endif  // HAVE_VSX && !CONFIG_VP9_HIGHBITDEPTH
 
 #if HAVE_LSX && !CONFIG_VP9_HIGHBITDEPTH
-INSTANTIATE_TEST_SUITE_P(LSX, VP9QuantizeTest,
-                         ::testing::Values(make_tuple(&vpx_quantize_b_lsx,
-                                                      &vpx_quantize_b_c,
-                                                      VPX_BITS_8, 16, false),
-                                           make_tuple(&vpx_quantize_b_32x32_lsx,
-                                                      &vpx_quantize_b_32x32_c,
-                                                      VPX_BITS_8, 32, false)));
+INSTANTIATE_TEST_SUITE_P(
+    LSX, VP9QuantizeTest,
+    ::testing::Values(make_tuple(&vpx_quantize_b_lsx, &vpx_quantize_b_c,
+                                 VPX_BITS_8, 16, false),
+                      make_tuple(&Quant32x32Wrapper<vpx_quantize_b_32x32_lsx>,
+                                 &Quant32x32Wrapper<vpx_quantize_b_32x32_c>,
+                                 VPX_BITS_8, 32, false)));
 #endif  // HAVE_LSX && !CONFIG_VP9_HIGHBITDEPTH
 
 // Only useful to compare "Speed" test results.
diff --git a/third_party/libvpx/source/libvpx/vp8/common/loongarch/sixtap_filter_lsx.c b/third_party/libvpx/source/libvpx/vp8/common/loongarch/sixtap_filter_lsx.c
index cd7ba54746..9867633415 100644
--- a/third_party/libvpx/source/libvpx/vp8/common/loongarch/sixtap_filter_lsx.c
+++ b/third_party/libvpx/source/libvpx/vp8/common/loongarch/sixtap_filter_lsx.c
@@ -1706,21 +1706,22 @@ void vp8_sixtap_predict4x4_lsx(uint8_t *RESTRICT src, int32_t src_stride,
       switch (xoffset) {
         case 0: {
           __m128i tp0;
-          tp0 = __lsx_vinsgr2vr_w(tp0, src, 0);
-          src += src_stride;
-          tp0 = __lsx_vinsgr2vr_w(tp0, src, 0);
-          src += src_stride;
-          tp0 = __lsx_vinsgr2vr_w(tp0, src, 0);
-          src += src_stride;
-          tp0 = __lsx_vinsgr2vr_w(tp0, src, 0);
 
+          tp0 = __lsx_vldrepl_w(src, 0);
+          src += src_stride;
           __lsx_vstelm_w(tp0, dst, 0, 0);
           dst += dst_stride;
-          __lsx_vstelm_w(tp0, dst, 0, 1);
+          tp0 = __lsx_vldrepl_w(src, 0);
+          src += src_stride;
+          __lsx_vstelm_w(tp0, dst, 0, 0);
           dst += dst_stride;
-          __lsx_vstelm_w(tp0, dst, 0, 2);
+          tp0 = __lsx_vldrepl_w(src, 0);
+          src += src_stride;
+          __lsx_vstelm_w(tp0, dst, 0, 0);
           dst += dst_stride;
-          __lsx_vstelm_w(tp0, dst, 0, 3);
+          tp0 = __lsx_vldrepl_w(src, 0);
+          __lsx_vstelm_w(tp0, dst, 0, 0);
+
           break;
         }
         case 2:
@@ -1865,7 +1866,7 @@ void vp8_sixtap_predict16x16_lsx(uint8_t *RESTRICT src, int32_t src_stride,
 
               case 1:
                 Predict16x16Funcs1[3](src, src_stride, dst, dst_stride,
-                                      h_filter, v_filter + 1, 16);
+                                      h_filter + 1, v_filter + 1, 16);
                 break;
             }
             break;
diff --git a/third_party/libvpx/source/libvpx/vpx_dsp/loongarch/quantize_lsx.c b/third_party/libvpx/source/libvpx/vpx_dsp/loongarch/quantize_lsx.c
index 77be0bb4fe..7d924a9922 100644
--- a/third_party/libvpx/source/libvpx/vpx_dsp/loongarch/quantize_lsx.c
+++ b/third_party/libvpx/source/libvpx/vpx_dsp/loongarch/quantize_lsx.c
@@ -11,6 +11,8 @@
 #include "./vpx_config.h"
 #include "./vpx_dsp_rtcd.h"
 #include "vpx_util/loongson_intrinsics.h"
+#include "vp9/common/vp9_scan.h"
+#include "vp9/encoder/vp9_block.h"
 
 static INLINE __m128i calculate_qcoeff(__m128i coeff, __m128i coeff_abs,
                                        __m128i round, __m128i quant,
@@ -88,6 +90,7 @@ static INLINE int16_t accumulate_eob(__m128i eob) {
 }
 
 #if !CONFIG_VP9_HIGHBITDEPTH
+
 void vpx_quantize_b_lsx(const int16_t *coeff_ptr, intptr_t n_coeffs,
                         const int16_t *zbin_ptr, const int16_t *round_ptr,
                         const int16_t *quant_ptr,
@@ -167,31 +170,27 @@ void vpx_quantize_b_lsx(const int16_t *coeff_ptr, intptr_t n_coeffs,
   *eob_ptr = accumulate_eob(eob);
 }
 
-void vpx_quantize_b_32x32_lsx(const int16_t *coeff_ptr, intptr_t n_coeffs,
-                              const int16_t *zbin_ptr, const int16_t *round_ptr,
-                              const int16_t *quant_ptr,
-                              const int16_t *quant_shift_ptr,
-                              int16_t *qcoeff_ptr, int16_t *dqcoeff_ptr,
+void vpx_quantize_b_32x32_lsx(const tran_low_t *coeff_ptr,
+                              const struct macroblock_plane *const mb_plane,
+                              tran_low_t *qcoeff_ptr, tran_low_t *dqcoeff_ptr,
                               const int16_t *dequant_ptr, uint16_t *eob_ptr,
-                              const int16_t *scan, const int16_t *iscan) {
+                              const struct ScanOrder *const scan_order) {
   __m128i zero = __lsx_vldi(0);
   int index;
+  const int16_t *iscan = scan_order->iscan;
 
   __m128i zbin, round, quant, dequant, quant_shift;
   __m128i coeff0, coeff1, qcoeff0, qcoeff1, cmp_mask0, cmp_mask1;
   __m128i eob = zero, eob0;
 
-  (void)scan;
-  (void)n_coeffs;
-
-  zbin = __lsx_vld(zbin_ptr, 0);
+  zbin = __lsx_vld(mb_plane->zbin, 0);
   zbin = __lsx_vsrari_h(zbin, 1);
-  round = __lsx_vld(round_ptr, 0);
+  round = __lsx_vld(mb_plane->round, 0);
   round = __lsx_vsrari_h(round, 1);
 
-  quant = __lsx_vld(quant_ptr, 0);
+  quant = __lsx_vld(mb_plane->quant, 0);
   dequant = __lsx_vld(dequant_ptr, 0);
-  quant_shift = __lsx_vld(quant_shift_ptr, 0);
+  quant_shift = __lsx_vld(mb_plane->quant_shift, 0);
   quant_shift = __lsx_vslli_h(quant_shift, 1);
   // Handle one DC and first 15 AC.
   DUP2_ARG2(__lsx_vld, coeff_ptr, 0, coeff_ptr, 16, coeff0, coeff1);
diff --git a/third_party/libyuv/BUILD.gn b/third_party/libyuv/BUILD.gn
index 133336ddc1..5a0ca81457 100644
--- a/third_party/libyuv/BUILD.gn
+++ b/third_party/libyuv/BUILD.gn
@@ -12,7 +12,7 @@ import("libyuv.gni")
 
 declare_args() {
   # Set to false to disable building with absl flags.
-  libyuv_use_absl_flags = true
+  libyuv_use_absl_flags = false
 
   # When building a shared library using a target in WebRTC or
   # Chromium projects that depends on libyuv, setting this flag
@@ -74,6 +74,14 @@ group("libyuv") {
     deps += [ ":libyuv_msa" ]
   }
 
+  if (libyuv_use_lasx) {
+    deps += [ ":libyuv_lasx" ]
+  }
+
+  if (libyuv_use_lsx) {
+    deps += [ ":libyuv_lsx" ]
+  }
+
   if (!is_ios && !libyuv_disable_jpeg) {
     # Make sure that clients of libyuv link with libjpeg. This can't go in
     # libyuv_internal because in Windows x64 builds that will generate a clang
@@ -183,6 +191,12 @@ static_library("libyuv_internal") {
       "-ffp-contract=fast",  # Enable fma vectorization for NEON.
     ]
   }
+  if (!libyuv_use_lasx) {
+    defines += [ "LIBYUV_DISABLE_LASX" ]
+  }
+  if (!libyuv_use_lsx) {
+    defines += [ "LIBYUV_DISABLE_LSX" ]
+  }
 }
 
 if (libyuv_use_neon) {
@@ -236,6 +250,38 @@ if (libyuv_use_msa) {
   }
 }
 
+if (libyuv_use_lasx) {
+  static_library("libyuv_lasx") {
+    sources = [
+      # LASX Source Files
+      "source/row_lasx.cc",
+    ]
+
+    cflags_cc = [ "-mlasx", "-Wno-c++11-narrowing" ]
+
+    deps = [ ":libyuv_internal" ]
+
+    public_configs = [ ":libyuv_config" ]
+  }
+}
+
+if (libyuv_use_lsx) {
+  static_library("libyuv_lsx") {
+    sources = [
+      # LSX Source Files
+      "source/rotate_lsx.cc",
+      "source/row_lsx.cc",
+      "source/scale_lsx.cc",
+    ]
+
+    cflags_cc = [ "-mlsx",  "-Wno-c++11-narrowing" ]
+
+    deps = [ ":libyuv_internal" ]
+
+    public_configs = [ ":libyuv_config" ]
+  }
+}
+
 if (libyuv_include_tests) {
   config("libyuv_unittest_warnings_config") {
     if (!is_win) {
diff --git a/third_party/libyuv/include/libyuv/rotate_row.h b/third_party/libyuv/include/libyuv/rotate_row.h
index 2dd8c03d37..fabaff4ea7 100644
--- a/third_party/libyuv/include/libyuv/rotate_row.h
+++ b/third_party/libyuv/include/libyuv/rotate_row.h
@@ -64,7 +64,7 @@ extern "C" {
 #define HAS_TRANSPOSEUVWX16_MSA
 #endif
 
-#if !defined(LIBYUV_DISABLE_LSX) && defined(__loongarch_sx)
+#if !defined(LIBYUV_DISABLE_LSX) && defined(__loongarch__)
 #define HAS_TRANSPOSEWX16_LSX
 #define HAS_TRANSPOSEUVWX16_LSX
 #endif
diff --git a/third_party/libyuv/include/libyuv/row.h b/third_party/libyuv/include/libyuv/row.h
index 8df334b17e..47fbd0f002 100644
--- a/third_party/libyuv/include/libyuv/row.h
+++ b/third_party/libyuv/include/libyuv/row.h
@@ -643,7 +643,7 @@ extern "C" {
 #define HAS_YUY2TOYROW_MSA
 #endif
 
-#if !defined(LIBYUV_DISABLE_LSX) && defined(__loongarch_sx)
+#if !defined(LIBYUV_DISABLE_LSX) && defined(__loongarch__)
 #define HAS_ABGRTOUVROW_LSX
 #define HAS_ABGRTOYROW_LSX
 #define HAS_ARGB1555TOARGBROW_LSX
@@ -716,6 +716,7 @@ extern "C" {
 #define HAS_UYVYTOUV422ROW_LSX
 #define HAS_UYVYTOUVROW_LSX
 #define HAS_UYVYTOYROW_LSX
+#define HAS_I422TOARGBROW_LSX
 #define HAS_YUY2TOARGBROW_LSX
 #define HAS_YUY2TOUVROW_LSX
 #define HAS_YUY2TOUV422ROW_LSX
@@ -727,11 +728,7 @@ extern "C" {
 #define HAS_RAWTOYJROW_LSX
 #endif
 
-#if !defined(LIBYUV_DISABLE_LSX) && defined(__loongarch_sx)
-#define HAS_I422TOARGBROW_LSX
-#endif
-
-#if !defined(LIBYUV_DISABLE_LASX) && defined(__loongarch_asx)
+#if !defined(LIBYUV_DISABLE_LASX) && defined(__loongarch_sx)
 #define HAS_ARGB1555TOARGBROW_LASX
 #define HAS_ARGB1555TOUVROW_LASX
 #define HAS_ARGB1555TOYROW_LASX
@@ -1174,6 +1171,13 @@ void I422ToARGBRow_LSX(const uint8_t* src_y,
                        uint8_t* dst_argb,
                        const struct YuvConstants* yuvconstants,
                        int width);
+void I422ToARGBRow_LSX(const uint8_t* src_y,
+                       const uint8_t* src_u,
+                       const uint8_t* src_v,
+                       uint8_t* dst_argb,
+                       const struct YuvConstants* yuvconstants,
+                       int width);
+
 void I422ToARGBRow_LASX(const uint8_t* src_y,
                         const uint8_t* src_u,
                         const uint8_t* src_v,
@@ -5002,6 +5006,12 @@ void I422ToARGBRow_Any_LSX(const uint8_t* y_buf,
                            uint8_t* dst_ptr,
                            const struct YuvConstants* yuvconstants,
                            int width);
+void I422ToARGBRow_Any_LSX(const uint8_t* y_buf,
+                            const uint8_t* u_buf,
+                            const uint8_t* v_buf,
+                            uint8_t* dst_ptr,
+                            const struct YuvConstants* yuvconstants,
+                            int width);
 void I422ToARGBRow_Any_LASX(const uint8_t* y_buf,
                             const uint8_t* u_buf,
                             const uint8_t* v_buf,
diff --git a/third_party/libyuv/include/libyuv/scale_row.h b/third_party/libyuv/include/libyuv/scale_row.h
index dbe664def2..fed427918b 100644
--- a/third_party/libyuv/include/libyuv/scale_row.h
+++ b/third_party/libyuv/include/libyuv/scale_row.h
@@ -162,7 +162,7 @@ extern "C" {
 #define HAS_SCALEROWDOWN4_MSA
 #endif
 
-#if !defined(LIBYUV_DISABLE_LSX) && defined(__loongarch_sx)
+#if !defined(LIBYUV_DISABLE_LSX) && defined(__loongarch__)
 #define HAS_SCALEARGBROWDOWN2_LSX
 #define HAS_SCALEARGBROWDOWNEVEN_LSX
 #define HAS_SCALEROWDOWN2_LSX
diff --git a/third_party/libyuv/libyuv.gni b/third_party/libyuv/libyuv.gni
index 0a6c445338..5aa7d4c15b 100644
--- a/third_party/libyuv/libyuv.gni
+++ b/third_party/libyuv/libyuv.gni
@@ -8,10 +8,11 @@
 
 import("//build/config/arm.gni")
 import("//build/config/mips.gni")
+import("//build/config/loongarch64.gni")
 import("//build_overrides/build.gni")
 
 declare_args() {
-  libyuv_include_tests = !build_with_chromium
+  libyuv_include_tests = build_with_chromium
   libyuv_disable_jpeg = false
   libyuv_disable_rvv = false
   libyuv_use_neon =
@@ -21,4 +22,8 @@ declare_args() {
       (current_cpu == "mips64el" || current_cpu == "mipsel") && mips_use_msa
   libyuv_use_mmi =
       (current_cpu == "mips64el" || current_cpu == "mipsel") && mips_use_mmi
+  libyuv_use_lasx=
+      current_cpu == "loong64" && loongarch64_use_lasx
+  libyuv_use_lsx=
+      current_cpu == "loong64" && loongarch64_use_lsx
 }
diff --git a/third_party/libyuv/source/convert_argb.cc b/third_party/libyuv/source/convert_argb.cc
index cc6560de66..35bdbc8cab 100644
--- a/third_party/libyuv/source/convert_argb.cc
+++ b/third_party/libyuv/source/convert_argb.cc
@@ -128,6 +128,14 @@ int I420ToARGBMatrix(const uint8_t* src_y,
     }
   }
 #endif
+#if defined(HAS_I422TOARGBROW_LSX)
+  if (TestCpuFlag(kCpuHasLSX)) {
+    I422ToARGBRow = I422ToARGBRow_Any_LSX;
+    if (IS_ALIGNED(width, 16)) {
+      I422ToARGBRow = I422ToARGBRow_LSX;
+    }
+  }
+#endif
 #if defined(HAS_I422TOARGBROW_LASX)
   if (TestCpuFlag(kCpuHasLASX)) {
     I422ToARGBRow = I422ToARGBRow_Any_LASX;
@@ -382,6 +390,14 @@ int I422ToARGBMatrix(const uint8_t* src_y,
     }
   }
 #endif
+#if defined(HAS_I422TOARGBROW_LSX)
+  if (TestCpuFlag(kCpuHasLSX)) {
+    I422ToARGBRow = I422ToARGBRow_Any_LSX;
+    if (IS_ALIGNED(width, 16)) {
+      I422ToARGBRow = I422ToARGBRow_LSX;
+    }
+  }
+#endif
 #if defined(HAS_I422TOARGBROW_LASX)
   if (TestCpuFlag(kCpuHasLASX)) {
     I422ToARGBRow = I422ToARGBRow_Any_LASX;
@@ -5708,6 +5724,14 @@ int I420ToRGB565Dither(const uint8_t* src_y,
     }
   }
 #endif
+#if defined(HAS_I422TOARGBROW_LSX)
+  if (TestCpuFlag(kCpuHasLSX)) {
+    I422ToARGBRow = I422ToARGBRow_Any_LSX;
+    if (IS_ALIGNED(width, 16)) {
+      I422ToARGBRow = I422ToARGBRow_LSX;
+    }
+  }
+#endif
 #if defined(HAS_I422TOARGBROW_LASX)
   if (TestCpuFlag(kCpuHasLASX)) {
     I422ToARGBRow = I422ToARGBRow_Any_LASX;
diff --git a/third_party/libyuv/source/cpu_id.cc b/third_party/libyuv/source/cpu_id.cc
index 0c4a1581ca..1098d7bc6c 100644
--- a/third_party/libyuv/source/cpu_id.cc
+++ b/third_party/libyuv/source/cpu_id.cc
@@ -268,9 +268,31 @@ LIBYUV_API SAFEBUFFERS int MipsCpuCaps(const char* cpuinfo_name) {
 #define LOONGARCH_CFG2_LSX (1 << 6)
 #define LOONGARCH_CFG2_LASX (1 << 7)
 
+enum {
+  LOONG_COM = 1 << 0,
+  LOONG_LSX = 1 << 1,
+  LOONG_LASX = 1 << 2,
+  DISABLE_LOONGOPT = 1 << 4,
+};
+
+extern "C" {
+  __attribute__((visibility("default")))
+  unsigned int gLoongsonCpuFeatureLibyuv = 0;
+}
+
 #if defined(__loongarch__)
 LIBYUV_API SAFEBUFFERS int LoongarchCpuCaps(void) {
   int flag = 0;
+  if(DISABLE_LOONGOPT == gLoongsonCpuFeatureLibyuv)
+    return 0;
+  if(0 != gLoongsonCpuFeatureLibyuv) { // has initialized in main process.
+    if (LOONG_LSX & gLoongsonCpuFeatureLibyuv)
+      flag |= kCpuHasLSX;
+    if (LOONG_LASX & gLoongsonCpuFeatureLibyuv)
+      flag |= kCpuHasLASX;
+    return flag;
+  }
+
   uint32_t cfg2 = 0;
 
   __asm__ volatile("cpucfg %0, %1 \n\t" : "+&r"(cfg2) : "r"(LOONGARCH_CFG2));
diff --git a/third_party/libyuv/source/scale_argb.cc b/third_party/libyuv/source/scale_argb.cc
index 214f932cbe..b5cc07da19 100644
--- a/third_party/libyuv/source/scale_argb.cc
+++ b/third_party/libyuv/source/scale_argb.cc
@@ -697,6 +697,14 @@ static void ScaleYUVToARGBBilinearUp(int src_width,
     }
   }
 #endif
+#if defined(HAS_I422TOARGBROW_LSX)
+  if (TestCpuFlag(kCpuHasLSX)) {
+    I422ToARGBRow = I422ToARGBRow_Any_LSX;
+    if (IS_ALIGNED(src_width, 16)) {
+      I422ToARGBRow = I422ToARGBRow_LSX;
+    }
+  }
+#endif
 #if defined(HAS_I422TOARGBROW_LASX)
   if (TestCpuFlag(kCpuHasLASX)) {
     I422ToARGBRow = I422ToARGBRow_Any_LASX;
diff --git a/third_party/lss/linux_syscall_support.h b/third_party/lss/linux_syscall_support.h
index 99a4b44491..e768d32b6a 100644
--- a/third_party/lss/linux_syscall_support.h
+++ b/third_party/lss/linux_syscall_support.h
@@ -322,7 +322,7 @@ struct kernel_old_sigaction {
  * actual number of signals is obviously the same, but the constants
  * differ by one.
  */
-#ifdef __mips__
+#if defined(__mips__) || defined(LOONGARCH_IS_LEGACY)
 #define KERNEL_NSIG 128
 #else
 #define KERNEL_NSIG  64
@@ -747,7 +747,7 @@ struct kernel_statfs64 {
   unsigned long      f_spare[6];
 };
 #endif
-#elif defined(__s390__)
+#elif defined(__s390__) || defined(LOONGARCH_IS_LEGACY)
 /* See also arch/s390/include/asm/compat.h                                   */
 struct kernel_statfs64 {
   unsigned int       f_type;
@@ -811,7 +811,7 @@ struct kernel_statfs {
   uint64_t           f_frsize;
   uint64_t           f_spare[5];
 };
-#elif defined(__s390__)
+#elif defined(__s390__) || defined(LOONGARCH_IS_LEGACY)
 struct kernel_statfs {
   unsigned int       f_type;
   unsigned int       f_bsize;
@@ -1308,7 +1308,7 @@ struct kernel_statx {
 #ifndef __NR_readlinkat
 #define __NR_readlinkat          78
 #endif
-#if !defined(__loongarch_lp64)
+#if !defined(LOONGARCH_NOT_LEGACY)
 #ifndef __NR_newfstatat
 #define __NR_newfstatat          79
 #endif
@@ -3940,13 +3940,23 @@ struct kernel_statx {
      * So, we just have to redefine all of the _syscallX() macros.
      */
     #undef LSS_REG
-    #define LSS_REG(ar,a) register int64_t __r##ar __asm__("a"#ar) = (int64_t)a
-    /* syscall is like subroutine calls, all caller-saved registers may be
-     * clobbered, we should add them to the |Clobbers| list.
-     * a0 is not included because it's in the output list.
-     */
-    #define LSS_SYSCALL_CLOBBERS "t0", "t1", "t2", "t3", "t4", "t5", "t6",    \
-                                 "t7", "t8", "memory"
+    #define LSS_REG(ar,a) register int64_t __a##ar __asm__("a"#ar) = (int64_t)a
+    #undef LSS_SYSCALL_CLOBBERS
+    #if defined(LOONGARCH_IS_LEGACY)
+      /* Upon return, the return value is placed in a0; a1-a7 and t0-t8 should
+       * be considered clobbered, all other registers are preserved.
+       */
+      #define LSS_SYSCALL_CLOBBERS "a1", "a2", "a3", "a4", "a5", "a6", "a7",  \
+                                   "t0", "t1", "t2", "t3", "t4", "t5", "t6",  \
+                                   "t7", "t8", "memory"
+    #else
+      /* Upon return, the return value is placed in a0; t0-t8 should be
+       * considered clobbered, all other registers are preserved.
+       */
+      #define LSS_SYSCALL_CLOBBERS "a1", "a2", "a3", "a4", "a5", "a6", "a7",  \
+                                   "t0", "t1", "t2", "t3", "t4", "t5", "t6",  \
+                                   "t7", "t8", "memory"
+    #endif
     #undef  LSS_BODY
     #define LSS_BODY(type,name,args...)                                       \
           register int64_t __res_a0 __asm__("a0");                            \
@@ -3966,26 +3976,26 @@ struct kernel_statx {
     #undef _syscall1
     #define _syscall1(type, name, type1, arg1)                                \
       type LSS_NAME(name)(type1 arg1) {                                       \
-        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
+        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__a0));                    \
       }
     #undef _syscall2
     #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
       type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
         LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1));                           \
       }
     #undef _syscall3
     #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
         LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2));                \
       }
     #undef _syscall4
     #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
       type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
         LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
         LSS_REG(3, arg4);                                                     \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3));     \
       }
     #undef _syscall5
     #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
@@ -3994,8 +4004,8 @@ struct kernel_statx {
                           type5 arg5) {                                       \
         LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
         LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4));                                      \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),      \
+                             "r"(__a4));                                      \
       }
     #undef _syscall6
     #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
@@ -4004,8 +4014,8 @@ struct kernel_statx {
                           type5 arg5, type6 arg6) {                           \
         LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
         LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4), "r"(__r5));                           \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),      \
+                             "r"(__a4), "r"(__a5));                           \
       }
 
     LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
@@ -4014,7 +4024,7 @@ struct kernel_statx {
       int64_t __res;
       {
         register int64_t __res_a0 __asm__("a0");
-        register uint64_t __flags __asm__("a0") = flags;
+        register uint64_t __flags __asm__("a0") = static_cast<uint64_t>(flags);
         register void *__stack __asm__("a1") = child_stack;
         register void *__ptid  __asm__("a2") = parent_tidptr;
         register void *__tls   __asm__("a3") = newtls;
@@ -5279,7 +5289,7 @@ struct kernel_statx {
 // TODO: define this in an arch-independant way instead of inlining the clone
 //       syscall body.
 
-# if defined(__aarch64__) || defined(__riscv) || defined(__loongarch_lp64)
+# if defined(__aarch64__) || defined(__riscv)
   LSS_INLINE pid_t LSS_NAME(fork)(void) {
     // No fork syscall on aarch64 - implement by means of the clone syscall.
     // Note that this does not reset glibc's cached view of the PID/TID, so
@@ -5298,6 +5308,25 @@ struct kernel_statx {
     LSS_BODY(pid_t, clone, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),
              "r"(__r4));
   }
+# elif defined(__loongarch__)
+  LSS_INLINE pid_t LSS_NAME(fork)(void) {
+    // No fork syscall on loongarch - implement by means of the clone syscall.
+    // Note that this does not reset glibc's cached view of the PID/TID, so
+    // some glibc interfaces might go wrong in the forked subprocess.
+    int flags = SIGCHLD;
+    void *child_stack = NULL;
+    void *parent_tidptr = NULL;
+    void *newtls = NULL;
+    void *child_tidptr = NULL;
+
+    LSS_REG(0, flags);
+    LSS_REG(1, child_stack);
+    LSS_REG(2, parent_tidptr);
+    LSS_REG(3, newtls);
+    LSS_REG(4, child_tidptr);
+    LSS_BODY(pid_t, clone, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),
+             "r"(__a4));
+  }
 # elif defined(__x86_64__)
   LSS_INLINE pid_t LSS_NAME(fork)(void) {
     // Android disallows the fork syscall on x86_64 - implement by means of the
diff --git a/third_party/protobuf/src/google/protobuf/port_def.inc b/third_party/protobuf/src/google/protobuf/port_def.inc
index 8cc16a6ece..24ad0b6b97 100644
--- a/third_party/protobuf/src/google/protobuf/port_def.inc
+++ b/third_party/protobuf/src/google/protobuf/port_def.inc
@@ -235,7 +235,7 @@
 #endif
 #if __has_cpp_attribute(clang::musttail) && !defined(__arm__) && \
     !defined(_ARCH_PPC) && !defined(__wasm__) &&                 \
-    !(defined(_MSC_VER) && defined(_M_IX86))
+    !(defined(_MSC_VER) && defined(_M_IX86)) && !defined(__loongarch__)
 #  ifndef PROTO2_OPENSOURCE
 // Compilation fails on ARM32: b/195943306
 // Compilation fails on powerpc64le: b/187985113
diff --git a/third_party/skia/BUILD.gn b/third_party/skia/BUILD.gn
index 34ca483b63..5cd3a2e6e2 100644
--- a/third_party/skia/BUILD.gn
+++ b/third_party/skia/BUILD.gn
@@ -22,6 +22,12 @@ if (defined(skia_settings)) {
   import(skia_settings)
 }
 
+if(current_cpu == "loong64") {
+  declare_args() {
+    use_la64_opt = true
+  }
+}
+
 import("gn/ios.gni")
 
 # Skia public API, generally provided by :skia.
@@ -185,6 +191,18 @@ opts("ssse3") {
   }
 }
 
+opts("lasx") {
+  enabled = current_cpu == "loong64"
+  sources = skia_opts.lasx_sources
+  cflags = [ "-mlasx", "-O3", "-Wno-unused-function", ]
+}
+
+#opts("lsx") {
+#  enabled = current_cpu == "loong64"
+#  sources = skia_opts.lsx_sources
+#  cflags = [ "-mlsx", "-O3", "-Wno-unused-function", ]
+#}
+
 opts("avx") {
   enabled = is_x86
   sources = skia_opts.avx_sources
@@ -1433,6 +1451,7 @@ skia_component("skia") {
     ":ndk_images",
     ":png_decode",
     ":raw",
+    ":lasx",
     ":skvm_jit",
     ":skx",
     ":ssse3",
diff --git a/third_party/skia/gn/opts.gni b/third_party/skia/gn/opts.gni
index 56d1bc0496..25d692abc7 100644
--- a/third_party/skia/gn/opts.gni
+++ b/third_party/skia/gn/opts.gni
@@ -10,3 +10,5 @@ ssse3 = [ "$_src/opts/SkOpts_ssse3.cpp" ]
 avx = [ "$_src/opts/SkOpts_avx.cpp" ]
 hsw = [ "$_src/opts/SkOpts_hsw.cpp" ]
 skx = [ "$_src/opts/SkOpts_skx.cpp" ]
+#lsx = [ "$_src/opts/SkOpts_lsx.cpp" ]
+lasx = [ "$_src/opts/SkOpts_lasx.cpp" ]
diff --git a/third_party/skia/gn/shared_sources.gni b/third_party/skia/gn/shared_sources.gni
index 146a537ff8..9596b7f147 100644
--- a/third_party/skia/gn/shared_sources.gni
+++ b/third_party/skia/gn/shared_sources.gni
@@ -22,4 +22,6 @@ skia_opts = {
   avx_sources = avx
   hsw_sources = hsw
   skx_sources = skx
+  #lsx_sources = lsx
+  lasx_sources = lasx
 }
diff --git a/third_party/skia/include/core/SkColor.h b/third_party/skia/include/core/SkColor.h
index 3b46be030f..732d6cade2 100644
--- a/third_party/skia/include/core/SkColor.h
+++ b/third_party/skia/include/core/SkColor.h
@@ -264,6 +264,10 @@ struct SkRGBA4f {
     float fG;  //!< green component
     float fB;  //!< blue component
     float fA;  //!< alpha component
+    static SkRGBA4f Make(float tr, float tg, float tb, float ta) {
+      return {tr, tg, tb, ta};
+    }
+    //SkRGBA4f();
 
     /** Compares SkRGBA4f with other, and returns true if all components are equal.
 
diff --git a/third_party/skia/include/private/base/SkFeatures.h b/third_party/skia/include/private/base/SkFeatures.h
index 1c8aa4c0af..3869ee0bce 100644
--- a/third_party/skia/include/private/base/SkFeatures.h
+++ b/third_party/skia/include/private/base/SkFeatures.h
@@ -144,4 +144,21 @@
     #define SK_ARM_HAS_NEON
 #endif
 
+// LoongArch defines
+#if defined(__loongarch__)
+    #define SK_CPU_LOONGARCH 1
+#endif
+
+#define SK_CPU_LSX_LEVEL_LSX      61
+#define SK_CPU_LSX_LEVEL_LASX     62
+
+#if defined(SK_CPU_LOONGARCH) && !defined(SK_BUILD_NO_OPTS)
+    #if defined(__loongarch_asx) && !defined(SK_LA_HAS_LASX)
+        #define SK_LA_HAS_LASX 1
+    #endif
+    #if defined(__loongarch_sx) && !defined(SK_LA_HAS_LSX)
+        #define SK_LA_HAS_LSX 1
+    #endif
+#endif
+
 #endif // SkFeatures_DEFINED
diff --git a/third_party/skia/modules/skcms/skcms.cc b/third_party/skia/modules/skcms/skcms.cc
index 3940c0ab9a..c100a959de 100644
--- a/third_party/skia/modules/skcms/skcms.cc
+++ b/third_party/skia/modules/skcms/skcms.cc
@@ -30,6 +30,8 @@
         #include <avx512fintrin.h>
         #include <avx512dqintrin.h>
     #endif
+#elif defined(__loongarch_sx)
+    #include <lsxintrin.h>
 #endif
 
 static bool runtime_cpu_detection = true;
diff --git a/third_party/skia/modules/skcms/src/Transform_inl.h b/third_party/skia/modules/skcms/src/Transform_inl.h
index ede3732558..6fdebd23d7 100644
--- a/third_party/skia/modules/skcms/src/Transform_inl.h
+++ b/third_party/skia/modules/skcms/src/Transform_inl.h
@@ -168,6 +168,7 @@ SI F F_from_Half(U16 half) {
 #elif defined(USING_AVX_F16C)
     typedef int16_t __attribute__((vector_size(16))) I16;
     return __builtin_ia32_vcvtph2ps256((I16)half);
+//TODO: loongarch vfcvtl.s.h vfcvth.s.h
 #else
     U32 wide = cast<U32>(half);
     // A half is 1-5-10 sign-exponent-mantissa, with 15 exponent bias.
@@ -194,6 +195,7 @@ SI U16 Half_from_F(F f) {
     return (U16)_mm512_cvtps_ph((__m512 )f, _MM_FROUND_CUR_DIRECTION );
 #elif defined(USING_AVX_F16C)
     return (U16)__builtin_ia32_vcvtps2ph256(f, 0x04/*_MM_FROUND_CUR_DIRECTION*/);
+//TODO: loongarch vfcvt.h.s vfcrt.s.d
 #else
     // A float is 1-8-23 sign-exponent-mantissa, with 127 exponent bias.
     U32 sem = bit_pun<U32>(f),
@@ -221,6 +223,9 @@ SI U64 swap_endian_16x4(const U64& rgba) {
 #if defined(USING_NEON)
     SI F min_(F x, F y) { return (F)vminq_f32((float32x4_t)x, (float32x4_t)y); }
     SI F max_(F x, F y) { return (F)vmaxq_f32((float32x4_t)x, (float32x4_t)y); }
+#elif defined(__loongarch_sx)
+    SI F min_(F x, F y) { return (F)__lsx_vfmin_s(x, y); }
+    SI F max_(F x, F y) { return (F)__lsx_vfmax_s(x, y); }
 #else
     SI F min_(F x, F y) { return if_then_else(x > y, y, x); }
     SI F max_(F x, F y) { return if_then_else(x < y, y, x); }
@@ -241,6 +246,8 @@ SI F floor_(F x) {
     return __builtin_ia32_roundps256(x, 0x01/*_MM_FROUND_FLOOR*/);
 #elif defined(__SSE4_1__)
     return _mm_floor_ps(x);
+#elif defined(__loongarch_sx)
+    return __lsx_vfrintrm_s((__m128)x);
 #else
     // Round trip through integers with a truncating cast.
     F roundtrip = cast<F>(cast<I32>(x));
@@ -638,7 +645,7 @@ SI void sample_clut_8(const uint8_t* grid_8, I32 ix, F* r, F* g, F* b, F* a) {
 }
 
 SI void sample_clut_16(const uint8_t* grid_16, I32 ix, F* r, F* g, F* b) {
-#if defined(__arm__)
+#if defined(__arm__) || defined(__loongarch_sx)
     // This is up to 2x faster on 32-bit ARM than the #else-case fast path.
     *r = F_from_U16_BE(gather_16(grid_16, 3*ix+0));
     *g = F_from_U16_BE(gather_16(grid_16, 3*ix+1));
@@ -755,9 +762,14 @@ static void clut(const skcms_B2A* b2a, F* r, F* g, F* b, F* a) {
          r,g,b,a);
 }
 
+typedef union {
+    unsigned int ii;
+    float ff;
+} temp_float_int;
 static void exec_ops(const Op* ops, const void** args,
                      const char* src, char* dst, int i) {
     F r = F0, g = F0, b = F0, a = F1;
+    temp_float_int temp_uf;
     while (true) {
         switch (*ops++) {
             case Op_load_a8:{
@@ -811,12 +823,38 @@ static void exec_ops(const Op* ops, const void** args,
             } break;
 
             case Op_load_8888:{
+#if defined(__loongarch_sx)
+                char * temp_src = (char*)src + i*4;
+                temp_uf.ff = 1/255.0f;
+                U32 rgba = __lsx_vld(temp_src, 0);
+                v4i32 temp_ff = __lsx_vldi(0x8ff);
+                v4i32 invert255 = __lsx_vreplgr2vr_w(temp_uf.ii);
+
+                r = __lsx_vand_v(rgba, temp_ff);
+                r = __lsx_vffint_s_wu(r);
+                r = __lsx_vfmul_s(r, invert255);
+
+                g = __lsx_vsrli_w(rgba, 0x8);
+                g = __lsx_vand_v(g, temp_ff);
+                g = __lsx_vffint_s_wu(g);
+                g = __lsx_vfmul_s(g, invert255);
+
+                b = __lsx_vsrli_w(rgba, 0x10);
+                b = __lsx_vand_v(b, temp_ff);
+                b = __lsx_vffint_s_wu(b);
+                b = __lsx_vfmul_s(b, invert255);
+
+                a = __lsx_vsrli_w(rgba, 0x18);
+                a = __lsx_vffint_s_wu(a);
+                a = __lsx_vfmul_s(a, invert255);
+#else
                 U32 rgba = load<U32>(src + 4*i);
 
                 r = cast<F>((rgba >>  0) & 0xff) * (1/255.0f);
                 g = cast<F>((rgba >>  8) & 0xff) * (1/255.0f);
                 b = cast<F>((rgba >> 16) & 0xff) * (1/255.0f);
                 a = cast<F>((rgba >> 24) & 0xff) * (1/255.0f);
+#endif
             } break;
 
             case Op_load_8888_palette8:{
@@ -1065,6 +1103,23 @@ static void exec_ops(const Op* ops, const void** args,
             } break;
 
             case Op_lab_to_xyz:{
+#if defined(__loongarch_sx)
+                temp_uf.ff = 100.0f;
+                F temp_100 = __lsx_vreplgr2vr_w(temp_uf.ii);
+                temp_uf.ff = -128.0f;
+                F temp_128 = __lsx_vreplgr2vr_w(temp_uf.ii);
+                temp_uf.ff = 255.0f;
+                F temp_255 = __lsx_vreplgr2vr_w(temp_uf.ii);
+                F L = __lsx_vfmul_s(r, temp_100);
+                F A = __lsx_vfmadd_s(g, temp_255, temp_128);
+                F B = __lsx_vfmadd_s(b, temp_255, temp_128);
+
+                F Y = (L + 16.0f) * (1/116.0f);
+                temp_uf.ff = 1/500.0f;
+                F temp_500 = __lsx_vreplgr2vr_w(temp_uf.ii);
+                F X = __lsx_vfmadd_s(A, temp_500, Y);
+                F Z = Y - B*(1/200.0f);
+#else
                 // The L*a*b values are in r,g,b, but normalized to [0,1].  Reconstruct them:
                 F L = r * 100.0f,
                   A = g * 255.0f - 128.0f,
@@ -1074,6 +1129,7 @@ static void exec_ops(const Op* ops, const void** args,
                 F Y = (L + 16.0f) * (1/116.0f),
                   X = Y + A*(1/500.0f),
                   Z = Y - B*(1/200.0f);
+#endif
 
                 X = if_then_else(X*X*X > 0.008856f, X*X*X, (X - (16/116.0f)) * (1/7.787f));
                 Y = if_then_else(Y*Y*Y > 0.008856f, Y*Y*Y, (Y - (16/116.0f)) * (1/7.787f));
@@ -1389,6 +1445,8 @@ static void exec_ops(const Op* ops, const void** args,
 static void run_program(const Op* program, const void** arguments,
                         const char* src, char* dst, int n,
                         const size_t src_bpp, const size_t dst_bpp) {
+    //Print the icc ops from src to dst.
+    //int a; for(a=0; a<32; a++) {  printf("%d\t", program[a]); } printf("\n");
     int i = 0;
     while (n >= N) {
         exec_ops(program, arguments, src, dst, i);
diff --git a/third_party/skia/src/base/SkVx.h b/third_party/skia/src/base/SkVx.h
index 23dc579827..257975ed74 100644
--- a/third_party/skia/src/base/SkVx.h
+++ b/third_party/skia/src/base/SkVx.h
@@ -34,6 +34,7 @@
 // The gn build has no option which sets SKNX_NO_SIMD.
 // Use SKVX_USE_SIMD internally to avoid confusing double negation.
 // Do not use 'defined' in a macro expansion.
+//#define SKNX_NO_SIMD true
 #if !defined(SKNX_NO_SIMD)
     #define SKVX_USE_SIMD 1
 #else
@@ -47,6 +48,8 @@
         #include <arm_neon.h>
     #elif defined(__wasm_simd128__)
         #include <wasm_simd128.h>
+    #elif defined(__loongarch_sx)
+        #include <lsxintrin.h>
     #endif
 #endif
 
@@ -68,6 +71,7 @@
 namespace skvx {
 
 template <int N, typename T>
+//N*sizeof(T) align, just Vec declare，defined by 'struct alignas(N*sizeof(T)) Vec : public VecStorage<N,T>'
 struct alignas(N*sizeof(T)) Vec;
 
 template <int... Ix, int N, typename T>
@@ -498,6 +502,13 @@ SINT Vec<N,T> if_then_else(const Vec<N,M<T>>& cond, const Vec<N,T>& t, const Vec
                                               sk_bit_cast<uint8x16_t>(t),
                                               sk_bit_cast<uint8x16_t>(e)));
     }
+#endif
+#if SKVX_USE_SIMD && defined(__loongarch_sx)
+    if constexpr (N*sizeof(T) == 16) {
+        return sk_bit_cast<Vec<N,T>>(__lsx_vbitsel_v(sk_bit_cast<__m128i>(e),
+                                          sk_bit_cast<__m128i>(t),
+                                          sk_bit_cast<__m128i>(cond)));
+    }
 #endif
     // Recurse for large vectors to try to hit the specializations above.
     if constexpr (N*sizeof(T) > 16) {
@@ -541,6 +552,12 @@ SINT bool any(const Vec<N,T>& x) {
     if constexpr (N == 4 && sizeof(T) == 4) {
         return wasm_i32x4_any_true(sk_bit_cast<VExt<4,int>>(x));
     }
+#endif
+#if SKVX_USE_SIMD && defined(__loongarch_sx)
+    if constexpr (N*sizeof(T) == 16) {
+	    v4i32 retv = (v4i32)__lsx_vmskltz_w(__lsx_vslt_wu(__lsx_vreplgr2vr_w(0), sk_bit_cast<__m128i>(x)));
+	    return retv[0] != 0b0000;
+    }
 #endif
     return any(x.lo)
         || any(x.hi);
@@ -570,6 +587,12 @@ SINT bool all(const Vec<N,T>& x) {
     if constexpr (N == 4 && sizeof(T) == 4) {
         return wasm_i32x4_all_true(sk_bit_cast<VExt<4,int>>(x));
     }
+#endif
+#if SKVX_USE_SIMD && defined(__loongarch_sx)
+    if constexpr (N*sizeof(T) == 16) {
+	    v4i32 retv = (v4i32)__lsx_vmskltz_w(__lsx_vslt_wu(__lsx_vreplgr2vr_w(0), sk_bit_cast<__m128i>(x)));
+	    return retv[0] == 0b1111;
+    }
 #endif
     return all(x.lo)
         && all(x.hi);
@@ -679,6 +702,11 @@ SIN Vec<N,int> lrint(const Vec<N,float>& x) {
     if constexpr (N == 4) {
         return sk_bit_cast<Vec<N,int>>(_mm_cvtps_epi32(sk_bit_cast<__m128>(x)));
     }
+#endif
+#if SKVX_USE_SIMD && defined(__loongarch_sx)
+    if constexpr (N == 4) {
+        return sk_bit_cast<Vec<N,int>>(__lsx_vftint_w_s(sk_bit_cast<__m128>(x)));
+    }
 #endif
     return join(lrint(x.lo),
                 lrint(x.hi));
@@ -756,13 +784,15 @@ SIN Vec<N,uint8_t> approx_scale(const Vec<N,uint8_t>& x, const Vec<N,uint8_t>& y
 // saturated_add(x,y) sums values and clamps to the maximum value instead of overflowing.
 SINT std::enable_if_t<std::is_unsigned_v<T>, Vec<N,T>> saturated_add(const Vec<N,T>& x,
                                                                      const Vec<N,T>& y) {
-#if SKVX_USE_SIMD && (SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE1 || defined(SK_ARM_HAS_NEON))
+#if SKVX_USE_SIMD && (SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE1 || defined(SK_ARM_HAS_NEON) || defined(__loongarch_sx))
     // Both SSE and ARM have 16-lane saturated adds, so use intrinsics for those and recurse down
     // or join up to take advantage.
     if constexpr (N == 16 && sizeof(T) == 1) {
         #if SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE1
         return sk_bit_cast<Vec<N,T>>(_mm_adds_epu8(sk_bit_cast<__m128i>(x),
                                                    sk_bit_cast<__m128i>(y)));
+        #elif defined(__loongarch_sx)
+        return sk_bit_cast<Vec<N,T>>(__lsx_vsadd_bu(sk_bit_cast<__m128i>(x), sk_bit_cast<__m128i>(y)));
         #else  // SK_ARM_HAS_NEON
         return sk_bit_cast<Vec<N,T>>(vqaddq_u8(sk_bit_cast<uint8x16_t>(x),
                                                sk_bit_cast<uint8x16_t>(y)));
@@ -802,6 +832,7 @@ public:
             : fDivisorFactor{(uint32_t)(std::round((1.0 / divisor) * (1ull << 32)))}
             , fHalf{(divisor + 1) >> 1} {
         assert(divisor > 1);
+        fSimdDivisorFactor = fDivisorFactor;
     }
 
     Vec<4, uint32_t> divide(const Vec<4, uint32_t>& numerator) const {
@@ -810,6 +841,10 @@ public:
         uint64x2_t lo = vmull_n_u32(vget_low_u32(to_vext(numerator)),  fDivisorFactor);
 
         return to_vec<4, uint32_t>(vcombine_u32(vshrn_n_u64(lo,32), vshrn_n_u64(hi,32)));
+//#elif SKVX_USE_SIMD && defined(__loongarch_sx)
+//        v4u32 divisorFactor = __lsx_vreplgr2vr_w(fDivisorFactor);
+//        return to_vec<4, uint32_t>(__lsx_vmuh_w(to_vext(numerator), divisorFactor));
+//        //return bit_pun<Vec<8,uint16_t>>(__lsx_vmuh_hu(bit_pun<__m128i>(x), bit_pun<__m128i>(y)));
 #else
         return cast<uint32_t>((cast<uint64_t>(numerator) * fDivisorFactor) >> 32);
 #endif
@@ -817,6 +852,7 @@ public:
 
     uint32_t half() const { return fHalf; }
 
+    uint32_t fSimdDivisorFactor;
 private:
     const uint32_t fDivisorFactor;
     const uint32_t fHalf;
@@ -867,6 +903,14 @@ SIN Vec<N,uint16_t> mulhi(const Vec<N,uint16_t>& x,
     } else { // N > 8
         return join(mulhi(x.lo, y.lo), mulhi(x.hi, y.hi));
     }
+#elif SKVX_USE_SIMD && defined(__loongarch_sx)
+    if constexpr (N == 8) {
+        return sk_bit_cast<Vec<8,uint16_t>>(__lsx_vmuh_hu(sk_bit_cast<__m128i>(x), sk_bit_cast<__m128i>(y)));
+    } else if constexpr (N < 8) {
+        return mulhi(join(x,x), join(y,y)).lo;
+    } else { // N > 8
+        return join(mulhi(x.lo, y.lo), mulhi(x.hi, y.hi));
+    }
 #else
     return skvx::cast<uint16_t>(mull(x, y) >> 16);
 #endif
@@ -985,6 +1029,35 @@ SI void strided_load4(const float* v,
     c = sk_bit_cast<Vec<4,float>>(c_);
     d = sk_bit_cast<Vec<4,float>>(d_);
 }
+#elif SKVX_USE_SIMD && defined(__loongarch_sx)
+
+#define _LSX_TRANSPOSE4(row0, row1, row2, row3)       \
+do {                                                    \
+    __m128i __t0 = __lsx_vilvl_w (row1, row0);    \
+    __m128i __t1 = __lsx_vilvl_w (row3, row2);    \
+    __m128i __t2 = __lsx_vilvh_w (row1, row0);    \
+    __m128i __t3 = __lsx_vilvh_w (row3, row2);    \
+    (row0) = __lsx_vilvl_d (__t1, __t0);         \
+    (row1) = __lsx_vilvh_d (__t1, __t0);         \
+    (row2) = __lsx_vilvl_d (__t3, __t2);         \
+    (row3) = __lsx_vilvh_d (__t3, __t2);         \
+} while (0)
+
+SI void strided_load4(const int* v,
+                      Vec<4,int>& a,
+                      Vec<4,int>& b,
+                      Vec<4,int>& c,
+                      Vec<4,int>& d) {
+    __m128i a_ = __lsx_vld(v, 0);
+    __m128i b_ = __lsx_vld(v, 16);
+    __m128i c_ = __lsx_vld(v, 32);
+    __m128i d_ = __lsx_vld(v, 48);
+    _LSX_TRANSPOSE4(a_, b_, c_, d_);
+    a = sk_bit_cast<Vec<4,int>>(a_);
+    b = sk_bit_cast<Vec<4,int>>(b_);
+    c = sk_bit_cast<Vec<4,int>>(c_);
+    d = sk_bit_cast<Vec<4,int>>(d_);
+}
 #endif
 
 // De-interleaving load of 2 vectors.
diff --git a/third_party/skia/src/core/SkBlitRow_D32.cpp b/third_party/skia/src/core/SkBlitRow_D32.cpp
index baa2638dc8..74d042497e 100644
--- a/third_party/skia/src/core/SkBlitRow_D32.cpp
+++ b/third_party/skia/src/core/SkBlitRow_D32.cpp
@@ -277,6 +277,143 @@ static void blit_row_s32_opaque(SkPMColor* dst,
         }
     }
 
+#elif defined(SK_LA_HAS_LASX)
+    //TODO
+    //In order to compatible with 2k2000, disable it temporarily and replace
+    //it with lsx in the feture.
+    #include <lasxintrin.h>
+    #include <lasxintrin.h>
+    #include<stdio.h>
+    #define LASX_LD(psrc) *((__m256i *)(psrc))
+    #define LASX_ST(in, pdst) *((__m256i *)(pdst)) = (in)
+    /* Create a selector for use with the SHUFPS instruction.  */
+    #define _MM_SHUFFLE(fp3,fp2,fp1,fp0) \
+         (((fp3) << 6) | ((fp2) << 4) | ((fp1) << 2) | (fp0))
+
+    static inline __m256i SkPMLerp_LASX(const __m256i& src,
+                                        const __m256i& dst,
+                                        const unsigned src_scale) {
+        // Computes dst + (((src - dst)*src_scale)>>8)
+        unsigned int value  = 0x00FF00FF;
+        const __m256i mask = __lasx_xvldrepl_w(&value, 0);
+
+        // Unpack the 16x8-bit source into 2 8x16-bit splayed halves.
+        __m256i src_rb = __lasx_xvand_v(mask, src);
+        __m256i src_ag = __lasx_xvsrli_h(src, 8);
+        __m256i dst_rb = __lasx_xvand_v(mask, dst);
+        __m256i dst_ag = __lasx_xvsrli_h(dst, 8);
+
+        // Compute scaled differences.
+        __m256i diff_rb = __lasx_xvsub_h(src_rb, dst_rb);
+        __m256i diff_ag = __lasx_xvsub_h(src_ag, dst_ag);
+        __m256i s = __lasx_xvldrepl_h(&src_scale, 0);
+        diff_rb = __lasx_xvmul_h(diff_rb, s);
+        diff_ag = __lasx_xvmul_h(diff_ag, s);
+
+        // Pack the differences back together.
+        diff_rb = __lasx_xvsrli_h(diff_rb, 8);
+        diff_ag = __lasx_xvandn_v(mask, diff_ag);
+        __m256i diff = __lasx_xvor_v(diff_rb, diff_ag);
+
+        // Add difference to destination.
+        return __lasx_xvadd_b(dst, diff);
+    }
+
+    static void blit_row_s32_blend(SkPMColor* dst, const SkPMColor* src, int count, U8CPU alpha) {
+        //printf("%s==%s==%d\n",__FILE__,__func__,__LINE__);
+        SkASSERT(alpha <= 255);
+
+        auto src8 = (const __m256i*)src;
+        auto dst8 = (      __m256i*)dst;
+
+        while (count >= 8) {
+            LASX_ST(SkPMLerp_LASX(LASX_LD(src8),
+                                                 LASX_LD(dst8),
+                                                 SkAlpha255To256(alpha)), dst8);
+            src8++;
+            dst8++;
+            count -= 8;
+        }
+
+        src = (const SkPMColor*)src8;
+        dst = (      SkPMColor*)dst8;
+
+        while (count --> 0) {
+            *dst = SkPMLerp(*src, *dst, SkAlpha255To256(alpha));
+            src++;
+            dst++;
+        }
+    }
+
+    static inline __m256i SkBlendARGB32_LASX(const __m256i& src,
+                                             const __m256i& dst,
+                                             const unsigned aa) {
+        unsigned alpha = SkAlpha255To256(aa);
+        __m256i src_scale = __lasx_xvldrepl_h(&alpha, 0);
+        // SkAlphaMulInv256(SkGetPackedA32(src), src_scale)
+        __m256i dst_scale = __lasx_xvsrli_w(src, 24);
+        // High words in dst_scale are 0, so it's safe to multiply with 16-bit src_scale.
+        dst_scale = __lasx_xvmul_h(dst_scale, src_scale);
+        unsigned int tmp  = 0XFFFF;
+        dst_scale = __lasx_xvsub_w(__lasx_xvldrepl_w(&tmp, 0), dst_scale);
+        dst_scale = __lasx_xvadd_w(dst_scale, __lasx_xvsrli_w(dst_scale, 8));
+        dst_scale = __lasx_xvsrli_w(dst_scale, 8);
+        // Duplicate scales into 2x16-bit pattern per pixel.
+        //dst_scale = _mm_shufflelo_epi16(dst_scale, _MM_SHUFFLE(2, 2, 0, 0));
+        //dst_scale = _mm_shufflehi_epi16(dst_scale, _MM_SHUFFLE(2, 2, 0, 0));
+        dst_scale = __lasx_xvshuf4i_h(dst_scale, _MM_SHUFFLE(2, 2, 0, 0));
+
+        tmp = 0x00FF00FF;
+        const __m256i mask = __lasx_xvldrepl_h(&tmp, 0);
+
+        // Unpack the 16x8-bit source/destination into 2 8x16-bit splayed halves.
+        __m256i src_rb = __lasx_xvand_v(mask, src);
+        __m256i src_ag = __lasx_xvsrli_h(src, 8);
+        __m256i dst_rb = __lasx_xvand_v(mask, dst);
+        __m256i dst_ag = __lasx_xvsrli_h(dst, 8);
+
+        // Scale them.
+        src_rb = __lasx_xvmul_h(src_rb, src_scale);
+        src_ag = __lasx_xvmul_h(src_ag, src_scale);
+        dst_rb = __lasx_xvmul_h(dst_rb, dst_scale);
+        dst_ag = __lasx_xvmul_h(dst_ag, dst_scale);
+
+        // Add the scaled source and destination.
+        dst_rb = __lasx_xvadd_h(src_rb, dst_rb);
+        dst_ag = __lasx_xvadd_h(src_ag, dst_ag);
+
+        // Unsplay the halves back together.
+        dst_rb = __lasx_xvsrli_h(dst_rb, 8);
+        dst_ag = __lasx_xvandn_v(mask, dst_ag);
+        return __lasx_xvor_v(dst_rb, dst_ag);
+    }
+
+    static void blit_row_s32a_blend(SkPMColor* dst, const SkPMColor* src, int count, U8CPU alpha) {
+        //printf("%s==%s==%d\n",__FILE__,__func__,__LINE__);
+        SkASSERT(alpha <= 255);
+
+        auto src8 = (const __m256i*)src;
+        auto dst8 = (      __m256i*)dst;
+
+        while (count >= 8) {
+            LASX_ST(SkBlendARGB32_LASX(LASX_LD(src8),
+                                                      LASX_LD(dst8),
+                                                      alpha), dst8);
+            src8++;
+            dst8++;
+            count -= 8;
+        }
+
+        src = (const SkPMColor*)src8;
+        dst = (      SkPMColor*)dst8;
+
+        while (count --> 0) {
+            *dst = SkBlendARGB32(*src, *dst, alpha);
+            src++;
+            dst++;
+        }
+    }
+
 #else
     static void blit_row_s32_blend(SkPMColor* dst, const SkPMColor* src, int count, U8CPU alpha) {
         SkASSERT(alpha <= 255);
diff --git a/third_party/skia/src/core/SkBlitter_ARGB32.cpp b/third_party/skia/src/core/SkBlitter_ARGB32.cpp
index 3dc4f95f78..86ecea6875 100644
--- a/third_party/skia/src/core/SkBlitter_ARGB32.cpp
+++ b/third_party/skia/src/core/SkBlitter_ARGB32.cpp
@@ -82,6 +82,7 @@ static inline SkPMColor blend_lcd16_opaque(int srcR, int srcG, int srcB,
         return dst;
     }
 
+    // In SIMD opt, this will not special attention and values always be 0xff000000.
     if (0xFFFF == mask) {
         return opaqueDst;
     }
@@ -588,6 +589,366 @@ static inline SkPMColor blend_lcd16_opaque(int srcR, int srcG, int srcB,
         }
     }
 
+#elif defined(SK_LA_HAS_LSX)
+    #include <lsxintrin.h>
+    // The following (left) shifts cause the top 5 bits of the mask components to
+    // line up with the corresponding components in an SkPMColor.
+    // Note that the mask's RGB16 order may differ from the SkPMColor order.
+    #define SK_R16x5_R32x5_SHIFT (SK_R32_SHIFT - SK_R16_SHIFT - SK_R16_BITS + 5) //5, Just think SK_R32_SHIFT=16
+    #define SK_G16x5_G32x5_SHIFT (SK_G32_SHIFT - SK_G16_SHIFT - SK_G16_BITS + 5) //2
+    #define SK_B16x5_B32x5_SHIFT (SK_B32_SHIFT - SK_B16_SHIFT - SK_B16_BITS + 5) //0
+
+    #if SK_R16x5_R32x5_SHIFT == 0
+        #define SkPackedR16x5ToUnmaskedR32x5_LSX(x) (x)
+    #elif SK_R16x5_R32x5_SHIFT > 0
+        #define SkPackedR16x5ToUnmaskedR32x5_LSX(x) (__lsx_vslli_w(x, SK_R16x5_R32x5_SHIFT))
+    #else
+        #define SkPackedR16x5ToUnmaskedR32x5_LSX(x) (__lsx_vsrli_h(x, -SK_R16x5_R32x5_SHIFT))
+    #endif
+
+    #if SK_G16x5_G32x5_SHIFT == 0
+        #define SkPackedR16x5ToUnmaskedR32x5_LSX(x) (x)
+    #elif SK_G16x5_G32x5_SHIFT > 0
+        #define SkPackedG16x5ToUnmaskedG32x5_LSX(x) (__lsx_vslli_w(x, SK_G16x5_G32x5_SHIFT))
+    #else
+        #define SkPackedG16x5ToUnmaskedG32x5_LSX(x) (__lsx_vsrli_w(x, -SK_G16x5_G32x5_SHIFT))
+    #endif
+
+    #if SK_B16x5_B32x5_SHIFT == 0
+        #define SkPackedB16x5ToUnmaskedB32x5_LSX(x) (x)
+    #elif SK_B16x5_B32x5_SHIFT > 0
+        #define SkPackedB16x5ToUnmaskedB32x5_LSX(x) (__lsx_vslli_w(x, SK_B16x5_B32x5_SHIFT))
+    #else
+        #define SkPackedB16x5ToUnmaskedB32x5_LSX(x) (__lsx_vsrli_w(x, -SK_B16x5_B32x5_SHIFT))
+    #endif
+    #define LSX_LD(psrc) *((__m128i *)(psrc))
+    #define LSX_ST(in, pdst) *((__m128i *)(pdst)) = (in)
+
+
+     static inline __m128i emulate_lsx_packus_h(__m128i lo, __m128i hi)
+     {
+        __m128i tmp0 = __lsx_vsat_hu(lo, 7);
+        __m128i tmp1 = __lsx_vsat_hu(hi, 7);
+        __m128i tmp2 =  __lsx_vpickev_b(tmp1, tmp0);
+        return tmp2;
+     }
+
+    static __m128i blend_lcd16_lsx(__m128i &src, __m128i &dst, __m128i &mask, __m128i &srcA) {
+        // In the following comments, the components of src, dst and mask are
+        // abbreviated as (s)rc, (d)st, and (m)ask. Color components are marked
+        // by an R, G, B, or A suffix. Components of one of the four pixels that
+        // are processed in parallel are marked with 0, 1, 2, and 3. "d1B", for
+        // example is the blue channel of the second destination pixel. Memory
+        // layout is shown for an ARGB byte order in a color value.
+
+        // src and srcA store 8-bit values interleaved with zeros.
+        // src  = (0xFF, 0, sR, 0, sG, 0, sB, 0, 0xFF, 0, sR, 0, sG, 0, sB, 0)
+        // srcA = (srcA, 0, srcA, 0, srcA, 0, srcA, 0,
+        //         srcA, 0, srcA, 0, srcA, 0, srcA, 0)
+        // mask stores 16-bit values (compressed three channels) interleaved with zeros.
+        // Lo and Hi denote the low and high bytes of a 16-bit value, respectively.
+        // mask = (m0RGBLo, m0RGBHi, 0, 0, m1RGBLo, m1RGBHi, 0, 0,
+        //         m2RGBLo, m2RGBHi, 0, 0, m3RGBLo, m3RGBHi, 0, 0)
+
+        // Get the R,G,B of each 16bit mask pixel, we want all of them in 5 bits.
+        // r = (0, m0R, 0, 0, 0, m1R, 0, 0, 0, m2R, 0, 0, 0, m3R, 0, 0)
+        unsigned int sk_r32 = 0x1F << SK_R32_SHIFT;
+        __m128i r = __lsx_vand_v(SkPackedR16x5ToUnmaskedR32x5_LSX(mask),
+                                  __lsx_vldrepl_w(&sk_r32, 0));
+
+        // g = (0, 0, m0G, 0, 0, 0, m1G, 0, 0, 0, m2G, 0, 0, 0, m3G, 0)
+        unsigned int sk_g32 = 0x1F << SK_G32_SHIFT;
+        __m128i g = __lsx_vand_v(SkPackedG16x5ToUnmaskedG32x5_LSX(mask),
+                                  __lsx_vldrepl_w(&sk_g32, 0));
+
+        // b = (0, 0, 0, m0B, 0, 0, 0, m1B, 0, 0, 0, m2B, 0, 0, 0, m3B)
+        unsigned int sk_b32 = 0x1F << SK_B32_SHIFT;
+        __m128i b = __lsx_vand_v(SkPackedB16x5ToUnmaskedB32x5_LSX(mask),
+                                  __lsx_vldrepl_w(&sk_b32,0));
+
+        // Pack the 4 16bit mask pixels into 4 32bit pixels, (p0, p1, p2, p3)
+        // Each component (m0R, m0G, etc.) is then a 5-bit value aligned to an
+        // 8-bit position
+        // mask = (0, m0R, m0G, m0B, 0, m1R, m1G, m1B,
+        //         0, m2R, m2G, m2B, 0, m3R, m3G, m3B)
+        mask = __lsx_vor_v(__lsx_vor_v(r, g), b);
+
+        // Interleave R,G,B into the lower byte of word.
+        // i.e. split the sixteen 8-bit values from mask into two sets of eight
+        // 16-bit values, padded by zero.
+        __m128i maskLo, maskHi;
+        // maskLo = (0, 0, m0R, 0, m0G, 0, m0B, 0, 0, 0, m1R, 0, m1G, 0, m1B, 0)
+        maskLo = __lsx_vilvl_b(__lsx_vldi(0), mask);
+        // maskHi = (0, 0, m2R, 0, m2G, 0, m2B, 0, 0, 0, m3R, 0, m3G, 0, m3B, 0)
+        maskHi = __lsx_vilvh_b(__lsx_vldi(0), mask);
+
+        // Upscale from 0..31 to 0..32
+        // (allows to replace division by left-shift further down)
+        // Left-shift each component by 4 and add the result back to that component,
+        // mapping numbers in the range 0..15 to 0..15, and 16..31 to 17..32
+        maskLo = __lsx_vadd_h(maskLo, __lsx_vsrli_h(maskLo, 4));
+        maskHi = __lsx_vadd_h(maskHi, __lsx_vsrli_h(maskHi, 4));
+
+        // Multiply each component of maskLo and maskHi by srcA
+        maskLo = __lsx_vmul_h(maskLo, srcA);
+        maskHi = __lsx_vmul_h(maskHi, srcA);
+
+        // Left shift mask components by 8 (divide by 256)
+        maskLo = __lsx_vsrli_h(maskLo, 8);
+        maskHi = __lsx_vsrli_h(maskHi, 8);
+
+        // Interleave R,G,B into the lower byte of the word
+        // dstLo = (0, 0, d0R, 0, d0G, 0, d0B, 0, 0, 0, d1R, 0, d1G, 0, d1B, 0)
+        __m128i dstLo = __lsx_vilvl_b(__lsx_vldi(0), dst);
+        // dstLo = (0, 0, d2R, 0, d2G, 0, d2B, 0, 0, 0, d3R, 0, d3G, 0, d3B, 0)
+        __m128i dstHi = __lsx_vilvh_b(__lsx_vldi(0), dst);
+
+        // mask = (src - dst) * mask
+        maskLo = __lsx_vmul_h(maskLo, __lsx_vsub_h(src, dstLo));
+        maskHi = __lsx_vmul_h(maskHi, __lsx_vsub_h(src, dstHi));
+
+        // mask = (src - dst) * mask >> 5
+        maskLo = __lsx_vsrai_h(maskLo, 5);
+        maskHi = __lsx_vsrai_h(maskHi, 5);
+
+        // Add two pixels into result.
+        // result = dst + ((src - dst) * mask >> 5)
+        __m128i resultLo = __lsx_vadd_h(dstLo, maskLo);
+        __m128i resultHi = __lsx_vadd_h(dstHi, maskHi);
+
+        // Pack into 4 32bit dst pixels.
+        // resultLo and resultHi contain eight 16-bit components (two pixels) each.
+        // Merge into one SSE regsiter with sixteen 8-bit values (four pixels),
+        // clamping to 255 if necessary.
+        return  emulate_lsx_packus_h(resultLo, resultHi);
+    }
+    static __m128i blend_lcd16_opaque_lsx(__m128i &src, __m128i &dst, __m128i &mask) {
+        // src store 8-bit values interleaved with zeros.
+        // src  = (0xFF, 0, sR, 0, sG, 0, sB, 0, 0xFF, 0, sR, 0, sG, 0, sB, 0)
+        // mask stores 16-bit values interleaved with zeros
+        // mask = (m0, 0, m1, 0, m2, 0, m3, 0)
+
+        // Get the R,G,B of each 16bit mask pixel, we want all of them in 5 bits.
+        // int maskR = SkGetPackedR16(mask) >> (SK_R16_BITS - 5);
+        // r = (0, m0R, 0, 0, 0, m1R, 0, 0, 0, m2R, 0, 0, 0, m3R, 0, 0)
+        unsigned int sk_r32 = 0x1F << SK_R32_SHIFT;
+        __m128i r = __lsx_vand_v(SkPackedR16x5ToUnmaskedR32x5_LSX(mask),
+                                  __lsx_vldrepl_w(&sk_r32, 0));
+
+        // int maskG = SkGetPackedG16(mask) >> (SK_G16_BITS - 5);
+        // g = (0, 0, m0G, 0, 0, 0, m1G, 0, 0, 0, m2G, 0, 0, 0, m3G, 0)
+        // maskG = SkGetPackedG16(mask) >> (SK_G16_BITS - 5) == SkGetPackedG16(mask) >>1,
+        // so the highest 5bit for G channel is useful, so here is 0x1F also.
+        unsigned int sk_g32 = 0x1F << SK_G32_SHIFT;
+        __m128i g = __lsx_vand_v(SkPackedG16x5ToUnmaskedG32x5_LSX(mask),
+                                  __lsx_vldrepl_w(&sk_g32, 0));
+
+        //int maskB = SkGetPackedB16(mask) >> (SK_B16_BITS - 5);
+        // b = (0, 0, 0, m0B, 0, 0, 0, m1B, 0, 0, 0, m2B, 0, 0, 0, m3B)
+        unsigned int sk_b32 = 0x1F << SK_B32_SHIFT;
+        __m128i b = __lsx_vand_v(SkPackedB16x5ToUnmaskedB32x5_LSX(mask),
+                                  __lsx_vldrepl_w(&sk_b32, 0));
+
+        // Pack the 4 16bit mask pixels into 4 32bit pixels
+        // mask = (0, m0R, m0G, m0B, 0, m1R, m1G, m1B,
+        //         0, m2R, m2G, m2B, 0, m3R, m3G, m3B)
+        __m128i mask_rgb = __lsx_vor_v(__lsx_vor_v(r, g), b);
+
+        // split the sixteen 8-bit values from mask into two sets of eight
+        // 16-bit values, padded by zero.
+        __m128i maskLo, maskHi;
+        // maskLo = (0, 0, m0R, 0, m0G, 0, m0B, 0, 0, 0, m1R, 0, m1G, 0, m1B, 0)
+        maskLo = __lsx_vilvl_b(__lsx_vldi(0), mask_rgb);
+        // maskHi = (0, 0, m2R, 0, m2G, 0, m2B, 0, 0, 0, m3R, 0, m3G, 0, m3B, 0)
+        maskHi = __lsx_vilvh_b(__lsx_vldi(0), mask_rgb);
+
+        // Upscale from 0..31 to 0..32
+        maskLo = __lsx_vadd_h(maskLo, __lsx_vsrli_h(maskLo, 4));
+        maskHi = __lsx_vadd_h(maskHi, __lsx_vsrli_h(maskHi, 4));
+
+        // Interleave R,G,B into the lower byte of the word
+        // dstLo = (0, 0, d0R, 0, d0G, 0, d0B, 0, 0, 0, d1R, 0, d1G, 0, d1B, 0)
+        __m128i dstLo = __lsx_vilvl_b(__lsx_vldi(0), dst);
+        // dstHi = (0, 0, d2R, 0, d2G, 0, d2B, 0, 0, 0, d3R, 0, d3G, 0, d3B, 0)
+        __m128i dstHi = __lsx_vilvh_b(__lsx_vldi(0), dst);
+
+        // mask = (src - dst) * mask
+        maskLo = __lsx_vmul_h(maskLo, __lsx_vsub_h(src, dstLo));
+        maskHi = __lsx_vmul_h(maskHi, __lsx_vsub_h(src, dstHi));
+
+        // mask = (src - dst) * mask >> 5
+        maskLo = __lsx_vsrai_h(maskLo, 5);
+        maskHi = __lsx_vsrai_h(maskHi, 5);
+
+        // result = dst + ((src - dst) * mask >> 5)
+        __m128i resultLo = __lsx_vadd_h(dstLo, maskLo);
+        __m128i resultHi = __lsx_vadd_h(dstHi, maskHi);
+
+        // Pack into 4 32bit dst pixels and force opaque.
+        // resultLo and resultHi contain eight 16-bit components (two pixels) each.
+        // Merge into one LSX regsiter with sixteen 8-bit values (four pixels),
+        // clamping to 255 if necessary. Set alpha components to 0xFF.
+
+        unsigned int sk_a32 = SK_A32_MASK << SK_A32_SHIFT;
+
+#if 0 // same with x86, simple but testcases failed.
+        return __lsx_vor_v(emulate_lsx_packus_h(resultLo, resultHi),
+                            (__lsx_vldrepl_w(&sk_a32, 0)));
+#else // Test case friendly.
+        __m128i zero = __lsx_vldi(0);
+        // This should use mask and lead savelayerpreservelcdtext test passed.
+        v4i32 i = __lsx_vseq_w(mask, zero);
+        v4i32 one = {-1, -1, -1, -1};
+        i = (v4i32)__lsx_vxor_v(i, one);
+        return __lsx_vor_v(emulate_lsx_packus_h(resultLo, resultHi),
+                            (__lsx_vand_v(i, __lsx_vldrepl_w(&sk_a32, 0))));
+#endif
+    }
+
+    void blit_row_lcd16(SkPMColor dst[], const uint16_t mask[], SkColor src, int width, SkPMColor) {
+        if (width <= 0) {
+            return;
+        }
+
+        int srcA = SkColorGetA(src);
+        int srcR = SkColorGetR(src);
+        int srcG = SkColorGetG(src);
+        int srcB = SkColorGetB(src);
+
+        srcA = SkAlpha255To256(srcA);
+
+        if (width >= 4) {
+            SkASSERT(((size_t)dst & 0x03) == 0);
+            while (((size_t)dst & 0x0F) != 0) {
+                *dst = blend_lcd16(srcA, srcR, srcG, srcB, *dst, *mask);
+                mask++;
+                dst++;
+                width--;
+            }
+
+            __m128i *d = reinterpret_cast<__m128i*>(dst);
+            // Set alpha to 0xFF and replicate source eight times in LSX register.
+            unsigned int skpackargb32 = SkPackARGB32(0xFF, srcR, srcG, srcB);
+            __m128i src_sse = __lsx_vldrepl_w(&skpackargb32, 0);
+            // Interleave with zeros to get two sets of eight 16-bit values.
+            // src_sse=(0xFF, 0, sR, 0, sG, 0, sB, 0, 0xFF, 0, sR, 0, sG, 0, sB, 0)
+            src_sse = __lsx_vilvl_b(__lsx_vldi(0), src_sse);
+            // Set srcA_lsx to contain eight copies of srcA, padded with zero.
+            __m128i srcA_lsx = __lsx_vldrepl_h(&srcA, 0);
+
+            while (width >= 4) {
+                // Load eight destination pixels into dst_lsx.
+                __m128i dst_lsx = LSX_LD(d);
+                // Load four 16-bit masks into lower half of mask_sse.
+                __m128i _vzero = __lsx_vldi(0);
+                __m128i mask_lsx = __lsx_vldrepl_d((void *)mask, 0);
+                mask_lsx =  __lsx_vilvl_d(_vzero, mask_lsx);
+
+                // Check whether masks are equal to 0 and get the highest bit
+                // of each byte of result, if masks are all zero, we will get
+                // pack_cmp to 0
+                int pack_cmp = __lsx_bz_v(__lsx_vsub_b(mask_lsx, __lsx_vldi(0)));
+
+                // if mask pixels are not all zero, we will blend the dst pixels
+                if (pack_cmp != 1) {
+                    // Unpack 4 16bit mask pixels to
+                    // mask_lsx = (m0RGBLo, m0RGBHi, 0, 0, m1RGBLo, m1RGBHi, 0, 0,
+                    //             m2RGBLo, m2RGBHi, 0, 0, m3RGBLo, m3RGBHi, 0, 0)
+                    mask_lsx = __lsx_vilvl_h(__lsx_vldi(0), mask_lsx);
+
+
+                    // Process 8 32bit dst pixels
+                    __m128i result = blend_lcd16_lsx(src_sse, dst_lsx, mask_lsx, srcA_lsx);
+                    LSX_ST(result, d);
+                }
+
+                d++;
+                mask += 4;
+                width -= 4;
+            }
+
+            dst = reinterpret_cast<SkPMColor*>(d);
+        }
+
+        while (width > 0) {
+            *dst = blend_lcd16(srcA, srcR, srcG, srcB, *dst, *mask);
+            mask++;
+            dst++;
+            width--;
+        }
+    }
+
+    static int _lsx_movemask_epi8(__m128i ia)
+    {
+        __m128i ib = __lsx_vmskltz_b(ia);
+        v4u32 retv = (v4u32)ib;
+        return retv[0];
+    }
+    void blit_row_lcd16_opaque(SkPMColor dst[], const uint16_t mask[],
+                                   SkColor src, int width, SkPMColor opaqueDst) {
+        if (width <= 0) {
+            return;
+        }
+
+        int srcR = SkColorGetR(src);
+        int srcG = SkColorGetG(src);
+        int srcB = SkColorGetB(src);
+
+        if (width >= 4) {
+            SkASSERT(((size_t)dst & 0x03) == 0);
+            while (((size_t)dst & 0x0F) != 0) {
+                *dst = blend_lcd16_opaque(srcR, srcG, srcB, *dst, *mask, opaqueDst);
+                mask++;
+                dst++;
+                width--;
+            }
+
+            __m128i _vzero = __lsx_vldi(0);
+            __m128i *d = reinterpret_cast<__m128i*>(dst);
+            // Set alpha to 0xFF and replicate source four times in LSX register.
+            unsigned int sk_pack_argb32 = SkPackARGB32(0xFF, srcR, srcG, srcB);
+            __m128i src_lsx = __lsx_vldrepl_w(&sk_pack_argb32, 0);
+            // src_lsx=(0xFF, 0, sR, 0, sG, 0, sB, 0, 0xFF, 0, sR, 0, sG, 0, sB, 0)
+            src_lsx = __lsx_vilvl_b(_vzero, src_lsx);
+
+            while (width >= 4) {
+                // Load four destination pixels into dst_lsx.
+                __m128i dst_lsx = LSX_LD(d);
+                // Load four 16-bit masks into lower half of mask_lsx.
+                __m128i mask_lsx = __lsx_vldrepl_d((void *)(mask), 0);
+                mask_lsx =  __lsx_vilvl_d(_vzero, mask_lsx);
+
+                // Check whether masks are equal to 0 and get the highest bit of each byte
+                // of result, if masks are all zero, we will get pack_cmp to 0xffff
+                int pack_cmp = _lsx_movemask_epi8(__lsx_vseq_h(mask_lsx, _vzero));
+
+                // if mask pixels are not all zero, we will blend the dst pixels
+                // 0xFFFF == mask also handled here.
+                if (pack_cmp != 0XFFFF) {
+                    // Unpack 4 16bit mask pixels to
+                    mask_lsx = __lsx_vilvl_h(_vzero, mask_lsx);
+
+                    // Process 8 32bit dst pixels
+                    __m128i result = blend_lcd16_opaque_lsx(src_lsx, dst_lsx, mask_lsx);
+                    LSX_ST(result, d);
+                }
+
+               d++;
+               mask += 4;
+               width -= 4;
+            }
+
+            dst = reinterpret_cast<SkPMColor*>(d);
+        }
+
+        while (width > 0) {
+            *dst = blend_lcd16_opaque(srcR, srcG, srcB, *dst, *mask, opaqueDst);
+            mask++;
+            dst++;
+            width--;
+        }
+    }
+
 #else
 
     static inline void blit_row_lcd16(SkPMColor dst[], const uint16_t mask[],
diff --git a/third_party/skia/src/core/SkCpu.cpp b/third_party/skia/src/core/SkCpu.cpp
index 8bc7700573..aef4327ed5 100644
--- a/third_party/skia/src/core/SkCpu.cpp
+++ b/third_party/skia/src/core/SkCpu.cpp
@@ -72,6 +72,43 @@
         }
         return features;
     }
+#elif defined(SK_CPU_LOONGARCH)
+    #define LOONGARCH_CFG2 0x2
+    #define LOONGARCH_CFG2_LSX    (1 << 6)
+    #define LOONGARCH_CFG2_LASX   (1 << 7)
+
+    extern "C" {
+        __attribute__((visibility("default")))
+        unsigned int gLoongsonCpuFeatureSkia = 0;
+     }
+
+    static uint32_t read_cpu_features(void)
+    {
+      uint32_t features = 0;
+      uint32_t reg = 0;
+
+      // Once users use '--disable-loongopt', ruturn directly.
+      if(SkCpu::DISABLE_LOONG64OPT == gLoongsonCpuFeatureSkia)
+          return 0;
+      if(0 != gLoongsonCpuFeatureSkia) { // has initialized in main process.
+          if (0x3 == gLoongsonCpuFeatureSkia)
+              features |= SkCpu::LOONGARCH_SX;
+          if (0x7 == gLoongsonCpuFeatureSkia)
+              features |= SkCpu::LOONGARCH_ASX;
+          return features;
+      }
+
+      __asm__ volatile(
+          "cpucfg %0, %1 \n\t"
+          : "+&r"(reg)
+          : "r"(LOONGARCH_CFG2)
+      );
+
+      if (reg & LOONGARCH_CFG2_LSX) {features |= SkCpu::LOONGARCH_SX; }
+      if (reg & LOONGARCH_CFG2_LASX) {features |= SkCpu::LOONGARCH_ASX; }
+      return features;
+    }
+
 #else
     static uint32_t read_cpu_features() {
         return 0;
diff --git a/third_party/skia/src/core/SkCpu.h b/third_party/skia/src/core/SkCpu.h
index 1cea053144..c94e76f14b 100644
--- a/third_party/skia/src/core/SkCpu.h
+++ b/third_party/skia/src/core/SkCpu.h
@@ -42,6 +42,12 @@ struct SkCpu {
         ERMS       = 1 << 20,
     };
 
+    enum {
+        LOONGARCH_SX = 1 << 0,
+        LOONGARCH_ASX = 1 << 1,
+        DISABLE_LOONG64OPT = 1 << 4,
+    };
+
     static void CacheRuntimeFeatures();
     static bool Supports(uint32_t);
 private:
@@ -94,6 +100,14 @@ inline bool SkCpu::Supports(uint32_t mask) {
     features &= (SSE1 | SSE2);
     #endif
 
+#elif SK_CPU_LOONGARCH
+    #if defined(SK_LA_HAS_LSX)
+    features |= LOONGARCH_SX;
+    #endif
+    #if defined(SK_LA_HAS_LASX)
+    features |= LOONGARCH_ASX;
+    #endif
+
 #endif
     return (features & mask) == mask;
 }
diff --git a/third_party/skia/src/core/SkOpts.cpp b/third_party/skia/src/core/SkOpts.cpp
index f998f33be2..38de9901dc 100644
--- a/third_party/skia/src/core/SkOpts.cpp
+++ b/third_party/skia/src/core/SkOpts.cpp
@@ -30,6 +30,10 @@
     #define SK_OPTS_NS sse2
 #elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE1
     #define SK_OPTS_NS sse
+#elif defined(SK_LA_HAS_LSX)
+    #define SK_OPTS_NS lsx
+#elif defined(SK_LA_HAS_LASX)
+    #define SK_OPTS_NS lasx
 #else
     #define SK_OPTS_NS portable
 #endif
@@ -102,6 +106,7 @@ namespace SkOpts {
     void Init_hsw();
     void Init_skx();
     void Init_erms();
+    void Init_lasx();
 
     static void init() {
     #if defined(SK_ENABLE_OPTIMIZE_SIZE)
@@ -121,6 +126,11 @@ namespace SkOpts {
         #endif
 
         if (SkCpu::Supports(SkCpu::ERMS)) { Init_erms(); }
+    #elif defined(SK_CPU_LOONGARCH)
+       #if defined(SK_LA_HAS_LSX)
+           //if (SkCpu::Supports(SkCpu::LOONGARCH_SX)) {Init_lsx(); }
+           if (SkCpu::Supports(SkCpu::LOONGARCH_ASX)) {Init_lasx(); }
+       #endif
     #endif
     }
 
diff --git a/third_party/skia/src/core/SkRasterPipeline.h b/third_party/skia/src/core/SkRasterPipeline.h
index dc5fb4b8f2..c771696cad 100644
--- a/third_party/skia/src/core/SkRasterPipeline.h
+++ b/third_party/skia/src/core/SkRasterPipeline.h
@@ -24,7 +24,7 @@ enum SkColorType : int;
 struct SkImageInfo;
 struct skcms_TransferFunction;
 
-#if __has_cpp_attribute(clang::musttail) && !defined(__EMSCRIPTEN__) && !defined(SK_CPU_ARM32)
+#if __has_cpp_attribute(clang::musttail) && !defined(__EMSCRIPTEN__) && !defined(SK_CPU_ARM32) && !defined(SK_CPU_LOONGARCH)
     #define SK_HAS_MUSTTAIL 1
 #else
     #define SK_HAS_MUSTTAIL 0
diff --git a/third_party/skia/src/effects/imagefilters/SkBlurImageFilter.cpp b/third_party/skia/src/effects/imagefilters/SkBlurImageFilter.cpp
index 3b6a918abc..f4e307ac72 100644
--- a/third_party/skia/src/effects/imagefilters/SkBlurImageFilter.cpp
+++ b/third_party/skia/src/effects/imagefilters/SkBlurImageFilter.cpp
@@ -419,6 +419,82 @@ private:
     //    buffer0[i] = leading edge
     void blurSegment(
             int n, const uint32_t* src, int srcStride, uint32_t* dst, int dstStride) override {
+#if defined(__loongarch_sx)
+        skvx::Vec<4, uint32_t>* buffer0Cursor = fBuffer0Cursor;
+        skvx::Vec<4, uint32_t>* buffer1Cursor = fBuffer1Cursor;
+        skvx::Vec<4, uint32_t>* buffer2Cursor = fBuffer2Cursor;
+        v4u32 sum0 = __lsx_vld(fSum0, 0); // same as skvx::Vec<4, uint32_t>::Load(fSum0);
+        v4u32 sum1 = __lsx_vld(fSum1, 0);
+        v4u32 sum2 = __lsx_vld(fSum2, 0);
+
+        auto processValue = [&](v4u32& vLeadingEdge){
+          sum0 += vLeadingEdge;
+          sum1 += sum0;
+          sum2 += sum1;
+
+          v4u32 divisorFactor = __lsx_vreplgr2vr_w(fDivider.fSimdDivisorFactor);
+          //v4u32 divisorFactor = __lsx_vreplgr2vr_w(fDivider.divisorFactor());
+          v4u32 blurred = __lsx_vmuh_w(divisorFactor, sum2);
+
+          v4u32 buffer2Value = __lsx_vld(buffer2Cursor, 0); //Not fBuffer0Cursor, out of bounds.
+          sum2 -= buffer2Value;
+          __lsx_vst(sum1, (void *)buffer2Cursor, 0);
+          buffer2Cursor = (buffer2Cursor + 1) < fBuffersEnd ? buffer2Cursor + 1 : fBuffer2;
+          v4u32 buffer1Value = __lsx_vld(buffer1Cursor, 0);
+          sum1 -= buffer1Value;
+          __lsx_vst(sum0, (void *)buffer1Cursor, 0);
+          buffer1Cursor = (buffer1Cursor + 1) < fBuffer2 ? buffer1Cursor + 1 : fBuffer1;
+          v4u32 buffer0Value = __lsx_vld(buffer0Cursor, 0);
+          sum0 -= buffer0Value;
+          __lsx_vst(vLeadingEdge, (void *)buffer0Cursor, 0);
+          buffer0Cursor = (buffer0Cursor + 1) < fBuffer1 ? buffer0Cursor + 1 : fBuffer0;
+
+          v16u8 shuf = {0x0,0x4,0x8,0xc,0x0};
+          v16u8 ret = __lsx_vshuf_b(blurred, blurred, shuf);
+          return ret;
+        };
+
+        v4u32 zero = __lsx_vldi(0x0);
+        if (!src && !dst) {
+            while (n --> 0) {
+                (void)processValue(zero);
+            }
+        } else if (src && !dst) {
+            while (n --> 0) {
+                v4u32 edge = __lsx_vinsgr2vr_w(zero, *src, 0);
+                edge = __lsx_vilvl_b(zero, edge);
+                edge = __lsx_vilvl_h(zero, edge);
+                (void)processValue(edge);
+                src += srcStride;
+            }
+        } else if (!src && dst) {
+            v4u32 zero = __lsx_vldi(0u);
+            while (n --> 0) {
+                v4u32 ret = processValue(zero);
+                __lsx_vstelm_w(ret, dst, 0, 0); // 3rd is offset, 4th is idx.
+                dst += dstStride;
+            }
+        } else if (src && dst) {
+            while (n --> 0) {
+                v4u32 edge = __lsx_vinsgr2vr_w(zero, *src, 0);
+                edge = __lsx_vilvl_b(zero, edge);
+                edge = __lsx_vilvl_h(zero, edge);
+                v4u32 ret = processValue(edge);
+                __lsx_vstelm_w(ret, dst, 0, 0);
+                src += srcStride;
+                dst += dstStride;
+            }
+        }
+
+        // Store the state
+        fBuffer0Cursor = buffer0Cursor;
+        fBuffer1Cursor = buffer1Cursor;
+        fBuffer2Cursor = buffer2Cursor;
+
+        __lsx_vst(sum0, fSum0, 0);
+        __lsx_vst(sum1, fSum1, 0);
+        __lsx_vst(sum2, fSum2, 0);
+#else
         skvx::Vec<4, uint32_t>* buffer0Cursor = fBuffer0Cursor;
         skvx::Vec<4, uint32_t>* buffer1Cursor = fBuffer1Cursor;
         skvx::Vec<4, uint32_t>* buffer2Cursor = fBuffer2Cursor;
@@ -481,6 +557,7 @@ private:
         sum0.store(fSum0);
         sum1.store(fSum1);
         sum2.store(fSum2);
+#endif
     }
 
     skvx::Vec<4, uint32_t>* const fBuffer0;
diff --git a/third_party/skia/src/opts/SkBitmapProcState_opts.h b/third_party/skia/src/opts/SkBitmapProcState_opts.h
index 11f443db1d..7b27b65a7a 100644
--- a/third_party/skia/src/opts/SkBitmapProcState_opts.h
+++ b/third_party/skia/src/opts/SkBitmapProcState_opts.h
@@ -25,6 +25,8 @@
     #include <immintrin.h>
 #elif defined(SK_ARM_HAS_NEON)
     #include <arm_neon.h>
+#elif defined(SK_LA_HAS_LASX)
+    #include <lasxintrin.h>
 #endif
 
 namespace SK_OPTS_NS {
@@ -387,6 +389,221 @@ static void decode_packed_coordinates_and_weight(U32 packed, Out* v0, Out* v1, O
         }
     }
 
+#elif defined(SK_LA_HAS_LSX)
+
+    #include <lasxintrin.h>
+    #include <lsxintrin.h>
+#if 0
+    /*not static*/ inline
+    void S32_alpha_D32_filter_DX(const SkBitmapProcState& s,
+                                 const uint32_t* xy, int count, uint32_t* colors) {
+        SkASSERT(count > 0 && colors != nullptr);
+        SkASSERT(s.fBilerp);
+        SkASSERT(kN32_SkColorType == s.fPixmap.colorType());
+        SkASSERT(s.fAlphaScale <= 256);
+
+        int y0, y1, wy;
+        decode_packed_coordinates_and_weight(*xy++, &y0, &y1, &wy);
+
+        auto row0 = (const uint32_t*)( (const char*)s.fPixmap.addr() + y0 * s.fPixmap.rowBytes() ),
+             row1 = (const uint32_t*)( (const char*)s.fPixmap.addr() + y1 * s.fPixmap.rowBytes() );
+
+        // We'll put one pixel in the low 4 16-bit lanes to line up with wy,
+        // and another in the upper 4 16-bit lanes to line up with 16 - wy.
+        uint32_t tmp = 16-wy;
+        __m256i val1 = __lasx_xvldrepl_h(&wy, 0); // Bottom pixel goes here.
+        __m256i val2 = __lasx_xvldrepl_h(&tmp, 0); // Top pixel goes here.
+        //const __m128i allY = _mm_unpacklo_epi64(val1, val2);
+        __m256i tmp_FF00 = {(long long)0xFFFFFFFFFFFFFFFF, (long long)0x0000000000000000, (long long)0xFFFFFFFFFFFFFFFF, (long long)0x0000000000000000};
+        __m256i tmp_00FF = {(long long)0x0000000000000000, (long long)0xFFFFFFFFFFFFFFFF, (long long)0x0000000000000000, (long long)0xFFFFFFFFFFFFFFFF};
+        __m256i tmp_000F = {(long long)0x00000000FFFFFFFF, (long long)0x0000000000000000, (long long)0x00000000FFFFFFFF, (long long)0x0000000000000000};
+        val1 = __lasx_xvand_v(val1, tmp_FF00);
+        val2 = __lasx_xvpermi_d(val2, 0xA0);
+        val2 = __lasx_xvand_v(val2, tmp_00FF);
+        __m256i allY = __lasx_xvor_v(val1, val2);
+
+        while (count --> 0) {
+            int x0, x1, wx;
+            decode_packed_coordinates_and_weight(*xy++, &x0, &x1, &wx);
+
+            // Load the 4 pixels we're interpolating, in this grid:
+            //    | tl  tr |
+            //    | bl  br |
+
+            __m256i tl = __lasx_xvldrepl_w(&row0[x0], 0);
+            __m256i tr = __lasx_xvldrepl_w(&row0[x1], 0);
+            __m256i bl = __lasx_xvldrepl_w(&row1[x0], 0);
+            __m256i br = __lasx_xvldrepl_w(&row1[x1], 0);
+            tl = __lasx_xvand_v(tl, tmp_000F);
+            tr = __lasx_xvand_v(tr, tmp_000F);
+            bl = __lasx_xvand_v(bl, tmp_000F);
+            br = __lasx_xvand_v(br, tmp_000F);
+
+            // We want to calculate a sum of 4 pixels weighted in two directions:
+            //
+            //  sum = tl * (16-wy) * (16-wx)
+            //      + bl * (   wy) * (16-wx)
+            //      + tr * (16-wy) * (   wx)
+            //      + br * (   wy) * (   wx)
+            //
+            // (Notice top --> 16-wy, bottom --> wy, left --> 16-wx, right --> wx.)
+            //
+            // We've already prepared allY as a vector containing [wy, 16-wy] as a way
+            // to apply those y-direction weights.  So we'll start on the x-direction
+            // first, grouping into left and right halves, lined up with allY:
+            //
+            //     L = [bl, tl]
+            //     R = [br, tr]
+            //
+            //   sum = horizontalSum( allY * (L*(16-wx) + R*wx) )
+            //
+            // Rewriting that one more step, we can replace a multiply with a shift:
+            //
+            //   sum = horizontalSum( allY * (16*L + (R-L)*wx) )
+            //
+            // That's how we'll actually do this math.
+
+
+            __m256i L = __lasx_xvilvl_b(__lasx_xvldi(0), __lasx_xvilvl_w(tl, bl)),
+                    R = __lasx_xvilvl_b(__lasx_xvldi(0), __lasx_xvilvl_w(tr, br));
+
+
+            __m256i inner = __lasx_xvadd_h(__lasx_xvslli_h(L, 4),
+                                          __lasx_xvmul_h(__lasx_xvsub_h(R,L), __lasx_xvldrepl_h(&wx, 0)));
+
+            __m256i sum_in_x = __lasx_xvmul_h(inner, allY);
+
+            // sum = horizontalSum( ... )
+            //__m128i sum = _mm_add_epi16(sum_in_x, _mm_srli_si128(sum_in_x, 8));
+            //tmp = __lasx_xvpermi_d(sum_in_x, 0xA5);
+            __m256i sum = __lasx_xvand_v(__lasx_xvpermi_d(sum_in_x, 0xA5), tmp_FF00);
+
+            sum = __lasx_xvadd_h(sum, sum_in_x);
+            // Get back to [0,255] by dividing by maximum weight 16x16 = 256.
+            sum = __lasx_xvsrli_h(sum, 8);
+
+            if (s.fAlphaScale < 256) {
+                // Scale by alpha, which is in [0,256].
+                sum = __lasx_xvmul_h(sum, __lasx_xvldrepl_h(&s.fAlphaScale, 0));
+                sum = __lasx_xvsrli_h(sum, 8);
+            }
+
+            // Pack back into 8-bit values and store.
+            __m256i tmp0 = __lasx_xvsat_hu(sum, 7);
+            __m256i tmp1 = __lasx_xvsat_hu(__lasx_xvldi(0), 7);
+            __m256i tmp2 =  __lasx_xvpickev_b(tmp1, tmp0);
+            *colors++ = __lasx_xvpickve2gr_w(__lasx_xvand_v(tmp2, tmp_000F), 0);
+        }
+    }
+#else
+    /*not static*/ inline
+    void S32_alpha_D32_filter_DX(const SkBitmapProcState& s,
+                                 const uint32_t* xy,
+                                 int count, uint32_t* colors) {
+        SkASSERT(count > 0 && colors != nullptr);
+        SkASSERT(s.fBilerp);
+        SkASSERT(kN32_SkColorType == s.fPixmap.colorType());
+        SkASSERT(s.fAlphaScale < 256);
+
+        const char* srcAddr = static_cast<const char*>(s.fPixmap.addr());
+        size_t rb = s.fPixmap.rowBytes();
+        uint32_t XY = *xy++;
+        unsigned y0 = XY >> 14;
+        const uint32_t* row0 = reinterpret_cast<const uint32_t*>(srcAddr + (y0 >> 4) * rb);
+        const uint32_t* row1 = reinterpret_cast<const uint32_t*>(srcAddr + (XY & 0x3FFF) * rb);
+        unsigned subY = y0 & 0xF; //weight, | x0-14bit | weight-4bit | X1-14bit |
+
+        // ( 0,  0,  0,  0,  0,  0,  0,  0)
+        __m128i zero = {0};
+
+        // (16, 16, 16, 16, 16, 16, 16, 16 )
+        int sixteen_con = 16;
+        __m128i sixteen = __lsx_vreplgr2vr_h(sixteen_con);
+        //__m128i sixteen = __lsx_vldrepl_h(&sixteen_con, 0);
+
+        // ( y,  y,  y,  y,  y,  y,  y,  y)
+        __m128i allY = __lsx_vreplgr2vr_h(subY);
+        allY = __lsx_vilvl_d(zero, allY);
+
+        __m128i sixteen_half = __lsx_vilvl_d(zero, sixteen);
+
+        // ( 16-y,  16-y,  16-y,  16-y, 16-y, 16-y, 16-y, 16-y)
+        __m128i negY = __lsx_vsub_h(sixteen_half, allY);
+
+        // (16-y, 16-y, 16-y, 16-y, y, y, y, y)
+        allY = __lsx_vilvl_d(negY, allY);
+
+        // ( alpha, alpha, alpha, alpha, alpha, alpha, alpha, alpha )
+        //__m128i alpha = __lsx_vreplgr2vr_h(s.fAlphaScale);
+        __m128i alpha = __lsx_vldrepl_h(&s.fAlphaScale,0);
+
+        do {
+            uint32_t XX = *xy++;    // x0:14 | 4 | x1:14
+            unsigned x0 = XX >> 18;
+            unsigned x1 = XX & 0x3FFF;
+
+            // (x, x, x, x, x, x, x, x)
+            __m128i allX = __lsx_vreplgr2vr_h((XX >> 14) & 0x0F);
+
+            // (16-x, 16-x, 16-x, 16-x, 16-x, 16-x, 16-x)
+            __m128i negX = __lsx_vsub_h(sixteen, allX);
+
+            // Load 4 samples (pixels).
+            __m128i a00 = __lsx_vreplgr2vr_w(row0[x0]);
+            __m128i a01 = __lsx_vreplgr2vr_w(row0[x1]);
+            __m128i a10 = __lsx_vreplgr2vr_w(row1[x0]);
+            __m128i a11 = __lsx_vreplgr2vr_w(row1[x1]);
+
+            // (0, 0, a00, a10)
+            __m128i a00a10 = __lsx_vilvl_w(a00, a10);
+
+            // Expand to 16 bits per component.
+            a00a10 = (v4i32)__lsx_vilvl_b(zero, a00a10);
+
+            // ((a00 * (16-y)), (a10 * y)).
+            a00a10 = __lsx_vmul_h(a00a10, allY);
+
+            // (a00 * (16-y) * (16-x), a10 * y * (16-x)).
+            a00a10 = __lsx_vmul_h(a00a10, negX);
+
+            // (0, 0, a01, a10)
+            __m128i a01a11 = __lsx_vilvl_w(a01, a11);
+
+            // Expand to 16 bits per component.
+            a01a11 = __lsx_vilvl_b(zero, a01a11);
+
+            // (a01 * (16-y)), (a11 * y)
+            a01a11 = __lsx_vmul_h(a01a11, allY);
+
+            // (a01 * (16-y) * x), (a11 * y * x)
+            //a01a11 = __lsx_vmul_h(a01a11, allX);
+
+            // (a00*w00 + a01*w01, a10*w10 + a11*w11)
+            //__m128i sum = __lsx_vadd_h(a00a10, a01a11);
+            __m128i sum = __lsx_vmadd_h(a00a10, a01a11, allX);
+
+            // (DC, a00*w00 + a01*w01)
+            __m128i shifted = __lsx_vshuf4i_w((v4i32)sum, 0xEE);
+
+            // (DC, a00*w00 + a01*w01 + a10*w10 + a11*w11)
+            sum = __lsx_vadd_h((v8i16)sum, (v8i16)shifted);
+
+            // Divide each 16 bit component by 256.
+            sum = __lsx_vsrli_h(sum, 8);
+
+            // Multiply by alpha.
+            sum = __lsx_vmul_h(sum, alpha);
+
+            // Divide each 16 bit component by 256.
+            sum = __lsx_vpickod_b(sum, sum);
+
+            // Extract low int and store.
+            __lsx_vstelm_w(sum, colors++, 0, 0);
+        } while (--count > 0);
+    }
+
+#endif
+
 #else
 
     // The NEON code only actually differs from the portable code in the
diff --git a/third_party/skia/src/opts/SkBlitRow_opts.h b/third_party/skia/src/opts/SkBlitRow_opts.h
index 71f46c11cb..e1677b63c2 100644
--- a/third_party/skia/src/opts/SkBlitRow_opts.h
+++ b/third_party/skia/src/opts/SkBlitRow_opts.h
@@ -116,6 +116,32 @@
 
 #endif
 
+#if defined(SK_LA_HAS_LASX)
+    #include <lasxintrin.h>
+    #define LASX_ST(in, pdst) *((__m256i *)(pdst)) = (in)
+    #define LASX_LD(psrc) *((__m256i *)(psrc))
+
+    static inline __m256i SkPMSrcOver_LASX(const __m256i& src, const __m256i& dst) {
+        uint32_t tmp = 256;
+        __m256i val = __lasx_xvldrepl_w(&tmp, 0);
+        __m256i scale = __lasx_xvsub_w(val, __lasx_xvsrli_w(src, 24));
+        __m256i scale_x2 = __lasx_xvor_v(__lasx_xvslli_w(scale, 16), scale);
+
+        tmp = 0x00ff00ff;
+        val = __lasx_xvldrepl_w(&tmp, 0);
+        __m256i rb = __lasx_xvand_v(val, dst);
+        rb = __lasx_xvmul_h(rb, scale_x2);
+        rb = __lasx_xvsrli_h(rb, 8);
+
+        __m256i ga = __lasx_xvsrli_h(dst, 8);
+        ga = __lasx_xvmul_h(ga, scale_x2);
+        ga = __lasx_xvandn_v(val, ga);
+
+        // https://skia-review.googlesource.com/c/skia/+/579280.
+        return __lasx_xvsadd_bu(src, __lasx_xvor_v(rb, ga));
+    }
+#endif
+
 namespace SK_OPTS_NS {
 
 /*not static*/
@@ -169,6 +195,15 @@ inline void blit_row_s32a_opaque(SkPMColor* dst, const SkPMColor* src, int len,
     return;
 #endif
 
+#if defined(SK_LA_HAS_LASX)
+    while (len >= 8) {
+        LASX_ST(SkPMSrcOver_LASX(LASX_LD((const __m256i*)src), LASX_LD((const __m256i*)dst)), (__m256i*)dst);
+        src += 8;
+        dst += 8;
+        len -= 8;
+    }
+#endif
+
     while (len --> 0) {
         *dst = SkPMSrcOver(*src, *dst);
         src++;
diff --git a/third_party/skia/src/opts/SkOpts_lasx.cpp b/third_party/skia/src/opts/SkOpts_lasx.cpp
new file mode 100644
index 0000000000..8fdd3d9178
--- /dev/null
+++ b/third_party/skia/src/opts/SkOpts_lasx.cpp
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2020 Google Inc.
+ *
+ * Use of this source code is governed by a BSD-style license that can be
+ * found in the LICENSE file.
+ */
+
+#include "../core/SkOpts.h"
+#define SK_OPTS_NS lasx
+#include "SkBlitRow_opts.h"
+#include "SkSwizzler_opts.h"
+//#include "SkRasterPipeline_opts.h"
+//#include "SkBitmapProcState_opts.h"
+//#include "src/opts/SkBitmapProcState_opts.h"
+#include "src/opts/SkSwizzler_opts.h"
+
+namespace SkOpts {
+    void Init_lasx() {
+        //hash_fn = lasx::hash_fn;
+        blit_row_s32a_opaque = lasx::blit_row_s32a_opaque;
+        //S32_alpha_D32_filter_DX = lasx::S32_alpha_D32_filter_DX;
+
+        RGBA_to_BGRA          = lasx::RGBA_to_BGRA;
+        RGBA_to_rgbA          = lasx::RGBA_to_rgbA;
+        RGBA_to_bgrA          = lasx::RGBA_to_bgrA;
+        RGB_to_RGB1           = lasx::RGB_to_RGB1;
+        RGB_to_BGR1           = lasx::RGB_to_BGR1;
+        gray_to_RGB1          = lasx::gray_to_RGB1;
+        grayA_to_RGBA         = lasx::grayA_to_RGBA;
+        grayA_to_rgbA         = lasx::grayA_to_rgbA;
+        inverted_CMYK_to_RGB1 = lasx::inverted_CMYK_to_RGB1;
+        inverted_CMYK_to_BGR1 = lasx::inverted_CMYK_to_BGR1;
+
+#if 0
+    #define M(st) stages_highp[SkRasterPipeline::st] = (StageFn)SK_OPTS_NS::st;
+        SK_RASTER_PIPELINE_STAGES(M)
+        just_return_highp = (StageFn)SK_OPTS_NS::just_return;
+        start_pipeline_highp = SK_OPTS_NS::start_pipeline;
+    #undef M
+
+    #define M(st) stages_lowp[SkRasterPipeline::st] = (StageFn)SK_OPTS_NS::lowp::st;
+        SK_RASTER_PIPELINE_STAGES(M)
+        just_return_lowp = (StageFn)SK_OPTS_NS::lowp::just_return;
+        start_pipeline_lowp = SK_OPTS_NS::lowp::start_pipeline;
+    #undef M
+#endif
+    }
+}
diff --git a/third_party/skia/src/opts/SkRasterPipeline_opts.h b/third_party/skia/src/opts/SkRasterPipeline_opts.h
index 7522741fb9..5cb9c18442 100644
--- a/third_party/skia/src/opts/SkRasterPipeline_opts.h
+++ b/third_party/skia/src/opts/SkRasterPipeline_opts.h
@@ -60,6 +60,8 @@ using NoCtx = const void*;
     #define JUMPER_IS_SSE41
 #elif SK_CPU_SSE_LEVEL >= SK_CPU_SSE_LEVEL_SSE2
     #define JUMPER_IS_SSE2
+#elif defined(SK_LA_HAS_LSX)
+    #define JUMPER_IS_LSX
 #else
     #define JUMPER_IS_SCALAR
 #endif
@@ -82,6 +84,8 @@ using NoCtx = const void*;
     #include <math.h>
 #elif defined(JUMPER_IS_NEON)
     #include <arm_neon.h>
+#elif defined(JUMPER_IS_LSX)
+    #include <lsxintrin.h>
 #else
     #include <immintrin.h>
 #endif
@@ -1007,6 +1011,398 @@ template <typename T> using V = T __attribute__((ext_vector_type(4)));
             _mm_storeu_ps(ptr +12, a);
         }
     }
+#elif defined(JUMPER_IS_LSX)
+    template <typename T> using V = T __attribute__((ext_vector_type(4)));
+    using F   = V<float   >;
+    using I32 = V< int32_t>;
+    using U64 = V<uint64_t>;
+    using U32 = V<uint32_t>;
+    using U16 = V<uint16_t>;
+    using U8  = V<uint8_t >;
+
+    #define LSX_LD(psrc) *((__m128i *)(psrc))
+    #define LSX_ST(in, pdst) *((__m128i *)(pdst)) = (in)
+    #define LSX_LDF(psrc) *((__m128 *)(psrc))
+    #define LSX_STF(in, pdst) *((__m128 *)(pdst)) = (in)
+
+    SI __m128 emulate_lsx_loadl_pi(__m128 a, void const* mem_addr)
+    {
+        __m128i ptr_lsx = LSX_LD(mem_addr);
+        return (__m128)__lsx_vshuf4i_d(ptr_lsx, a, 0xC);
+    }
+    SI __m128 emulate_lsx_loadh_pi(__m128 a, void const *mem_addr)
+    {
+        __m128i ptr_lsx = LSX_LD(mem_addr);
+        return (__m128)__lsx_vshuf4i_d(ptr_lsx, a, 0x2);
+    }
+
+    SI F emulate_lsx_and_ps(F a, F b)
+    {
+        return (F)__lsx_vand_v((I32)a, (I32)b);
+    }
+    SI I32 emulate_lsx_slli_epi32(I32 a, int imm8)
+    {
+        I32 tmp0 = __lsx_vldrepl_w(&imm8, 0);
+        return (I32)__lsx_vsll_w(a, tmp0);
+    }
+    SI auto emulate_lsx_srai_epi32(I32 a, int imm8)
+    {
+        I32 tmp0 = __lsx_vldrepl_w(&imm8, 0);
+        return __lsx_vsrar_w(a, tmp0);
+    }
+    SI  F emulate_lsx_andnot_ps(F a, F b)
+    {
+        return (F)__lsx_vandn_v((I32)a, (I32)b);
+    }
+    SI F emulate_lsx_or_ps(F a, F b)
+    {
+        return (F)__lsx_vor_v((I32)a, (I32)b);
+    }
+    SI __m128d emulate_lsx_loadl_pd(__m128i a, const double *mem_addr)
+    {
+        __m128i tmp = LSX_LD(mem_addr);
+        return (__m128d) __lsx_vshuf4i_d(tmp, a, 0xC);
+    }
+
+    SI __m128d emulate_lsx_loadh_pd(__m128i a, const double *mem_addr)
+    {
+        __m128i tmp = LSX_LD(mem_addr);
+        return (__m128d)__lsx_vshuf4i_d(tmp, a, 0x2);
+    }
+
+    SI __m128 emulate_lsx_unpacklo_ps(__m128 a, __m128 b)
+    {
+        return (__m128)__lsx_vilvl_w((__m128i)b, (__m128i)a);
+    }
+    SI __m128 emulate_lsx_unpackhi_ps(__m128 a, __m128 b)
+    {
+        return (__m128)__lsx_vilvh_w((__m128i)b, (__m128i)a);
+    }
+    SI __m128 emulate_lsx_movlh_ps(__m128 a, __m128 b)
+    {
+        return (__m128)__lsx_vilvl_d((__m128i) b, (__m128i)a);
+    }
+    SI __m128 emulate_lsx_movhl_ps(__m128 a, __m128 b)
+    {
+        return (__m128)__lsx_vilvh_d((__m128i)a, (__m128i)b);
+    }
+    
+    /* Transpose the 4x4 matrix composed of row[0-3].  */
+    #define _LSX_TRANSPOSE4_PS(row0, row1, row2, row3)\
+        do {   \
+          __m128 __t0 = emulate_lsx_unpacklo_ps (row0, row1);    \
+          __m128 __t1 = emulate_lsx_unpacklo_ps (row2, row3);    \
+          __m128 __t2 = emulate_lsx_unpackhi_ps (row0, row1);    \
+          __m128 __t3 = emulate_lsx_unpackhi_ps (row2, row3);    \
+          (row0) = emulate_lsx_movlh_ps (__t0, __t1);    \
+          (row1) = emulate_lsx_movhl_ps (__t1, __t0);    \
+          (row2) = emulate_lsx_movlh_ps (__t2, __t3);    \
+          (row3) = emulate_lsx_movhl_ps (__t3, __t2);    \
+        } while (0)
+
+    SI __m128 emulate_lsx_set1_ps(float e0)
+    {
+        __m128 retv = {e0, e0, e0, e0};
+        return retv;
+    }
+    // Emulate _mm_floor_ps() with LSX:
+    //   - roundtrip through integers via truncation
+    //   - subtract 1 if that's too big (possible for negative values).
+    // This restricts the domain of our inputs to a maximum somehwere around 2^31.
+    // Seems plenty big.
+    SI __m128 emulate_lsx_floor_ps(__m128 v)
+    {
+        __m128 roundtrip = __lsx_vffint_s_w(__lsx_vftintrz_w_s(v));
+        __m128 too_big = (__m128)__lsx_vfcmp_clt_s(v, roundtrip);
+        __m128 tmp = emulate_lsx_set1_ps(1.0f);
+    
+        tmp = emulate_lsx_and_ps(too_big, tmp);
+        return __lsx_vfsub_s(roundtrip, tmp);
+    }
+
+    SI F   mad(F f, F m, F a)  {
+      //return f*m+a; //Interpret Mul and Add two instructions by clang.
+      return __lsx_vfmadd_s(f, m, a);
+    }
+    SI F   min(F a, F b)       { return __lsx_vfmin_s(a,b);    }
+    SI F   max(F a, F b)       { return __lsx_vfmax_s(a,b);    }
+
+    SI I32 min(I32 a, I32 b) { return __lsx_vmin_w(a,b); }
+    SI U32 min(U32 a, U32 b) { return __lsx_vmin_wu(a,b); }
+    SI I32 max(I32 a, I32 b) { return __lsx_vmax_w(a,b); }
+    SI U32 max(U32 a, U32 b) { return __lsx_vmax_wu(a,b); }
+
+    SI F   abs_(F v)           { return emulate_lsx_and_ps(v, 0-v); } //TODO:
+    SI I32 abs_(I32 v)         { return max(v, -v); } //TODO: vabsd.w ?
+    SI F   rcp_fast   (F v)    { return __lsx_vfrecip_s(v);    }
+    SI F   rcp_precise (F v)   { F e = rcp_fast(v); return e * (2.0f - v * e); }
+    SI F   rsqrt (F v)         { return __lsx_vfrsqrt_s(v);    }
+    SI F    sqrt_(F v)         { return __lsx_vfsqrt_s (v);    }
+#if 1
+    //SI U32 round(F v)           { return (uint32_t)(v + 0.5f); }
+    SI U32 round(F v)           {
+        F t = F(0.5);
+        return __lsx_vftintrz_w_s(v+t);
+    }
+    SI U32 round(F v, F scale) {
+        F t = F(0.5);
+        return __lsx_vftintrz_w_s(mad(v,scale, t));
+    }
+#else
+   SI U32 round(F v, F scale) {
+     U32 e;
+     e[0] = v[0]*scale[0] + 0.5f;
+     e[1] = v[1]*scale[1] + 0.5f;
+     e[2] = v[2]*scale[2] + 0.5f;
+     e[3] = v[3]*scale[3] + 0.5f;
+     return e;
+   }
+#endif
+
+    SI U16 pack(U32 v) {
+        // Sign extend so that _mm_packs_epi32() does the pack we want.
+        __m128i tmp0 = __lsx_vsat_wu(v, 15);
+        auto p =  __lsx_vpickev_h(tmp0, tmp0);
+
+        return sk_unaligned_load<U16>(&p);  // We have two copies.  Return (the lower) one.
+    }
+    SI U8 pack(U16 v) {
+        auto r = widen_cast<__m128i>(v);
+        __m128i tmp0 = __lsx_vsat_hu(r, 7);
+        r =  __lsx_vpickev_b(tmp0, tmp0);
+        return sk_unaligned_load<U8>(&r);
+    }
+
+#if 0
+     SI bool any(I32 c) { return c[0] | c[1] | c[2] | c[3]; }
+     SI bool all(I32 c) { return c[0] & c[1] & c[2] & c[3]; }
+     SI F ceil_(F v) { return {ceilf(v[0]), ceilf(v[1]), ceilf(v[2]), ceilf(v[3])}; }
+#else
+    SI bool any(I32 c) {
+        v4i32 retv = (v4i32)__lsx_vmskltz_w(__lsx_vslt_wu(__lsx_vldi(0), c));
+        return retv[0] != 0b0000;
+    }
+
+    SI bool all(I32 c) {
+        v4i32 retv = (v4i32)__lsx_vmskltz_w(__lsx_vslt_wu(__lsx_vldi(0), c));
+        return retv[0] == 0b1111;
+    }
+    SI F ceil_(F v) {
+        return __lsx_vfrintrp_s(v);
+    }
+#endif
+
+    SI F if_then_else(I32 c, F t, F e) {
+        return __lsx_vbitsel_v(e, t, c);
+    }
+
+    SI F floor_(F v) {
+	    return __lsx_vfrintrm_s(v);
+        //F roundtrip = __lsx_vffint_s_w(__lsx_vftintrz_w_s(v));
+        //return roundtrip - if_then_else(roundtrip > v, 1, 0);
+    }
+
+    template <typename T>
+    SI V<T> gather(const T* p, U32 ix) {
+        return {p[ix[0]], p[ix[1]], p[ix[2]], p[ix[3]]};
+    }
+    // Args 'p' is a float* type actually and 'int*' to avoid use float register.
+    SI F   gather(const int*    p, int ix0, int ix1, int ix2, int ix3) {
+       F ret = {0.0};
+       ret = __lsx_vinsgr2vr_w(ret, p[ix0], 0);
+       ret = __lsx_vinsgr2vr_w(ret, p[ix1], 1);
+       ret = __lsx_vinsgr2vr_w(ret, p[ix2], 2);
+       ret = __lsx_vinsgr2vr_w(ret, p[ix3], 3);
+       return ret;
+    }
+    template <typename V, typename S>
+    SI void scatter_masked(V src, S* dst, U32 ix, I32 mask) {
+        V before = gather(dst, ix);
+        V after = if_then_else(mask, src, before);
+        dst[ix[0]] = after[0];
+        dst[ix[1]] = after[1];
+        dst[ix[2]] = after[2];
+        dst[ix[3]] = after[3];
+    }
+
+    SI void load2(const uint16_t* ptr, size_t tail, U16* r, U16* g) {
+        __m128i _01;
+        if (__builtin_expect(tail,0)) {
+            _01 = __lsx_vldi(0);
+            if (tail > 1) {
+                _01 = emulate_lsx_loadl_pd(_01, (const double*)ptr);            // r0 g0 r1 g1 00 00 00 00
+                if (tail > 2) {
+                  _01 = __lsx_vinsgr2vr_h(_01, *(ptr+4), 4);             // r0 g0 r1 g1 r2 00 00 00
+                  _01 = __lsx_vinsgr2vr_h(_01, *(ptr+5), 5);             // r0 g0 r1 g1 r2 g2 00 00
+                }
+            } else {
+                _01 = __lsx_vinsgr2vr_w(_01, *(const uint32_t*)ptr, 0);         // r0 g0 00 00 00 00 00 00
+            }
+        } else {
+            _01 = LSX_LD(((__m128i*)ptr) + 0);  // r0 g0 r1 g1 r2 g2 r3 g3
+        }
+        auto rg = __lsx_vshuf4i_h(_01, 0xD8);  // r0 r1 g0 g1 r2 r3 g2 g3
+
+        auto R = __lsx_vshuf4i_w(rg, 0x88);  // r0 r1 r2 r3 r0 r1 r2 r3
+        auto G = __lsx_vshuf4i_w(rg, 0xDD);  // g0 g1 g2 g3 g0 g1 g2 g3
+        *r = sk_unaligned_load<U16>(&R);
+        *g = sk_unaligned_load<U16>(&G);
+    }
+    SI void store2(uint16_t* ptr, size_t tail, U16 r, U16 g) {
+        U32 rg = __lsx_vilvl_h(widen_cast<__m128i>(g), widen_cast<__m128i>(r));
+        if (__builtin_expect(tail, 0)) {
+            if (tail > 1) {
+                __lsx_vstelm_d(rg, (__m128i*)ptr, 0, 0);
+                if (tail > 2) {
+                    int32_t rgpair = rg[2];
+                    memcpy(ptr + 4, &rgpair, sizeof(rgpair));
+                }
+            } else {
+                int32_t rgpair = rg[0];
+                memcpy(ptr, &rgpair, sizeof(rgpair));
+            }
+        } else {
+            LSX_ST(rg, (__m128i*)ptr + 0);
+        }
+    }
+
+    SI void load3(const uint16_t* ptr, size_t tail, U16* r, U16* g, U16* b) {
+        __m128i _0, _1, _2, _3;
+        if (__builtin_expect(tail,0)) {
+            _1 = _2 = _3 = __lsx_vldi(0);
+            auto load_rgb = [](const uint16_t* src) {
+                __m128i tmp = __lsx_vldi(0);
+                auto v = __lsx_vinsgr2vr_w(tmp, *(const uint32_t*)src, 0);
+                return __lsx_vinsgr2vr_h(v, src[2], 2);
+            };
+            if (  true  ) { _0 = load_rgb(ptr + 0); }
+            if (tail > 1) { _1 = load_rgb(ptr + 3); }
+            if (tail > 2) { _2 = load_rgb(ptr + 6); }
+        } else {
+            // Load slightly weirdly to make sure we don't load past the end of 4x48 bits.
+            auto _01 =              LSX_LD((const __m128i*)(ptr + 0))    ,
+                 _23 = __lsx_vbsrl_v(LSX_LD((const __m128i*)(ptr + 4)), 4);
+
+            // Each _N holds R,G,B for pixel N in its lower 3 lanes (upper 5 are ignored).
+            _0 = _01;
+            _1 = __lsx_vbsrl_v(_01, 6);
+            _2 = _23;
+            _3 = __lsx_vbsrl_v(_23, 6);
+        }
+
+        // De-interlace to R,G,B.
+        auto _02 = __lsx_vilvl_h(_2, _0),  // r0 r2 g0 g2 b0 b2 xx xx
+             _13 = __lsx_vilvl_h(_3, _1);  // r1 r3 g1 g3 b1 b3 xx xx
+
+        auto R = __lsx_vilvl_b(_13, _02),  // r0 r1 r2 r3 g0 g1 g2 g3
+             G = __lsx_vbsrl_v(R, 8),
+             B = __lsx_vilvh_h(_13, _02);  // b0 b1 b2 b3 xx xx xx xx
+
+        *r = sk_unaligned_load<U16>(&R);
+        *g = sk_unaligned_load<U16>(&G);
+        *b = sk_unaligned_load<U16>(&B);
+    }
+    SI void load4(const uint16_t* ptr, size_t tail, U16* r, U16* g, U16* b, U16* a) {
+        __m128i _01, _23;
+        if (__builtin_expect(tail,0)) {
+            _01 = _23 = __lsx_vldi(0);
+            auto src = (const double*)ptr;
+            if (  true  ) { _01 = emulate_lsx_loadl_pd(_01, src + 0); } // r0 g0 b0 a0 00 00 00 00
+            if (tail > 1) { _01 = emulate_lsx_loadh_pd(_01, src + 1); } // r0 g0 b0 a0 r1 g1 b1 a1
+            if (tail > 2) { _23 = emulate_lsx_loadl_pd(_23, src + 2); } // r2 g2 b2 a2 00 00 00 00
+        } else {
+            _01 = LSX_LD(((__m128i*)ptr) + 0); // r0 g0 b0 a0 r1 g1 b1 a1
+            _23 = LSX_LD(((__m128i*)ptr) + 1); // r2 g2 b2 a2 r3 g3 b3 a3
+        }
+
+        auto _02 = __lsx_vilvl_h(_23, _01),  // r0 r2 g0 g2 b0 b2 a0 a2
+             _13 = __lsx_vilvh_h(_23, _01);  // r1 r3 g1 g3 b1 b3 a1 a3
+
+        auto rg = __lsx_vilvl_h(_13, _02),  // r0 r1 r2 r3 g0 g1 g2 g3
+             ba = __lsx_vilvh_h(_13, _02);  // b0 b1 b2 b3 a0 a1 a2 a3
+
+        *r = sk_unaligned_load<U16>((uint16_t*)&rg + 0);
+        *g = sk_unaligned_load<U16>((uint16_t*)&rg + 4);
+        *b = sk_unaligned_load<U16>((uint16_t*)&ba + 0);
+        *a = sk_unaligned_load<U16>((uint16_t*)&ba + 4);
+    }
+
+    SI void store4(uint16_t* ptr, size_t tail, U16 r, U16 g, U16 b, U16 a) {
+        auto rg = __lsx_vilvl_h(widen_cast<__m128i>(g), widen_cast<__m128i>(r)),
+             ba = __lsx_vilvl_h(widen_cast<__m128i>(a), widen_cast<__m128i>(b));
+
+        if (__builtin_expect(tail, 0)) {
+            auto dst = (double*)ptr;
+            if (  true  ) { __lsx_vstelm_d(__lsx_vilvl_w(ba, rg), dst , 0, 0); }
+            if (tail > 1) { __lsx_vstelm_d(__lsx_vilvl_w(ba, rg), dst , 8, 1); }
+            if (tail > 2) { __lsx_vstelm_d(__lsx_vilvh_w(ba, rg), dst , 16, 0); }
+        } else {
+            LSX_ST(__lsx_vilvl_w(ba, rg), (__m128i*)ptr + 0);
+            LSX_ST(__lsx_vilvh_w(ba, rg), (__m128i*)ptr + 1);
+        }
+    }
+    SI void load2(const float* ptr, size_t tail, F* r, F* g) {
+         F _01, _23;
+         if (__builtin_expect(tail, 0)) {
+             _01 = _23 = __lsx_vldi(0);
+             if (  true  ) { _01 = emulate_lsx_loadl_pi(_01, (void const*)(ptr + 0)); }
+             if (tail > 1) { _01 = emulate_lsx_loadh_pi(_01, (void const*)(ptr + 2)); }
+             if (tail > 2) { _23 = emulate_lsx_loadl_pi(_23, (void const*)(ptr + 4)); }
+         } else {
+             _01 = LSX_LDF(ptr + 0);
+             _23 = LSX_LDF(ptr + 4);
+         }
+         v4u32 mask1 = {0, 2, 4, 6};
+         v4u32 mask2 = {1, 3, 5, 7};
+         *r = __lsx_vshuf_w(mask1, _23, _01);
+         *g = __lsx_vshuf_w(mask2, _23, _01);
+     }
+     SI void store2(float* ptr, size_t tail, F r, F g) {
+         F _01 = __lsx_vilvl_w(g, r),
+           _23 = __lsx_vilvh_w(g, r);
+         if (__builtin_expect(tail, 0)) {
+             if (  true  ) { __lsx_vstelm_d(_01, ptr, 0, 0); }
+             if (tail > 1) { __lsx_vstelm_d(_01, ptr, 8, 1); }
+             if (tail > 2) { __lsx_vstelm_d(_23, ptr, 16, 0); }
+         } else {
+             LSX_STF(_01, ptr + 0);
+             LSX_STF(_23, ptr + 4);
+         }
+     }
+     SI void load4(const float* ptr, size_t tail, F* r, F* g, F* b, F* a) {
+         F _0, _1, _2, _3;
+         if (__builtin_expect(tail, 0)) {
+             _1 = _2 = _3 = __lsx_vldi(0);
+             if (  true  ) { _0 = LSX_LDF(ptr + 0); }
+             if (tail > 1) { _1 = LSX_LDF(ptr + 4); }
+             if (tail > 2) { _2 = LSX_LDF(ptr + 8); }
+         } else {
+             _0 = LSX_LDF(ptr + 0);
+             _1 = LSX_LDF(ptr + 4);
+             _2 = LSX_LDF(ptr + 8);
+             _3 = LSX_LDF(ptr +12);
+         }
+         _LSX_TRANSPOSE4_PS(_0,_1,_2,_3);
+         *r = _0;
+         *g = _1;
+         *b = _2;
+         *a = _3;
+     }
+
+     SI void store4(float* ptr, size_t tail, F r, F g, F b, F a) {
+         _LSX_TRANSPOSE4_PS(r,g,b,a);
+         if (__builtin_expect(tail, 0)) {
+             if (  true  ) { LSX_STF(r, ptr + 0); }
+             if (tail > 1) { LSX_STF(g, ptr + 4); }
+             if (tail > 2) { LSX_STF(b, ptr + 8); }
+         } else {
+             LSX_STF(r, ptr + 0);
+             LSX_STF(g, ptr + 4);
+             LSX_STF(b, ptr + 8);
+             LSX_STF(a, ptr +12);
+         }
+     }
+
 #endif
 
 // We need to be a careful with casts.
@@ -1038,6 +1434,10 @@ SI U16 bswap(U16 x) {
     auto v = widen_cast<__m128i>(x);
     v = _mm_slli_epi16(v,8) | _mm_srli_epi16(v,8);
     return sk_unaligned_load<U16>(&v);
+#elif defined(JUMPER_IS_LSX)
+    auto v = widen_cast<__m128i>(x);
+    v = __lsx_vslli_h(v,8) | __lsx_vsrli_h(v,8);
+    return sk_unaligned_load<U16>(&v);
 #else
     return (x<<8) | (x>>8);
 #endif
@@ -1148,7 +1548,7 @@ static constexpr size_t N = sizeof(F) / sizeof(float);
     // instead of {b,a} on the stack.  Narrow stages work best for __vectorcall.
     #define ABI __vectorcall
     #define JUMPER_NARROW_STAGES 1
-#elif defined(__x86_64__) || defined(SK_CPU_ARM64)
+#elif defined(__x86_64__) || defined(SK_CPU_ARM64) || defined(JUMPER_IS_LSX)
     // These platforms are ideal for wider stages, and their default ABI is ideal.
     #define ABI
     #define JUMPER_NARROW_STAGES 0
@@ -3009,7 +3409,38 @@ SI void gradient_lookup(const SkRasterPipeline_GradientCtx* c, U32 idx, F t,
         fa = _mm256_permutevar8x32_ps(_mm256_loadu_ps(c->fs[3]), idx);
         ba = _mm256_permutevar8x32_ps(_mm256_loadu_ps(c->bs[3]), idx);
     } else
+#elif defined(JUMPER_IS_LSX)
+    // The all data can put a vector register, so can use shuffle to
+    // simplify the conputer.
+    if (c->stopCount <=4){
+        __m128i zero = __lsx_vldi(0);
+        fr = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->fs[0], 0));
+        br = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->bs[0], 0));
+        fg = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->fs[1], 0));
+        bg = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->bs[1], 0));
+        fb = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->fs[2], 0));
+        bb = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->bs[2], 0));
+        fa = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->fs[3], 0));
+        ba = (__m128)__lsx_vshuf_w(idx, zero, __lsx_vld(c->bs[3], 0));
+    } else
 #endif
+#if defined(JUMPER_IS_LSX)
+    {
+        // This opt can avoid more vpickve2gr.
+        int i0 = __lsx_vpickve2gr_w(idx, 0);
+        int i1 = __lsx_vpickve2gr_w(idx, 1);
+        int i2 = __lsx_vpickve2gr_w(idx, 2);
+        int i3 = __lsx_vpickve2gr_w(idx, 3);
+        fr = gather((int *)c->fs[0], i0, i1, i2, i3);
+        br = gather((int *)c->bs[0], i0, i1, i2, i3);
+        fg = gather((int *)c->fs[1], i0, i1, i2, i3);
+        bg = gather((int *)c->bs[1], i0, i1, i2, i3);
+        fb = gather((int *)c->fs[2], i0, i1, i2, i3);
+        bb = gather((int *)c->bs[2], i0, i1, i2, i3);
+        fa = gather((int *)c->fs[3], i0, i1, i2, i3);
+        ba = gather((int *)c->bs[3], i0, i1, i2, i3);
+    }
+#else
     {
         fr = gather(c->fs[0], idx);
         br = gather(c->bs[0], idx);
@@ -3020,6 +3451,7 @@ SI void gradient_lookup(const SkRasterPipeline_GradientCtx* c, U32 idx, F t,
         fa = gather(c->fs[3], idx);
         ba = gather(c->bs[3], idx);
     }
+#endif
 
     *r = mad(t, fr, br);
     *g = mad(t, fg, bg);
@@ -4496,6 +4928,7 @@ STAGE(swizzle, void* ctx) {
     }
 }
 
+//#define SK_DISABLE_LOWP_RASTER_PIPELINE
 namespace lowp {
 #if defined(JUMPER_IS_SCALAR) || defined(SK_DISABLE_LOWP_RASTER_PIPELINE)
     // If we're not compiled by Clang, or otherwise switched into scalar mode (old Clang, manually),
@@ -4787,7 +5220,7 @@ SI F rcp_precise(F x) {
     __m256 lo,hi;
     split(x, &lo,&hi);
     return join<F>(SK_OPTS_NS::rcp_precise(lo), SK_OPTS_NS::rcp_precise(hi));
-#elif defined(JUMPER_IS_SSE2) || defined(JUMPER_IS_SSE41) || defined(JUMPER_IS_AVX)
+#elif defined(JUMPER_IS_SSE2) || defined(JUMPER_IS_SSE41) || defined(JUMPER_IS_AVX) || defined(JUMPER_IS_LSX)
     __m128 lo,hi;
     split(x, &lo,&hi);
     return join<F>(SK_OPTS_NS::rcp_precise(lo), SK_OPTS_NS::rcp_precise(hi));
@@ -4822,6 +5255,10 @@ SI F sqrt_(F x) {
     float32x4_t lo,hi;
     split(x, &lo,&hi);
     return join<F>(sqrt(lo), sqrt(hi));
+#elif defined(JUMPER_IS_LSX)
+    __m128 lo,hi;
+    split(x, &lo,&hi);
+    return join<F>(__lsx_vfsqrt_s(lo), __lsx_vfsqrt_s(hi));
 #else
     return F{
         sqrtf(x[0]), sqrtf(x[1]), sqrtf(x[2]), sqrtf(x[3]),
@@ -4843,6 +5280,11 @@ SI F floor_(F x) {
     __m128 lo,hi;
     split(x, &lo,&hi);
     return join<F>(_mm_floor_ps(lo), _mm_floor_ps(hi));
+#elif defined(JUMPER_IS_LSX)
+    __m128 lo,hi;
+    split(x, &lo,&hi);
+    //return join<F>(emulate_lsx_floor_ps(lo), emulate_lsx_floor_ps(hi));
+    return join<F>(__lsx_vfrintrm_s(lo), __lsx_vfrintrm_s(hi));
 #else
     F roundtrip = cast<F>(cast<I32>(x));
     return roundtrip - if_then_else(roundtrip > x, F(1), F(0));
@@ -4863,6 +5305,9 @@ SI I16 scaled_mult(I16 a, I16 b) {
     return vqrdmulhq_s16(a, b);
 #elif defined(JUMPER_IS_NEON)
     return vqrdmulhq_s16(a, b);
+#elif defined(JUMPER_IS_LSX)
+    I16 res = __lsx_vmuh_h(a, b);
+    return __lsx_vslli_h(res, 1);
 #else
     const I32 roundingTerm = 1 << 14;
     return cast<I16>((cast<I32>(a) * cast<I32>(b) + roundingTerm) >> 15);
@@ -4893,12 +5338,30 @@ SI F abs_(F x) { return sk_bit_cast<F>( sk_bit_cast<I32>(x) & 0x7fffffff ); }
 // ~~~~~~ Basic / misc. stages ~~~~~~ //
 
 STAGE_GG(seed_shader, NoCtx) {
+#if defined(JUMPER_IS_LSX)
+    __m128 val1 = {0.5f, 1.5f, 2.5f, 3.5f};
+    __m128 val2 = {4.5f, 5.5f, 6.5f, 7.5f};
+    __m128 val3 = {0.5f, 0.5f, 0.5f, 0.5f};
+
+    __m128i v_d = __lsx_vreplgr2vr_w(dx);
+
+    __m128 f_d = __lsx_vffint_s_w(v_d);
+    val1 = __lsx_vfadd_s(val1, f_d);
+    val2 = __lsx_vfadd_s(val2, f_d);
+    x = join<F>(val1, val2);
+
+    v_d = __lsx_vreplgr2vr_w(dy);
+    f_d = __lsx_vffint_s_w(v_d);
+    val3 = __lsx_vfadd_s(val3, f_d);
+    y = join<F>(val3, val3);
+#else
     static constexpr float iota[] = {
         0.5f, 1.5f, 2.5f, 3.5f, 4.5f, 5.5f, 6.5f, 7.5f,
         8.5f, 9.5f,10.5f,11.5f,12.5f,13.5f,14.5f,15.5f,
     };
     x = cast<F>(I32(dx)) + sk_unaligned_load<F>(iota);
     y = cast<F>(I32(dy)) + 0.5f;
+#endif
 }
 
 STAGE_GG(matrix_translate, const float* m) {
@@ -5218,15 +5681,29 @@ SI void from_8888(U32 rgba, U16* r, U16* g, U16* b, U16* a) {
         split(v, &_02,&_13);
         return _mm256_packus_epi32(_02,_13);
     };
+#elif defined(JUMPER_IS_LSX)
+    __m128i _01, _23, rg, ba;
+    split(rgba, &_01, &_23);
+    rg = __lsx_vpickev_h(_23, _01);
+    ba = __lsx_vpickod_h(_23, _01);
+
+    __m128i mask_00ff = __lsx_vreplgr2vr_h(0xff);
+
+    *r = __lsx_vand_v(rg, mask_00ff);
+    *g = __lsx_vsrli_h(rg, 8);
+    *b = __lsx_vand_v(ba, mask_00ff);
+    *a = __lsx_vsrli_h(ba, 8);
 #else
     auto cast_U16 = [](U32 v) -> U16 {
         return cast<U16>(v);
     };
 #endif
+#if !defined(JUMPER_IS_LSX)
     *r = cast_U16(rgba & 65535) & 255;
     *g = cast_U16(rgba & 65535) >>  8;
     *b = cast_U16(rgba >>   16) & 255;
     *a = cast_U16(rgba >>   16) >>  8;
+#endif
 }
 
 SI void load_8888_(const uint32_t* ptr, size_t tail, U16* r, U16* g, U16* b, U16* a) {
@@ -5251,6 +5728,31 @@ SI void load_8888_(const uint32_t* ptr, size_t tail, U16* r, U16* g, U16* b, U16
 #endif
 }
 SI void store_8888_(uint32_t* ptr, size_t tail, U16 r, U16 g, U16 b, U16 a) {
+#if defined(JUMPER_IS_LSX)
+    __m128i mask = __lsx_vreplgr2vr_h(255);
+    r = __lsx_vmin_hu(r, mask);
+    g = __lsx_vmin_hu(g, mask);
+    b = __lsx_vmin_hu(b, mask);
+    a = __lsx_vmin_hu(a, mask);
+
+    g = __lsx_vslli_h(g, 8);
+    r = r | g;
+    a = __lsx_vslli_h(a, 8);
+    a = a | b;
+
+    __m128i r_lo = __lsx_vsllwil_wu_hu(r, 0);
+    __m128i r_hi = __lsx_vexth_wu_hu(r);
+    __m128i a_lo = __lsx_vsllwil_wu_hu(a, 0);
+    __m128i a_hi = __lsx_vexth_wu_hu(a);
+
+    a_lo = __lsx_vslli_w(a_lo, 16);
+    a_hi = __lsx_vslli_w(a_hi, 16);
+
+    r = r_lo | a_lo;
+    a = r_hi | a_hi;
+    store(ptr, tail, join<U32>(r, a));
+
+#else
     r = min(r, 255);
     g = min(g, 255);
     b = min(b, 255);
@@ -5277,6 +5779,7 @@ SI void store_8888_(uint32_t* ptr, size_t tail, U16 r, U16 g, U16 b, U16 a) {
     store(ptr, tail, cast<U32>(r | (g<<8)) <<  0
                    | cast<U32>(b | (a<<8)) << 16);
 #endif
+#endif
 }
 
 STAGE_PP(load_8888, const SkRasterPipeline_MemoryCtx* ctx) {
@@ -5708,6 +6211,28 @@ SI void gradient_lookup(const SkRasterPipeline_GradientCtx* c, U32 idx, F t,
         ba = join<F>(_mm256_permutevar8x32_ps(_mm256_loadu_ps(c->bs[3]), lo),
                      _mm256_permutevar8x32_ps(_mm256_loadu_ps(c->bs[3]), hi));
     } else
+#elif defined(JUMPER_IS_LSX)
+    if (c->stopCount <= 4) {
+        __m128i lo, hi;
+        split(idx, &lo, &hi);
+        // TODO:
+        fr = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->fs[0], 0), __lsx_vld(c->fs[0], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->fs[0], 0), __lsx_vld(c->fs[0], 0)));
+        br = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->bs[0], 0), __lsx_vld(c->bs[0], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->bs[0], 0), __lsx_vld(c->bs[0], 0)));
+        fg = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->fs[1], 0), __lsx_vld(c->fs[1], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->fs[1], 0), __lsx_vld(c->fs[1], 0)));
+        bg = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->bs[1], 0), __lsx_vld(c->bs[1], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->bs[1], 0), __lsx_vld(c->bs[1], 0)));
+        fb = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->fs[2], 0), __lsx_vld(c->fs[2], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->fs[2], 0), __lsx_vld(c->fs[2], 0)));
+        bb = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->bs[2], 0), __lsx_vld(c->bs[2], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->bs[2], 0), __lsx_vld(c->bs[2], 0)));
+        fa = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->fs[3], 0), __lsx_vld(c->fs[3], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->fs[3], 0), __lsx_vld(c->fs[3], 0)));
+        ba = join<F>((__m128)__lsx_vshuf_w(lo, __lsx_vld(c->bs[3], 0), __lsx_vld(c->bs[3], 0)),
+                     (__m128)__lsx_vshuf_w(hi, __lsx_vld(c->bs[3], 0), __lsx_vld(c->bs[3], 0)));
+    } else
 #endif
     {
         fr = gather<F>(c->fs[0], idx);
@@ -5756,8 +6281,23 @@ STAGE_GP(evenly_spaced_2_stop_gradient, const SkRasterPipeline_EvenlySpaced2Stop
 STAGE_GP(bilerp_clamp_8888, const SkRasterPipeline_GatherCtx* ctx) {
     // Quantize sample point and transform into lerp coordinates converting them to 16.16 fixed
     // point number.
+#if defined(JUMPER_IS_LSX)
+    __m128 _01, _23, _45, _67;
+    v4f32 v_tmp1 = {0.5f, 0.5f, 0.5f, 0.5f};
+    v4f32 v_tmp2 = {65536.0f, 65536.0f, 65536.0f, 65536.0f};
+    split(x, &_01,&_23);
+    split(y, &_45,&_67);
+    __m128 val1 = __lsx_vfmadd_s((__m128)v_tmp2, _01, (__m128)v_tmp1);
+    __m128 val2 = __lsx_vfmadd_s((__m128)v_tmp2, _23, (__m128)v_tmp1);
+    __m128 val3 = __lsx_vfmadd_s((__m128)v_tmp2, _45, (__m128)v_tmp1);
+    __m128 val4 = __lsx_vfmadd_s((__m128)v_tmp2, _67, (__m128)v_tmp1);
+    I32 qx = cast<I32>((join<F>(__lsx_vfrintrm_s(val1), __lsx_vfrintrm_s(val2)))) - 32768,
+    qy = cast<I32>((join<F>(__lsx_vfrintrm_s(val3), __lsx_vfrintrm_s(val4)))) - 32768;
+
+#else
     I32 qx = cast<I32>(floor_(65536.0f * x + 0.5f)) - 32768,
         qy = cast<I32>(floor_(65536.0f * y + 0.5f)) - 32768;
+#endif
 
     // Calculate screen coordinates sx & sy by flooring qx and qy.
     I32 sx = qx >> 16,
@@ -5773,8 +6313,22 @@ STAGE_GP(bilerp_clamp_8888, const SkRasterPipeline_GatherCtx* ctx) {
     // Calculate {qx} - 1 and {qy} - 1 where the {} operation is handled by the cast, and the - 1
     // is handled by the ^ 0x8000, dividing by 2 is deferred and handled in lerpX and lerpY in
     // order to use the full 16-bit resolution.
+#if defined(JUMPER_IS_LSX)
+    __m128i qx_lo, qx_hi, qy_lo, qy_hi;
+    split(qx, &qx_lo, &qx_hi);
+    split(qy, &qy_lo, &qy_hi);
+    __m128i temp = __lsx_vreplgr2vr_w(0x8000);
+    qx_lo = __lsx_vxor_v(qx_lo, temp);
+    qx_hi = __lsx_vxor_v(qx_hi, temp);
+    qy_lo = __lsx_vxor_v(qy_lo, temp);
+    qy_hi = __lsx_vxor_v(qy_hi, temp);
+
+    I16 tx = __lsx_vpickev_h(qx_hi, qx_lo);
+    I16 ty = __lsx_vpickev_h(qy_hi, qy_lo);
+#else
     I16 tx = cast<I16>(qx ^ 0x8000),
         ty = cast<I16>(qy ^ 0x8000);
+#endif
 
     // Substituting the {qx} by the equation for tx from above into the lerp equation where v is
     // the lerped value:
diff --git a/third_party/skia/src/opts/SkSwizzler_opts.h b/third_party/skia/src/opts/SkSwizzler_opts.h
index 79ee016a01..10b372e6fd 100644
--- a/third_party/skia/src/opts/SkSwizzler_opts.h
+++ b/third_party/skia/src/opts/SkSwizzler_opts.h
@@ -16,6 +16,11 @@
     #include <immintrin.h>
 #elif defined(SK_ARM_HAS_NEON)
     #include <arm_neon.h>
+#elif defined(SK_LA_HAS_LASX)
+    #include <lasxintrin.h>
+    #define LASX_ST(in, pdst) *((__m256i *)(pdst)) = (in)
+    #define LASX_LD(psrc) *((__m256i *)(psrc))
+    #include<stdio.h>
 #endif
 
 namespace SK_OPTS_NS {
@@ -812,6 +817,224 @@ static void inverted_cmyk_to(Format format, uint32_t* dst, const uint32_t* src,
     inverted_cmyk_to(kBGR1, dst, src, count);
 }
 
+#elif defined(SK_LA_HAS_LASX)
+//TODO
+//enable by SkOpts_lasx.cpp
+
+// Scale a byte by another.
+// Inputs are stored in 16-bit lanes, but are not larger than 8-bits.
+// (x+127)/255 == ((x+128)*257)>>16
+static __m256i lasx_pix_multiply(__m256i x, __m256i y) {
+    __m256i tmp0, tmp1;
+    __m256i vec;
+    const unsigned short val = 0x80;
+
+    vec  = __lasx_xvldrepl_h(&val, 0);
+    tmp0 = __lasx_xvmadd_h(vec, x, y);
+    tmp1 = __lasx_xvsrli_h(tmp0, 8);
+    tmp0 = __lasx_xvadd_h(tmp0, tmp1);
+    tmp1 = __lasx_xvsrli_h(tmp0, 8);
+
+    return tmp1;
+}
+
+static void premul_should_swapRB(bool kSwapRB, uint32_t* dst, const uint32_t* src, int count) {
+    //printf("%s====%s====%d\n",__FILE__,__func__,__LINE__);
+    const __m256i colorMask = {(long long)0x000000ff000000ff, (long long)0x000000ff000000ff, (long long)0x000000ff000000ff, (long long)0x000000ff000000ff};
+    auto premul8 = [=](__m256i *srcVector)
+    {
+        __m256i pixa,pixr,pixg,pixb;
+        pixa = __lasx_xvsrli_w(*srcVector, 24);
+        pixr = __lasx_xvsrli_w(*srcVector, 0);
+        pixg = __lasx_xvsrli_w(*srcVector, 8);
+        pixb = __lasx_xvsrli_w(*srcVector, 16);
+
+        pixa = __lasx_xvand_v(pixa, colorMask);
+        pixb = __lasx_xvand_v(pixb, colorMask);
+        pixg = __lasx_xvand_v(pixg, colorMask);
+        pixr = __lasx_xvand_v(pixr, colorMask);
+
+        pixb = lasx_pix_multiply(pixb, pixa);
+        pixg = lasx_pix_multiply(pixg, pixa);
+        pixr = lasx_pix_multiply(pixr, pixa);
+
+        if(!kSwapRB)
+        {
+            pixa = __lasx_xvslli_w(pixa, 24);
+            pixb = __lasx_xvslli_w(pixb, 16);
+            pixg = __lasx_xvslli_w(pixg, 8);
+            pixr = __lasx_xvslli_w(pixr, 0);
+        }
+        else
+        {
+            pixa = __lasx_xvslli_w(pixa, 24);
+            pixr = __lasx_xvslli_w(pixr, 16);
+            pixg = __lasx_xvslli_w(pixg, 8);
+            pixb = __lasx_xvslli_w(pixb, 0);
+        }
+
+        __m256i tmp1 = __lasx_xvor_v(pixa, pixr);
+        __m256i tmp2 = __lasx_xvor_v(pixg, pixb);
+        *srcVector = __lasx_xvor_v(tmp1, tmp2);
+    };
+
+    while (count >= 8) {
+        __m256i srcVec = LASX_LD((const __m256i*)src);
+        premul8(&srcVec);
+        LASX_ST(srcVec, (__m256i*) dst);
+        src += 8;
+        dst += 8;
+        count -= 8;
+    }
+
+    // Call portable code to finish up the tail of [0,4) pixels.
+    auto proc = kSwapRB ? RGBA_to_bgrA_portable : RGBA_to_rgbA_portable;
+    proc(dst, src, count);
+}
+
+/*not static*/ inline void RGBA_to_rgbA(uint32_t* dst, const uint32_t* src, int count) {
+    premul_should_swapRB(false, dst, src, count);
+}
+
+/*not static*/ inline void RGBA_to_bgrA(uint32_t* dst, const uint32_t* src, int count) {
+    premul_should_swapRB(true, dst, src, count);
+}
+
+/*not static*/ inline void RGBA_to_BGRA(uint32_t* dst, const uint32_t* src, int count) {
+    //printf("%s====%s====%d\n",__FILE__,__func__,__LINE__);
+    while (count >= 8) {
+        __m256i rgba = LASX_LD((const __m256i*) src);
+        __m256i bgra = __lasx_xvshuf4i_b(rgba, 0xC6);
+        LASX_ST(bgra, (__m256i*) dst);
+
+        src += 8;
+        dst += 8;
+        count -= 8;
+    }
+
+    RGBA_to_BGRA_portable(dst, src, count);
+}
+
+/*not static*/ inline void grayA_to_RGBA(uint32_t dst[], const uint8_t* src, int count) {
+    //printf("%s====%s====%d\n",__FILE__,__func__,__LINE__);
+    while (count >= 16) {
+        __m256i ga = LASX_LD((const __m256i*) src);
+
+        uint32_t tmp = 0x00FF;
+        __m256i val = __lasx_xvldrepl_h(&tmp, 0);
+
+        __m256i gg = __lasx_xvor_v(__lasx_xvand_v(ga, val), __lasx_xvslli_h(ga, 8));
+
+        __m256i ggga_lo = __lasx_xvilvl_h(ga, gg);
+        __m256i ggga_hi = __lasx_xvilvh_h(ga, gg);
+
+        LASX_ST(ggga_lo, (__m256i*) (dst +  0));
+        LASX_ST(ggga_hi, (__m256i*) (dst +  8));
+
+        src += 16*2;
+        dst += 16;
+        count -= 16;
+    }
+
+    grayA_to_RGBA_portable(dst, src, count);
+}
+
+/*not static*/ inline void grayA_to_rgbA(uint32_t dst[], const uint8_t* src, int count) {
+    //printf("%s====%s====%d\n",__FILE__,__func__,__LINE__);
+    while (count >= 8) {
+        __m256i grayA = LASX_LD((const __m256i*) src);
+
+        uint16_t tmp = 0x00FF;
+        __m256i val = __lasx_xvldrepl_h(&tmp, 0);
+
+        __m256i g0 = __lasx_xvand_v(grayA, val);
+        __m256i a0 = __lasx_xvsrli_h(grayA, 8);
+
+        // Premultiply
+        g0 = lasx_pix_multiply(g0, a0);
+
+        __m256i gg = __lasx_xvor_v(g0, __lasx_xvslli_h(g0, 8));
+        __m256i ga = __lasx_xvor_v(g0, __lasx_xvslli_h(a0, 8));
+
+        __m256i ggga_lo = __lasx_xvilvl_h(ga, gg);
+        __m256i ggga_hi = __lasx_xvilvl_h(ga, gg);
+
+        LASX_ST(ggga_lo, (__m256i*) (dst +  0));
+        LASX_ST(ggga_hi, (__m256i*) (dst +  4));
+
+        src += 8*2;
+        dst += 8;
+        count -= 8;
+    }
+
+    grayA_to_rgbA_portable(dst, src, count);
+}
+
+enum Format { kRGB1, kBGR1 };
+static void inverted_cmyk_to(Format format, uint32_t* dst, const uint32_t* src, int count) {
+    //printf("%s====%s====%d\n",__FILE__,__func__,__LINE__);
+    const __m256i colorMask = {(long long)0x000000ff000000ff, (long long)0x000000ff000000ff, (long long)0x000000ff000000ff, (long long)0x000000ff000000ff};
+    auto convert8 = [=](__m256i *srcVector) {
+
+        __m256i pixr,pixg,pixb,k,y,m,c;
+        k = __lasx_xvsrli_w(*srcVector, 24);
+        y = __lasx_xvsrli_w(*srcVector, 16);
+        m = __lasx_xvsrli_w(*srcVector, 8);
+        c = __lasx_xvsrli_w(*srcVector, 0);
+
+        k = __lasx_xvand_v(k, colorMask);
+        y = __lasx_xvand_v(y, colorMask);
+        m = __lasx_xvand_v(m, colorMask);
+        c = __lasx_xvand_v(c, colorMask);
+
+        pixb = lasx_pix_multiply(y, k);
+        pixg = lasx_pix_multiply(m, k);
+        pixr = lasx_pix_multiply(c, k);
+
+        uint32_t alphaMask = 0xFF000000;
+        __m256i FF = __lasx_xvldrepl_w(&alphaMask, 0);
+        if(kBGR1 != format)
+        {
+            pixb = __lasx_xvslli_w(pixb, 16);
+            pixg = __lasx_xvslli_w(pixg, 8);
+            pixr = __lasx_xvslli_w(pixr, 0);
+        }
+        else
+        {
+            pixb = __lasx_xvslli_w(pixb, 0);
+            pixg = __lasx_xvslli_w(pixg, 8);
+            pixr = __lasx_xvslli_w(pixr, 16);
+        }
+
+        __m256i tmp1 = __lasx_xvor_v(FF, pixr);
+        __m256i tmp2 = __lasx_xvor_v(pixg, pixb);
+        *srcVector = __lasx_xvor_v(tmp1, tmp2);
+    };
+
+    while (count >= 8) {
+        __m256i srcVec = LASX_LD((const __m256i*) src);
+
+        convert8(&srcVec);
+
+        LASX_ST(srcVec, (__m256i*) dst);
+
+        src += 8;
+        dst += 8;
+        count -= 8;
+    }
+
+    auto proc = (kBGR1 == format) ? inverted_CMYK_to_BGR1_portable : inverted_CMYK_to_RGB1_portable;
+    proc(dst, src, count);
+}
+
+/*not static*/ inline void inverted_CMYK_to_RGB1(uint32_t dst[], const uint32_t* src, int count) {
+    inverted_cmyk_to(kRGB1, dst, src, count);
+}
+
+/*not static*/ inline void inverted_CMYK_to_BGR1(uint32_t dst[], const uint32_t* src, int count) {
+    inverted_cmyk_to(kBGR1, dst, src, count);
+}
+
 #else
 
 /*not static*/ inline void RGBA_to_rgbA(uint32_t* dst, const uint32_t* src, int count) {
@@ -963,6 +1186,34 @@ static void gray_to_RGB1_portable(uint32_t dst[], const uint8_t* src, int count)
         }
         gray_to_RGB1_portable(dst, src, count);
     }
+#elif defined(SK_LA_HAS_LASX)
+    /*not static*/ inline void gray_to_RGB1(uint32_t dst[], const uint8_t* src, int count) {
+        uint32_t FF = 0xFFFFFFFF;
+        const __m256i alphas = __lasx_xvldrepl_w(&FF, 0);
+        while (count >= 32) {
+            __m256i grays = LASX_LD((const __m256i*) src);
+
+            __m256i gg_lo = __lasx_xvilvl_b(grays, grays);
+            __m256i gg_hi = __lasx_xvilvh_b(grays, grays);
+            __m256i ga_lo = __lasx_xvilvl_b(alphas, grays);
+            __m256i ga_hi = __lasx_xvilvh_b(alphas, grays);
+
+            __m256i ggga0 = __lasx_xvilvl_h(ga_lo, gg_lo);
+            __m256i ggga1 = __lasx_xvilvh_h(ga_lo, gg_lo);
+            __m256i ggga2 = __lasx_xvilvl_h(ga_hi, gg_hi);
+            __m256i ggga3 = __lasx_xvilvl_h(ga_hi, gg_hi);
+
+            LASX_ST(ggga0, (__m256i*) (dst +  0));
+            LASX_ST(ggga1, (__m256i*) (dst +  8));
+            LASX_ST(ggga2, (__m256i*) (dst + 16));
+            LASX_ST(ggga3, (__m256i*) (dst + 24));
+
+            src += 32;
+            dst += 32;
+            count -= 32;
+        }
+        gray_to_RGB1_portable(dst, src, count);
+    }
 #else
     /*not static*/ inline void gray_to_RGB1(uint32_t dst[], const uint8_t* src, int count) {
         gray_to_RGB1_portable(dst, src, count);
@@ -1088,6 +1339,48 @@ static void RGB_to_BGR1_portable(uint32_t dst[], const uint8_t* src, int count)
         proc(dst, src, count);
     }
 
+    /*not static*/ inline void RGB_to_RGB1(uint32_t dst[], const uint8_t* src, int count) {
+        insert_alpha_should_swaprb(false, dst, src, count);
+    }
+    /*not static*/ inline void RGB_to_BGR1(uint32_t dst[], const uint8_t* src, int count) {
+        insert_alpha_should_swaprb(true, dst, src, count);
+    }
+#elif defined(SK_LA_HAS_LASX)
+    static void insert_alpha_should_swaprb(bool kSwapRB,
+                                           uint32_t dst[], const uint8_t* src, int count) {
+        const uint32_t tmp = 0xFF000000;
+        const __m256i alphaMask = __lasx_xvldrepl_w(&tmp, 0);
+
+        __m256i expand;
+        if (kSwapRB) {
+            expand = (__m256i){(long long)0x0503040502000102, (long long)0x0b090a0b08060708, (long long)0x110f10110e0c0d0e, (long long)0x1715161714121314};
+        } else {
+            expand = (__m256i){(long long)0x0505040302020100, (long long)0x0b0b0a0908080706, (long long)0x1111100f0e0e0d0c, (long long)0x1717161514141312};
+        }
+
+        while (count >= 8) {
+            // Load a vector.  While this actually contains 5 pixels plus an
+            // extra component, we will discard all but the first four pixels on
+            // this iteration.
+            __m256i rgb = LASX_LD((const __m256i*) src);
+            __m256i rgb_l = __lasx_xvpermi_d(rgb, 0x44);
+            __m256i rgb_h = __lasx_xvpermi_d(rgb, 0xEE);
+
+            // Expand the first four pixels to RGBX and then mask to RGB(FF).
+            __m256i rgba = __lasx_xvor_v(__lasx_xvshuf_b(rgb_h, rgb_l, expand), alphaMask);
+
+            // Store 8 pixels.
+            LASX_ST(rgba, (__m256i*) dst);
+
+            src += 4*6;
+            dst += 8;
+            count -= 8;
+        }
+
+        // Call portable code to finish up the tail of [0,4) pixels.
+        auto proc = kSwapRB ? RGB_to_BGR1_portable : RGB_to_RGB1_portable;
+        proc(dst, src, count);
+    }
     /*not static*/ inline void RGB_to_RGB1(uint32_t dst[], const uint8_t* src, int count) {
         insert_alpha_should_swaprb(false, dst, src, count);
     }
diff --git a/third_party/swiftshader/src/Reactor/SubzeroReactor.cpp b/third_party/swiftshader/src/Reactor/SubzeroReactor.cpp
index 0a4e9d2cea..ae9de4e8e2 100644
--- a/third_party/swiftshader/src/Reactor/SubzeroReactor.cpp
+++ b/third_party/swiftshader/src/Reactor/SubzeroReactor.cpp
@@ -309,6 +309,8 @@ private:
 		return false;
 #elif defined(__mips__)
 		return false;
+#elif defined(__loongarch64)
+		return false;
 #else
 #	error "Unknown architecture"
 #endif
@@ -659,6 +661,8 @@ std::vector<EntryPoint> loadImage(uint8_t *const elfImage, const std::vector<con
 	ASSERT(sizeof(void *) == 8 && elfHeader->e_machine == EM_AARCH64);
 #elif defined(__mips__)
 	ASSERT(sizeof(void *) == 4 && elfHeader->e_machine == EM_MIPS);
+#elif defined(__loongarch64)
+	//ASSERT(sizeof(void *) == 8 && elfHeader->e_machine == EM_LOONGARCH);
 #else
 #	error "Unsupported platform"
 #endif
diff --git a/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn b/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
index 59e52303c5..313fcd1831 100644
--- a/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
+++ b/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
@@ -158,6 +158,8 @@ swiftshader_llvm_source_set("swiftshader_llvm") {
     deps += [ ":swiftshader_llvm_riscv64" ]
   } else if (current_cpu == "x86" || current_cpu == "x64") {
     deps += [ ":swiftshader_llvm_x86" ]
+  } else if (current_cpu == "loong64") {
+    # TODO: Add support.
   } else {
     assert(false, "Unsupported current_cpu")
   }
diff --git a/ui/base/wayland/color_manager_util.h b/ui/base/wayland/color_manager_util.h
index fa1dd422c0..96c4dcd802 100644
--- a/ui/base/wayland/color_manager_util.h
+++ b/ui/base/wayland/color_manager_util.h
@@ -23,26 +23,44 @@ constexpr uint32_t kDefaultSinceVersion = 1;
 struct TransferFnVersion {
   skcms_TransferFunction transfer_fn;
   uint32_t version;
+  static constexpr TransferFnVersion Make(skcms_TransferFunction trans, uint32_t ver) {
+    return {trans, ver};
+  }
 };
 
 struct TransferVersion {
   gfx::ColorSpace::TransferID transfer;
   uint32_t version;
+  static constexpr TransferVersion Make(gfx::ColorSpace::TransferID trans, uint32_t ver) {
+    return {trans, ver};
+  }
 };
 
 struct PrimaryVersion {
   gfx::ColorSpace::PrimaryID primary;
   uint32_t version;
+  //PrimaryVersion(gfx::ColorSpace::PrimaryID pri, uint32_t ver) {
+  //  primary = pri; version = ver;
+  //}
+  static constexpr PrimaryVersion Make(gfx::ColorSpace::PrimaryID pri, uint32_t ver) {
+    return {pri, ver};
+  }
 };
 
 struct MatrixVersion {
   gfx::ColorSpace::MatrixID matrix;
   uint32_t version;
+  static constexpr MatrixVersion Make(gfx::ColorSpace::MatrixID matrix, uint32_t ver) {
+    return {matrix, ver};
+  }
 };
 
 struct RangeVersion {
   gfx::ColorSpace::RangeID range;
   uint32_t version;
+  static constexpr RangeVersion Make(gfx::ColorSpace::RangeID range, uint32_t ver) {
+    return {range, ver};
+  }
 };
 
 // A map from the zcr_color_manager_v1 chromaticity_names enum values
@@ -52,51 +70,51 @@ constexpr auto kChromaticityMap = base::MakeFixedFlatMap<
     zcr_color_manager_v1_chromaticity_names,
     PrimaryVersion>(
     {{ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT601_525_LINE,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::SMPTE170M,
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::SMPTE170M,
                      kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT601_625_LINE,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT470BG,
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::BT470BG,
                      kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTE170M,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::SMPTE170M,
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::SMPTE170M,
                      kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT709,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT709, kDefaultSinceVersion)},
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::BT709, kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT2020,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT2020, kDefaultSinceVersion)},
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::BT2020, kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SRGB,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT709, kDefaultSinceVersion)},
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::BT709, kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_DISPLAYP3,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::P3, kDefaultSinceVersion)},
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::P3, kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_ADOBERGB,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::ADOBE_RGB,
+      PrimaryVersion::Make(gfx::ColorSpace::PrimaryID::ADOBE_RGB,
                      kDefaultSinceVersion)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_WIDE_GAMUT_COLOR_SPIN,
-      PrimaryVersion(
+      PrimaryVersion::Make(
           gfx::ColorSpace::PrimaryID::WIDE_GAMUT_COLOR_SPIN,
           ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_WIDE_GAMUT_COLOR_SPIN_SINCE_VERSION)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT470M,
-      PrimaryVersion(
+      PrimaryVersion::Make(
           gfx::ColorSpace::PrimaryID::BT470M,
           ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT470M_SINCE_VERSION)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTE240M,
-      PrimaryVersion(
+      PrimaryVersion::Make(
           gfx::ColorSpace::PrimaryID::SMPTE240M,
           ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTE240M_SINCE_VERSION)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_XYZ_D50,
-      PrimaryVersion(
+      PrimaryVersion::Make(
           gfx::ColorSpace::PrimaryID::XYZ_D50,
           ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_XYZ_D50_SINCE_VERSION)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST428_1,
-      PrimaryVersion(
+      PrimaryVersion::Make(
           gfx::ColorSpace::PrimaryID::SMPTEST428_1,
           ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST428_1_SINCE_VERSION)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST431_2,
-      PrimaryVersion(
+      PrimaryVersion::Make(
           gfx::ColorSpace::PrimaryID::SMPTEST431_2,
           ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST431_2_SINCE_VERSION)},
      {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_FILM,
-      PrimaryVersion(
+      PrimaryVersion::Make(
           gfx::ColorSpace::PrimaryID::FILM,
           ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_FILM_SINCE_VERSION)}});
 
@@ -107,64 +125,64 @@ constexpr auto kEotfMap = base::MakeFixedFlatMap<
     zcr_color_manager_v1_eotf_names,
     TransferVersion>({
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR,
-     TransferVersion(gfx::ColorSpace::TransferID::LINEAR,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::LINEAR,
                      kDefaultSinceVersion)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB,
-     TransferVersion(gfx::ColorSpace::TransferID::SRGB, kDefaultSinceVersion)},
+     TransferVersion::Make(gfx::ColorSpace::TransferID::SRGB, kDefaultSinceVersion)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709,
-     TransferVersion(gfx::ColorSpace::TransferID::BT709,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::BT709,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2087,
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA24,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::GAMMA24,
                      kDefaultSinceVersion)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_ADOBERGB,
      // This is ever so slightly inaccurate. The number ought to be
      // 2.19921875f, not 2.2
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA22,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::GAMMA22,
                      kDefaultSinceVersion)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_PQ,
-     TransferVersion(gfx::ColorSpace::TransferID::PQ, kDefaultSinceVersion)},
+     TransferVersion::Make(gfx::ColorSpace::TransferID::PQ, kDefaultSinceVersion)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG,
-     TransferVersion(gfx::ColorSpace::TransferID::HLG,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::HLG,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE170M,
-     TransferVersion(gfx::ColorSpace::TransferID::SMPTE170M,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::SMPTE170M,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE170M_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE240M,
-     TransferVersion(gfx::ColorSpace::TransferID::SMPTE240M,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::SMPTE240M,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE240M_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTEST428_1,
-     TransferVersion(
+     TransferVersion::Make(
          gfx::ColorSpace::TransferID::SMPTEST428_1,
          ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTEST428_1_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG,
-     TransferVersion(gfx::ColorSpace::TransferID::LOG,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::LOG,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG_SQRT,
-     TransferVersion(gfx::ColorSpace::TransferID::LOG_SQRT,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::LOG_SQRT,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG_SQRT_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_IEC61966_2_4,
-     TransferVersion(
+     TransferVersion::Make(
          gfx::ColorSpace::TransferID::IEC61966_2_4,
          ZCR_COLOR_MANAGER_V1_EOTF_NAMES_IEC61966_2_4_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT1361_ECG,
-     TransferVersion(gfx::ColorSpace::TransferID::BT1361_ECG,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::BT1361_ECG,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT1361_ECG_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_10,
-     TransferVersion(gfx::ColorSpace::TransferID::BT2020_10,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::BT2020_10,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_10_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_12,
-     TransferVersion(gfx::ColorSpace::TransferID::BT2020_12,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::BT2020_12,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_12_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SCRGB_LINEAR_80_NITS,
-     TransferVersion(
+     TransferVersion::Make(
          gfx::ColorSpace::TransferID::SCRGB_LINEAR_80_NITS,
          ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SCRGB_LINEAR_80_NITS_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA18,
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA18,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::GAMMA18,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA18_SINCE_VERSION)},
     {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA28,
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA28,
+     TransferVersion::Make(gfx::ColorSpace::TransferID::GAMMA28,
                      ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA28_SINCE_VERSION)},
 });
 
@@ -174,17 +192,17 @@ constexpr auto kEotfMap = base::MakeFixedFlatMap<
 constexpr auto kTransferMap =
     base::MakeFixedFlatMap<zcr_color_manager_v1_eotf_names, TransferFnVersion>({
         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR,
-         TransferFnVersion(SkNamedTransferFn::kLinear, kDefaultSinceVersion)},
+         TransferFnVersion::Make(SkNamedTransferFn::kLinear, kDefaultSinceVersion)},
         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB,
-         TransferFnVersion(SkNamedTransferFnExt::kSRGB, kDefaultSinceVersion)},
+         TransferFnVersion::Make(SkNamedTransferFnExt::kSRGB, kDefaultSinceVersion)},
         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709,
-         TransferFnVersion(
+         TransferFnVersion::Make(
              SkNamedTransferFnExt::kRec709,
              ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709_SINCE_VERSION)},
         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2087,
-         TransferFnVersion(gamma24, kDefaultSinceVersion)},
+         TransferFnVersion::Make(gamma24, kDefaultSinceVersion)},
         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_ADOBERGB,
-         TransferFnVersion(SkNamedTransferFnExt::kA98RGB,
+         TransferFnVersion::Make(SkNamedTransferFnExt::kA98RGB,
                            kDefaultSinceVersion)},
     });
 
@@ -194,16 +212,16 @@ constexpr auto kTransferMap =
 constexpr auto kHDRTransferMap =
     base::MakeFixedFlatMap<zcr_color_manager_v1_eotf_names, TransferFnVersion>(
         {{ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR,
-          TransferFnVersion(SkNamedTransferFn::kLinear, kDefaultSinceVersion)},
+          TransferFnVersion::Make(SkNamedTransferFn::kLinear, kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB,
-          TransferFnVersion(SkNamedTransferFnExt::kSRGB, kDefaultSinceVersion)},
+          TransferFnVersion::Make(SkNamedTransferFnExt::kSRGB, kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_PQ,
-          TransferFnVersion(SkNamedTransferFn::kPQ, kDefaultSinceVersion)},
+          TransferFnVersion::Make(SkNamedTransferFn::kPQ, kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG,
-          TransferFnVersion(SkNamedTransferFn::kHLG,
+          TransferFnVersion::Make(SkNamedTransferFn::kHLG,
                             ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG_SINCE_VERSION)},
          {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_EXTENDEDSRGB10,
-          TransferFnVersion(
+          TransferFnVersion::Make(
               SkNamedTransferFnExt::kSRGBExtended1023Over510,
               ZCR_COLOR_MANAGER_V1_EOTF_NAMES_EXTENDEDSRGB10_SINCE_VERSION)}});
 
@@ -212,36 +230,36 @@ constexpr auto kHDRTransferMap =
 constexpr auto kMatrixMap =
     base::MakeFixedFlatMap<zcr_color_manager_v1_matrix_names, MatrixVersion>(
         {{ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_RGB,
-          MatrixVersion(gfx::ColorSpace::MatrixID::RGB, kDefaultSinceVersion)},
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::RGB, kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT709,
-          MatrixVersion(gfx::ColorSpace::MatrixID::BT709,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::BT709,
                         kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT470BG,
-          MatrixVersion(
+          MatrixVersion::Make(
               gfx::ColorSpace::MatrixID::BT470BG,
               ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT470BG_SINCE_VERSION)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT2020_NCL,
-          MatrixVersion(gfx::ColorSpace::MatrixID::BT2020_NCL,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::BT2020_NCL,
                         kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT2020_CL,
-          MatrixVersion(gfx::ColorSpace::MatrixID::BT2020_CL,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::BT2020_CL,
                         kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_FCC,
-          MatrixVersion(gfx::ColorSpace::MatrixID::FCC, kDefaultSinceVersion)},
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::FCC, kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YCOCG,
-          MatrixVersion(gfx::ColorSpace::MatrixID::YCOCG,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::YCOCG,
                         ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YCOCG_SINCE_VERSION)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YDZDX,
-          MatrixVersion(gfx::ColorSpace::MatrixID::YDZDX,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::YDZDX,
                         ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YDZDX_SINCE_VERSION)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_GBR,
-          MatrixVersion(gfx::ColorSpace::MatrixID::GBR,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::GBR,
                         ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_GBR_SINCE_VERSION)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_SMPTE170M,
-          MatrixVersion(gfx::ColorSpace::MatrixID::SMPTE170M,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::SMPTE170M,
                         kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_SMPTE240M,
-          MatrixVersion(gfx::ColorSpace::MatrixID::SMPTE240M,
+          MatrixVersion::Make(gfx::ColorSpace::MatrixID::SMPTE240M,
                         kDefaultSinceVersion)}});
 
 // A map from zcr_color_manager_v1 range_names enum values to
@@ -249,12 +267,12 @@ constexpr auto kMatrixMap =
 constexpr auto kRangeMap =
     base::MakeFixedFlatMap<zcr_color_manager_v1_range_names, RangeVersion>(
         {{ZCR_COLOR_MANAGER_V1_RANGE_NAMES_LIMITED,
-          RangeVersion(gfx::ColorSpace::RangeID::LIMITED,
+          RangeVersion::Make(gfx::ColorSpace::RangeID::LIMITED,
                        kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_RANGE_NAMES_FULL,
-          RangeVersion(gfx::ColorSpace::RangeID::FULL, kDefaultSinceVersion)},
+          RangeVersion::Make(gfx::ColorSpace::RangeID::FULL, kDefaultSinceVersion)},
          {ZCR_COLOR_MANAGER_V1_RANGE_NAMES_DERIVED,
-          RangeVersion(gfx::ColorSpace::RangeID::DERIVED,
+          RangeVersion::Make(gfx::ColorSpace::RangeID::DERIVED,
                        kDefaultSinceVersion)}});
 
 zcr_color_manager_v1_chromaticity_names ToColorManagerChromaticity(
@@ -278,4 +296,4 @@ zcr_color_manager_v1_eotf_names ToColorManagerEOTF(gfx::ColorSpace color_space,
 
 }  // namespace ui::wayland
 
-#endif  // UI_BASE_WAYLAND_COLOR_MANAGER_UTIL_H_
\ No newline at end of file
+#endif  // UI_BASE_WAYLAND_COLOR_MANAGER_UTIL_H_
diff --git a/ui/gfx/linux/drm_util_linux.cc b/ui/gfx/linux/drm_util_linux.cc
index 7abc662bae..602fb0ef21 100644
--- a/ui/gfx/linux/drm_util_linux.cc
+++ b/ui/gfx/linux/drm_util_linux.cc
@@ -6,6 +6,13 @@
 
 #include <drm_fourcc.h>
 
+#if defined(__loongarch64)
+// libdrm-dev
+#ifndef DRM_FORMAT_P010
+#define DRM_FORMAT_P010 fourcc_code('P', '0', '1', '0')
+#endif
+#endif
+
 #include "base/notreached.h"
 
 namespace ui {
-- 
2.25.1

