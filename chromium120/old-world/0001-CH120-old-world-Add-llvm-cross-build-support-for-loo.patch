From ac2cebce3d36c809dc5c7add5a445dbaad8f9433 Mon Sep 17 00:00:00 2001
From: Wang Qing <wangqing-hf@loongson.cn>
Date: Fri, 1 Dec 2023 18:04:22 +0800
Subject: [PATCH] [CH120-old-world] Add llvm cross build support for
 loongarch64.

---
 base/containers/map_util.h                    |    4 +-
 .../metrics/persistent_histogram_allocator.cc |   10 +-
 base/system/sys_info.cc                       |    2 +
 base/trace_event/trace_log.cc                 |    7 +-
 build/config/clang/clang.gni                  |    6 +-
 build/config/compiler/BUILD.gn                |   18 +-
 build/config/posix/BUILD.gn                   |    2 +-
 build/config/sysroot.gni                      |    2 +
 build/cross-build.sh                          |   43 +
 .../one_time_permission_provider.cc           |   14 +-
 .../bubble/download_bubble_update_service.cc  |    6 +-
 .../profile_management_navigation_throttle.cc |    8 +-
 .../ui/omnibox/chrome_omnibox_client.cc       |   12 +-
 .../safety_hub/menu_notification_service.cc   |    6 +-
 .../embedded_permission_prompt_ask_view.cc    |   20 +-
 .../embedded_permission_prompt_base_view.h    |    2 +-
 .../embedded_permission_prompt_policy_view.cc |   12 +-
 ...ermission_prompt_previously_denied_view.cc |   22 +-
 ...rmission_prompt_previously_granted_view.cc |   16 +-
 chrome/installer/linux/common/apt.include     |    2 +
 chrome/installer/linux/common/rpm.include     |    2 +-
 chrome/installer/linux/debian/build.sh        |    2 +-
 .../linux/debian/calculate_package_deps.py    |    3 +
 chrome/installer/linux/rpm/build.sh           |    2 +-
 .../core/browser/contact_info_sync_util.cc    |    7 +-
 .../core/browser/webdata/autofill_table.cc    |   10 +-
 .../metrics/debug/metrics_internals_utils.cc  |    2 +
 .../core/tflite_model_executor.h              |   10 +-
 .../core/browser/password_manager.cc          |    5 +-
 .../core/browser/proto_fetcher.cc             |    6 +-
 .../core/browser/proto_fetcher.h              |    4 +-
 components/variations/proto/study.proto       |    2 +
 .../variations_field_trial_creator_base.cc    |    3 +
 .../skia_output_surface_impl_on_gpu.cc        |    2 +-
 content/browser/download/save_package.cc      |    7 +-
 .../interest_group/interest_group_storage.cc  |    9 +-
 .../renderer_host/render_frame_host_impl.cc   |   21 +-
 .../service_worker_context_wrapper.cc         |    7 +-
 ...web_ui_browser_interface_broker_registry.h |    6 +-
 media/base/cdm_promise_adapter.cc             |    9 +-
 net/dns/host_resolver_cache.cc                |    5 +-
 net/dns/host_resolver_cache.h                 |   12 +-
 sandbox/features.gni                          |    3 +-
 sandbox/linux/BUILD.gn                        |    1 +
 sandbox/linux/bpf_dsl/linux_syscall_ranges.h  |    7 +
 sandbox/linux/bpf_dsl/seccomp_macros.h        |   42 +
 .../bpf_dsl_seccomp_unittest.cc               |    7 +-
 .../seccomp-bpf-helpers/baseline_policy.cc    |    8 +-
 .../baseline_policy_unittest.cc               |    8 +-
 .../syscall_parameters_restrictions.cc        |    7 +-
 .../linux/seccomp-bpf-helpers/syscall_sets.cc |   57 +-
 .../linux/seccomp-bpf-helpers/syscall_sets.h  |   16 +-
 sandbox/linux/seccomp-bpf/syscall.cc          |   32 +-
 sandbox/linux/seccomp-bpf/syscall_unittest.cc |    1 +
 sandbox/linux/services/credentials.cc         |    2 +-
 sandbox/linux/services/syscall_wrappers.cc    |    2 +-
 .../linux/syscall_broker/broker_process.cc    |   18 +-
 .../syscall_broker/broker_process_unittest.cc |    2 +
 .../remote_syscall_arg_handler_unittest.cc    |    4 +
 sandbox/linux/system_headers/linux_seccomp.h  |    8 +
 sandbox/linux/system_headers/linux_signal.h   |    5 +-
 sandbox/linux/system_headers/linux_stat.h     |    2 +-
 sandbox/linux/system_headers/linux_syscalls.h |    4 +
 .../loongarch64_linux_syscalls.h              | 1221 +++++++++++++++++
 .../linux/bpf_cros_amd_gpu_policy_linux.cc    |    2 +-
 sandbox/policy/linux/bpf_gpu_policy_linux.cc  |    2 +-
 .../policy/linux/bpf_network_policy_linux.cc  |    2 +-
 skia/BUILD.gn                                 |    2 +
 .../bindings/core/v8/async_iterable.h         |    4 +-
 .../parser/html_document_parser_fastpath.cc   |    2 +-
 .../core/layout/grid/grid_layout_algorithm.cc |   12 +-
 .../paint/object_paint_properties_sparse.h    |    4 +-
 .../modules/canvas/canvas2d/canvas_style.cc   |   10 +-
 .../service_worker_global_scope.cc            |    8 +-
 third_party/blink/renderer/platform/BUILD.gn  |    2 +-
 .../renderer/platform/fonts/font_palette.h    |   12 +-
 .../platform/fonts/palette_interpolation.cc   |    4 +-
 .../boringssl/src/include/openssl/target.h    |    3 +
 .../crashpad/client/crashpad_client_linux.cc  |    4 +
 .../crashpad/minidump/minidump_context.h      |   51 +
 .../minidump/minidump_context_writer.cc       |   46 +
 .../minidump/minidump_context_writer.h        |   38 +
 .../minidump/minidump_context_writer_test.cc  |   16 +
 .../crashpad/minidump/minidump_extensions.h   |    6 +
 .../minidump/minidump_misc_info_writer.cc     |    2 +
 .../minidump/minidump_system_info_writer.cc   |    3 +
 .../test/minidump_context_test_util.cc        |   46 +
 .../test/minidump_context_test_util.h         |    5 +
 .../crashpad/snapshot/capture_memory.cc       |    2 +-
 .../crashpad/snapshot/cpu_architecture.h      |    3 +
 .../crashpad/crashpad/snapshot/cpu_context.cc |    2 +
 .../crashpad/crashpad/snapshot/cpu_context.h  |   16 +
 .../snapshot/linux/cpu_context_linux.cc       |   17 +
 .../snapshot/linux/cpu_context_linux.h        |   17 +
 .../linux/exception_snapshot_linux.cc         |   59 +-
 .../snapshot/linux/exception_snapshot_linux.h |    2 +
 .../linux/exception_snapshot_linux_test.cc    |   21 +
 .../snapshot/linux/process_reader_linux.cc    |    2 +
 .../crashpad/snapshot/linux/signal_context.h  |   41 +
 .../snapshot/linux/system_snapshot_linux.cc   |    8 +
 .../snapshot/linux/thread_snapshot_linux.cc   |    7 +
 .../snapshot/linux/thread_snapshot_linux.h    |    2 +
 .../minidump/minidump_context_converter.cc    |   24 +
 .../snapshot/test/test_cpu_context.cc         |   25 +
 .../crashpad/snapshot/test/test_cpu_context.h |    1 +
 .../crashpad/crashpad/test/linux/get_tls.cc   |    3 +
 .../crashpad/crashpad/util/linux/ptracer.cc   |   42 +
 .../crashpad/util/linux/thread_info.h         |   20 +-
 .../util/net/http_transport_libcurl.cc        |    2 +
 third_party/ffmpeg/BUILD.gn                   |    4 +
 .../ffmpeg/chromium/scripts/build_ffmpeg.py   |   49 +-
 .../ffmpeg/chromium/scripts/copy_config.sh    |    2 +-
 .../ffmpeg/chromium/scripts/generate_gn.py    |   10 +-
 third_party/lss/linux_syscall_support.h       |  292 ++--
 .../fpdfapi/render/cpdf_imagerenderer.cpp     |    2 +-
 .../fpdfapi/render/cpdf_rendershading.cpp     |   10 +-
 .../core/fpdfapi/render/cpdf_renderstatus.cpp |   60 +-
 .../pdfium/core/fxge/cfx_fillrenderoptions.h  |   25 +
 .../pdfium/core/fxge/cfx_renderdevice.cpp     |   50 +-
 third_party/pdfium/fpdfsdk/cpdfsdk_widget.cpp |    2 +-
 third_party/pdfium/fpdfsdk/pwl/cpwl_caret.cpp |    2 +-
 .../pdfium/fpdfsdk/pwl/cpwl_cbbutton.cpp      |    2 +-
 third_party/pdfium/fpdfsdk/pwl/cpwl_edit.cpp  |    2 +-
 .../pdfium/fpdfsdk/pwl/cpwl_edit_impl.cpp     |    2 +-
 .../pdfium/fxbarcode/BC_TwoDimWriter.cpp      |    5 +-
 .../pdfium/fxbarcode/oned/BC_OneDimWriter.cpp |    5 +-
 .../xfa/fgas/graphics/cfgas_gegraphics.cpp    |    2 +-
 third_party/pdfium/xfa/fxfa/cxfa_ffwidget.cpp |    4 +-
 .../protobuf/src/google/protobuf/port_def.inc |    2 +-
 third_party/skia/BUILD.gn                     |    1 +
 third_party/skia/src/core/SkRasterPipeline.h  |    2 +-
 .../swiftshader/src/Reactor/reactor.gni       |    2 +-
 .../third_party/llvm-10.0/BUILD.gn            |    7 +
 .../llvm-subzero/include/llvm/Support/ELF.h   |    1 +
 third_party/webrtc/rtc_base/system/arch.h     |   10 +-
 ui/base/wayland/color_manager_util.cc         |   64 +-
 ui/base/wayland/color_manager_util.h          |  286 +---
 ui/gfx/linux/drm_util_linux.cc                |   10 +
 ui/gtk/gtk_ui.cc                              |    8 +-
 .../wayland/host/wayland_zcr_color_manager.cc |   15 +-
 .../wayland/host/wayland_zcr_color_space.cc   |   18 +-
 141 files changed, 2650 insertions(+), 715 deletions(-)
 create mode 100755 build/cross-build.sh
 create mode 100644 sandbox/linux/system_headers/loongarch64_linux_syscalls.h

diff --git a/base/containers/map_util.h b/base/containers/map_util.h
index 35ce4d72d4b..ecfcfe1c3f4 100644
--- a/base/containers/map_util.h
+++ b/base/containers/map_util.h
@@ -42,7 +42,7 @@ constexpr internal::MappedType<Map>* FindOrNull(Map& map, const Key& key) {
 template <typename Map,
           typename Key,
           typename MappedElementType =
-              std::pointer_traits<internal::MappedType<Map>>::element_type>
+              typename std::pointer_traits<internal::MappedType<Map>>::element_type>
 constexpr const MappedElementType* FindPtrOrNull(const Map& map,
                                                  const Key& key) {
   auto it = map.find(key);
@@ -58,7 +58,7 @@ constexpr const MappedElementType* FindPtrOrNull(const Map& map,
 template <typename Map,
           typename Key,
           typename MappedElementType =
-              std::pointer_traits<internal::MappedType<Map>>::element_type>
+              typename std::pointer_traits<internal::MappedType<Map>>::element_type>
 constexpr MappedElementType* FindPtrOrNull(Map& map, const Key& key) {
   auto it = map.find(key);
   return it != map.end() ? std::to_address(it->second) : nullptr;
diff --git a/base/metrics/persistent_histogram_allocator.cc b/base/metrics/persistent_histogram_allocator.cc
index de2c8148ada..0e327d3cf89 100644
--- a/base/metrics/persistent_histogram_allocator.cc
+++ b/base/metrics/persistent_histogram_allocator.cc
@@ -221,13 +221,19 @@ PersistentSparseHistogramDataManager::LoadRecords(
     // The sample-record could be for any sparse histogram. Add the reference
     // to the appropriate collection for later use.
     if (found_id == match_id) {
-      found_records.emplace_back(ref, value);
+      PersistentSparseHistogramDataManager::ReferenceAndSample record;
+      record.reference = ref;
+      record.value = value;
+      found_records.emplace_back(record);
       found = true;
     } else {
       std::vector<ReferenceAndSample>* samples =
           GetSampleMapRecordsWhileLocked(found_id);
       CHECK(samples);
-      samples->emplace_back(ref, value);
+      PersistentSparseHistogramDataManager::ReferenceAndSample sample;
+      sample.reference = ref;
+      sample.value = value;
+      samples->emplace_back(sample);
     }
   }
 
diff --git a/base/system/sys_info.cc b/base/system/sys_info.cc
index 82cebf2ccaf..abeeb340682 100644
--- a/base/system/sys_info.cc
+++ b/base/system/sys_info.cc
@@ -255,6 +255,8 @@ std::string SysInfo::ProcessCPUArchitecture() {
   return "ARM";
 #elif defined(ARCH_CPU_ARM64)
   return "ARM_64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+  return "LOONGARCH64";
 #else
   return std::string();
 #endif
diff --git a/base/trace_event/trace_log.cc b/base/trace_event/trace_log.cc
index dd3b5dbe5ec..8154948ca13 100644
--- a/base/trace_event/trace_log.cc
+++ b/base/trace_event/trace_log.cc
@@ -2191,8 +2191,11 @@ void TraceLog::SetTraceBufferForTesting(
 #if BUILDFLAG(USE_PERFETTO_CLIENT_LIBRARY)
 void TraceLog::OnSetup(const perfetto::DataSourceBase::SetupArgs& args) {
   AutoLock lock(track_event_lock_);
-  track_event_sessions_.emplace_back(args.internal_instance_index, *args.config,
-                                     args.backend_type);
+  TrackEventSession session;
+  session.internal_instance_index = args.internal_instance_index; 
+  session.config = *args.config;
+  session.backend_type = args.backend_type;
+  track_event_sessions_.emplace_back(session);
 }
 
 void TraceLog::OnStart(const perfetto::DataSourceBase::StartArgs&) {
diff --git a/build/config/clang/clang.gni b/build/config/clang/clang.gni
index 96cf72d8272..d03353b547a 100644
--- a/build/config/clang/clang.gni
+++ b/build/config/clang/clang.gni
@@ -5,7 +5,11 @@
 import("//build/config/chromeos/ui_mode.gni")
 import("//build/toolchain/toolchain.gni")
 
-default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+if (current_cpu == "loong64") {
+  default_clang_base_path = "/opt/llvm_chromium/llvm_install_15.0.7"
+} else {
+  default_clang_base_path = "//third_party/llvm-build/Release+Asserts"
+}
 
 declare_args() {
   # Indicates if the build should use the Chrome-specific plugins for enforcing
diff --git a/build/config/compiler/BUILD.gn b/build/config/compiler/BUILD.gn
index 80bc79e5fb3..a42314c4d9e 100644
--- a/build/config/compiler/BUILD.gn
+++ b/build/config/compiler/BUILD.gn
@@ -202,7 +202,7 @@ declare_args() {
   # This greatly reduces the size of debug builds, at the cost of
   # debugging information which is required by some specialized
   # debugging tools.
-  simple_template_names = is_clang && !is_nacl && !is_win && !is_apple
+  simple_template_names = is_clang && !is_nacl && !is_win && !is_apple && target_cpu != "loong64"
 }
 
 declare_args() {
@@ -620,7 +620,7 @@ config("compiler") {
     # other problems.
     # TODO(crbug.com/1491036): This isn't supported by Cronet's mainline llvm version.
     if (default_toolchain != "//build/toolchain/cros:target" &&
-        !llvm_android_mainline) {
+        !llvm_android_mainline && target_cpu != "loong64") {
       cflags += [
         "-mllvm",
         "-split-threshold-for-reg-with-hint=0",
@@ -1445,8 +1445,8 @@ config("compiler_cpu_abi") {
         ldflags += [ "--target=loongarch64-linux-gnu" ]
       }
       cflags += [
-        "-mabi=lp64d",
-        "-mcmodel=medium",
+        #"-mabi=lp64d",
+        "-mcmodel=large",
       ]
     } else if (current_cpu == "s390x") {
       cflags += [ "-m64" ]
@@ -1531,7 +1531,7 @@ config("compiler_deterministic") {
         "-Xclang",
         ".",
       ]
-    } else {
+    } else if (target_cpu != "loong64") {
       # -ffile-compilation-dir is an alias for both -fdebug-compilation-dir=
       # and -fcoverage-compilation-dir=.
       cflags += [ "-ffile-compilation-dir=." ]
@@ -1850,6 +1850,10 @@ config("default_warnings") {
           # TODO(https://crbug.com/1474434): fix and reenable
           "-Wno-missing-field-initializers",
         ]
+        if (target_cpu == "loong64") {
+          # < clang16 in loongarch.
+          cflags -= [ "-Wno-deprecated-builtins" ]
+        }
       }
 
       cflags += [
@@ -1878,10 +1882,10 @@ config("default_warnings") {
           "-Wno-vla-extension",
 
           # TODO(https://crbug.com/1490607): Fix and re-enable.
-          "-Wno-thread-safety-reference-return",
+          #"-Wno-thread-safety-reference-return",
 
           # TODO(crbug.com/1495100): Evaluate and possibly enable.
-          "-Wno-delayed-template-parsing-in-cxx20",
+          #"-Wno-delayed-template-parsing-in-cxx20",
         ]
       }
     }
diff --git a/build/config/posix/BUILD.gn b/build/config/posix/BUILD.gn
index 8312d7ecf62..1e83b3f8532 100644
--- a/build/config/posix/BUILD.gn
+++ b/build/config/posix/BUILD.gn
@@ -28,7 +28,7 @@ config("runtime_library") {
   if (!is_apple && sysroot != "" && current_os != "zos") {
     # Pass the sysroot to all C compiler variants, the assembler, and linker.
     sysroot_flags = [ "--sysroot=" + rebase_path(sysroot, root_build_dir) ]
-    if (is_linux || is_chromeos) {
+    if ((is_linux && current_cpu != "loong64") || is_chromeos) {
       # This is here so that all files get recompiled after a sysroot roll and
       # when turning the sysroot on or off. (defines are passed via the command
       # line, and build system rebuilds things when their commandline
diff --git a/build/config/sysroot.gni b/build/config/sysroot.gni
index 0f36edd9e5b..ba7841bdd5e 100644
--- a/build/config/sysroot.gni
+++ b/build/config/sysroot.gni
@@ -49,6 +49,8 @@ if (sysroot == "") {
       sysroot = "$target_sysroot_dir/debian_bullseye_armhf-sysroot"
     } else if (current_cpu == "arm64") {
       sysroot = "$target_sysroot_dir/debian_bullseye_arm64-sysroot"
+    } else if (current_cpu == "loong64") {
+      sysroot = "$target_sysroot_dir/debian_bullseye_loong64-sysroot"
     } else {
       assert(false, "No linux sysroot for cpu: $target_cpu")
     }
diff --git a/build/cross-build.sh b/build/cross-build.sh
new file mode 100755
index 00000000000..ec91e227fa8
--- /dev/null
+++ b/build/cross-build.sh
@@ -0,0 +1,43 @@
+#! /bin/bash
+
+# Chromium build configuration description.
+# Author: Wang Qing <wangqing-hf@loongson.cn>
+
+# Set gn args to build.
+export GN_CONFIG=(
+'google_api_key = "AIzaSyDxKL42zsPjbke5O8_rPVpVrLrJ8aeE9rQ"'
+'google_default_client_id =
+    "595013732528-llk8trb03f0ldpqq6nprjp1s79596646.apps.googleusercontent.com"'
+'google_default_client_secret = "5ntt6GbbkjnTVXx-MSxbmx5e"'
+'enable_hangout_services_extension=true'
+'enable_nacl=false'
+'enable_swiftshader=false'
+'angle_enable_swiftshader=false'
+'enable_swiftshader_vulkan=false'
+'dawn_use_swiftshader=false'
+'enable_widevine=false'
+'fatal_linker_warnings=false'
+'disable_fieldtrial_testing_config=true'
+'ffmpeg_branding="Chrome"'
+'proprietary_codecs=true'
+'is_debug=false'
+'use_gold=false'
+'is_clang=true'
+'clang_use_chrome_plugins=false'
+'link_pulseaudio=true'
+'symbol_level=0'
+'treat_warnings_as_errors=false'
+'use_pulseaudio=true'
+'use_sysroot=true'
+'use_qt6=false'
+'host_cpu = "x64"'
+'target_cpu = "loong64"'
+'v8_target_cpu = "loong64"'
+'enable_libaom=false'
+'enable_rust=false')
+
+# Set build directory.
+root_build_dir="out/la64_cross"
+
+# generate root_build_dir to build.
+./buildtools/linux64/gn gen $root_build_dir --args="${GN_CONFIG[*]}"
diff --git a/chrome/browser/content_settings/one_time_permission_provider.cc b/chrome/browser/content_settings/one_time_permission_provider.cc
index d682631d5b2..be0a9c20789 100644
--- a/chrome/browser/content_settings/one_time_permission_provider.cc
+++ b/chrome/browser/content_settings/one_time_permission_provider.cc
@@ -226,8 +226,11 @@ void OneTimePermissionProvider::OnSuspend() {
 
       while (rule_iterator && rule_iterator->HasNext()) {
         auto rule = rule_iterator->Next();
-        patterns_to_delete.emplace_back(setting_type, rule->primary_pattern,
-                                        rule->secondary_pattern);
+	ContentSettingEntry entry;
+	entry.type = setting_type;
+	entry.primary_pattern = rule->primary_pattern;
+	entry.secondary_pattern = rule->secondary_pattern;
+        patterns_to_delete.emplace_back(entry);
         permissions::PermissionUmaUtil::RecordOneTimePermissionEvent(
             setting_type,
             permissions::OneTimePermissionEvent::EXPIRED_ON_SUSPEND);
@@ -329,8 +332,11 @@ void OneTimePermissionProvider::DeleteEntriesMatchingGURL(
     auto rule = rule_iterator->Next();
     if (rule->primary_pattern.Matches(origin_gurl) &&
         rule->secondary_pattern.Matches(origin_gurl)) {
-      patterns_to_delete.emplace_back(
-          content_setting_type, rule->primary_pattern, rule->secondary_pattern);
+      ContentSettingEntry entry;
+      entry.type = content_setting_type;
+      entry.primary_pattern = rule->primary_pattern;
+      entry.secondary_pattern = rule->secondary_pattern;
+      patterns_to_delete.emplace_back(entry);
       permissions::PermissionUmaUtil::RecordOneTimePermissionEvent(
           content_setting_type, trigger_event);
     }
diff --git a/chrome/browser/download/bubble/download_bubble_update_service.cc b/chrome/browser/download/bubble/download_bubble_update_service.cc
index 3fb1520f887..7d1723f89c2 100644
--- a/chrome/browser/download/bubble/download_bubble_update_service.cc
+++ b/chrome/browser/download/bubble/download_bubble_update_service.cc
@@ -89,7 +89,7 @@ ItemSortKey GetSortKey(const Item& item) {
 // Helper to get an iterator to the last element in the cache. The cache
 // must not be empty.
 template <typename Item>
-SortedItems<Item>::const_iterator GetLastIter(const SortedItems<Item>& cache) {
+typename SortedItems<Item>::const_iterator GetLastIter(const SortedItems<Item>& cache) {
   CHECK(!cache.empty());
   auto it = cache.end();
   return std::prev(it);
@@ -1089,9 +1089,9 @@ bool DownloadBubbleUpdateService::CacheManager::RemoveItemFromCacheImpl(
 }
 
 template <typename Id, typename Item>
-SortedItems<Item>::iterator
+typename SortedItems<Item>::iterator
 DownloadBubbleUpdateService::CacheManager::RemoveItemFromCacheByIter(
-    SortedItems<Item>::iterator iter,
+    typename SortedItems<Item>::iterator iter,
     SortedItems<Item>& cache,
     IterMap<Id, Item>& iter_map) {
   CHECK(iter != cache.end());
diff --git a/chrome/browser/enterprise/profile_management/profile_management_navigation_throttle.cc b/chrome/browser/enterprise/profile_management/profile_management_navigation_throttle.cc
index aecaaf76762..ab4e13c7993 100644
--- a/chrome/browser/enterprise/profile_management/profile_management_navigation_throttle.cc
+++ b/chrome/browser/enterprise/profile_management/profile_management_navigation_throttle.cc
@@ -65,10 +65,12 @@ base::flat_map<std::string, SAMLProfileAttributes>& GetAttributeMap() {
   }
 
   // TODO(crbug.com/1445072): Add actual domains with attribute names.
+  SAMLProfileAttributes attr;
+  attr.name = "placeholderName";
+  attr.domain = "placeholderDomain";
+  attr.token = "placeholderToken";
   profile_attributes->insert(std::make_pair(
-      "supported.test",
-      SAMLProfileAttributes("placeholderName", "placeholderDomain",
-                            "placeholderToken")));
+      "supported.test", attr));
 
   // Extract domains and attributes from the command line switch.
   const base::CommandLine& command_line =
diff --git a/chrome/browser/ui/omnibox/chrome_omnibox_client.cc b/chrome/browser/ui/omnibox/chrome_omnibox_client.cc
index 8fa4739375b..ce79b4e7d63 100644
--- a/chrome/browser/ui/omnibox/chrome_omnibox_client.cc
+++ b/chrome/browser/ui/omnibox/chrome_omnibox_client.cc
@@ -474,10 +474,14 @@ void ChromeOmniboxClient::OnAutocompleteAccept(
               alternative_nav_match);
 
   // Store the details necessary to open the omnibox match via browser commands.
-  location_bar_->set_navigation_params(LocationBar::NavigationParams(
-      destination_url, disposition, transition, match_selection_timestamp,
-      destination_url_entered_without_scheme,
-      destination_url_entered_with_http_scheme));
+  LocationBar::NavigationParams params;
+  params.destination_url = destination_url;
+  params.disposition = disposition;
+  params.transition = transition;
+  params.match_selection_timestamp = match_selection_timestamp;
+  params.url_typed_without_scheme = destination_url_entered_without_scheme;
+  params.url_typed_with_http_scheme = destination_url_entered_with_http_scheme;
+  location_bar_->set_navigation_params(params);
 
   if (browser_) {
     auto navigation = chrome::OpenCurrentURL(browser_);
diff --git a/chrome/browser/ui/safety_hub/menu_notification_service.cc b/chrome/browser/ui/safety_hub/menu_notification_service.cc
index 58890d60b3b..99e21d33fb6 100644
--- a/chrome/browser/ui/safety_hub/menu_notification_service.cc
+++ b/chrome/browser/ui/safety_hub/menu_notification_service.cc
@@ -130,8 +130,10 @@ SafetyHubMenuNotificationService::GetNotificationToShow() {
   // The information related to showing the notification needs to be persisted
   // as well.
   SaveNotificationsToPrefs();
-  return MenuNotificationEntry(notification_to_show->GetNotificationCommandId(),
-                               notification_to_show->GetNotificationString());
+  MenuNotificationEntry menu_notification_entry;
+  menu_notification_entry.command = notification_to_show->GetNotificationCommandId();
+  menu_notification_entry.label = notification_to_show->GetNotificationString();
+  return menu_notification_entry;
 }
 
 absl::optional<ResultMap>
diff --git a/chrome/browser/ui/views/permissions/embedded_permission_prompt_ask_view.cc b/chrome/browser/ui/views/permissions/embedded_permission_prompt_ask_view.cc
index bf68de944df..5de02a6fa73 100644
--- a/chrome/browser/ui/views/permissions/embedded_permission_prompt_ask_view.cc
+++ b/chrome/browser/ui/views/permissions/embedded_permission_prompt_ask_view.cc
@@ -45,8 +45,10 @@ EmbeddedPermissionPromptAskView::GetRequestLinesConfiguration() const {
   std::vector<RequestLineConfiguration> lines;
 
   for (auto* request : delegate()->Requests()) {
-    lines.emplace_back(&permissions::GetIconId(request->request_type()),
-                       request->GetMessageTextFragment());
+    RequestLineConfiguration line;
+    line.icon = &permissions::GetIconId(request->request_type());
+    line.message = request->GetMessageTextFragment();
+    lines.emplace_back(line);
   }
   return lines;
 }
@@ -54,13 +56,17 @@ EmbeddedPermissionPromptAskView::GetRequestLinesConfiguration() const {
 std::vector<EmbeddedPermissionPromptAskView::ButtonConfiguration>
 EmbeddedPermissionPromptAskView::GetButtonsConfiguration() const {
   std::vector<ButtonConfiguration> buttons;
+  ButtonConfiguration button;
   if (base::FeatureList::IsEnabled(permissions::features::kOneTimePermission)) {
-    buttons.emplace_back(
-        l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW_THIS_TIME),
-        ButtonType::kAllowThisTime, ui::ButtonStyle::kTonal);
+    button.label = l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW_THIS_TIME);
+    button.type = ButtonType::kAllowThisTime;
+    button.style = ui::ButtonStyle::kTonal;
   }
-  buttons.emplace_back(l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW),
-                       ButtonType::kAllow, ui::ButtonStyle::kTonal);
+  button.label = l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW);
+  button.type = ButtonType::kAllow;
+  button.style = ui::ButtonStyle::kTonal;
+
+  buttons.emplace_back(button);
   return buttons;
 }
 
diff --git a/chrome/browser/ui/views/permissions/embedded_permission_prompt_base_view.h b/chrome/browser/ui/views/permissions/embedded_permission_prompt_base_view.h
index d48a6785786..c185e2e0f3b 100644
--- a/chrome/browser/ui/views/permissions/embedded_permission_prompt_base_view.h
+++ b/chrome/browser/ui/views/permissions/embedded_permission_prompt_base_view.h
@@ -72,7 +72,7 @@ class EmbeddedPermissionPromptBaseView : public PermissionPromptBaseView {
   };
 
   struct RequestLineConfiguration {
-    const raw_ptr<const gfx::VectorIcon> icon;
+    raw_ptr<const gfx::VectorIcon> icon;
     std::u16string message;
   };
 
diff --git a/chrome/browser/ui/views/permissions/embedded_permission_prompt_policy_view.cc b/chrome/browser/ui/views/permissions/embedded_permission_prompt_policy_view.cc
index 82ade727074..44ae2742b58 100644
--- a/chrome/browser/ui/views/permissions/embedded_permission_prompt_policy_view.cc
+++ b/chrome/browser/ui/views/permissions/embedded_permission_prompt_policy_view.cc
@@ -40,7 +40,10 @@ void EmbeddedPermissionPromptPolicyView::RunButtonCallback(int button_id) {
 std::vector<EmbeddedPermissionPromptPolicyView::RequestLineConfiguration>
 EmbeddedPermissionPromptPolicyView::GetRequestLinesConfiguration() const {
   std::vector<RequestLineConfiguration> lines;
-  lines.emplace_back(&vector_icons::kBusinessIcon, GetMessageText());
+  RequestLineConfiguration line;
+  line.icon = &vector_icons::kBusinessIcon;
+  line.message = GetMessageText();
+  lines.emplace_back(line);
 
   return lines;
 }
@@ -48,8 +51,11 @@ EmbeddedPermissionPromptPolicyView::GetRequestLinesConfiguration() const {
 std::vector<EmbeddedPermissionPromptPolicyView::ButtonConfiguration>
 EmbeddedPermissionPromptPolicyView::GetButtonsConfiguration() const {
   std::vector<ButtonConfiguration> buttons;
-  buttons.emplace_back(l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_OK_LABEL),
-                       ButtonType::kPolicyOK, ui::ButtonStyle::kTonal);
+  ButtonConfiguration button;
+  button.label = l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_OK_LABEL);
+  button.type = ButtonType::kPolicyOK;
+  button.style = ui::ButtonStyle::kTonal;
+  buttons.emplace_back(button);
   return buttons;
 }
 
diff --git a/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_denied_view.cc b/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_denied_view.cc
index 288df4b3601..127b2f0cf88 100644
--- a/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_denied_view.cc
+++ b/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_denied_view.cc
@@ -63,19 +63,23 @@ EmbeddedPermissionPromptPreviouslyDeniedView::GetRequestLinesConfiguration()
 std::vector<EmbeddedPermissionPromptPreviouslyDeniedView::ButtonConfiguration>
 EmbeddedPermissionPromptPreviouslyDeniedView::GetButtonsConfiguration() const {
   std::vector<ButtonConfiguration> buttons;
-  buttons.emplace_back(
-      l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_CONTINUE_NOT_ALLOWING),
-      ButtonType::kContinueNotAllowing, ui::ButtonStyle::kTonal);
+  ButtonConfiguration button;
+  button.label = l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_CONTINUE_NOT_ALLOWING);
+  button.type = ButtonType::kContinueNotAllowing;
+  button.style = ui::ButtonStyle::kTonal;
+  buttons.emplace_back(button);
 
   if (base::FeatureList::IsEnabled(permissions::features::kOneTimePermission)) {
-    buttons.emplace_back(
-        l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW_THIS_TIME),
-        ButtonType::kAllowThisTime, ui::ButtonStyle::kTonal);
+    button.label = l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW_THIS_TIME);
+    button.type = ButtonType::kAllowThisTime;
+    button.style = ui::ButtonStyle::kTonal;
   } else {
-    buttons.emplace_back(
-        l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW_THIS_TIME),
-        ButtonType::kAllow, ui::ButtonStyle::kTonal);
+    button.label = l10n_util::GetStringUTF16(IDS_PERMISSION_ALLOW_THIS_TIME);
+    button.type = ButtonType::kAllow;
+    button.style = ui::ButtonStyle::kTonal;
   }
+
+  buttons.emplace_back(button);
   return buttons;
 }
 
diff --git a/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_granted_view.cc b/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_granted_view.cc
index 1d68d83931e..546791e3c1f 100644
--- a/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_granted_view.cc
+++ b/chrome/browser/ui/views/permissions/embedded_permission_prompt_previously_granted_view.cc
@@ -58,13 +58,17 @@ EmbeddedPermissionPromptPreviouslyGrantedView::GetRequestLinesConfiguration()
 std::vector<EmbeddedPermissionPromptPreviouslyGrantedView::ButtonConfiguration>
 EmbeddedPermissionPromptPreviouslyGrantedView::GetButtonsConfiguration() const {
   std::vector<ButtonConfiguration> buttons;
-  buttons.emplace_back(
-      l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_CONTINUE_ALLOWING),
-      ButtonType::kContinueAllowing, ui::ButtonStyle::kTonal);
+  ButtonConfiguration button;
+  button.label = l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_CONTINUE_ALLOWING);
+  button.type = ButtonType::kContinueAllowing;
+  button.style = ui::ButtonStyle::kTonal;
+  buttons.emplace_back(button);
+
+  button.label = l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_STOP_ALLOWING);
+  button.type = ButtonType::kStopAllowing;
+  button.style = ui::ButtonStyle::kTonal;
+  buttons.emplace_back(button);
 
-  buttons.emplace_back(
-      l10n_util::GetStringUTF16(IDS_EMBEDDED_PROMPT_STOP_ALLOWING),
-      ButtonType::kStopAllowing, ui::ButtonStyle::kTonal);
   return buttons;
 }
 
diff --git a/chrome/installer/linux/common/apt.include b/chrome/installer/linux/common/apt.include
index 05c622864e7..7d91f03dce2 100644
--- a/chrome/installer/linux/common/apt.include
+++ b/chrome/installer/linux/common/apt.include
@@ -369,6 +369,8 @@ get_lib_dir() {
     LIBDIR=lib/mipsel-linux-gnu
   elif [ "$DEFAULT_ARCH" = "mips64el" ]; then
     LIBDIR=lib/mips64el-linux-gnuabi64
+  elif [ "$DEFAULT_ARCH" = "loongarch64" ]; then
+    LIBDIR=lib/loongarch64-linux-gnu
   else
     echo Unknown CPU Architecture: "$DEFAULT_ARCH"
     exit 1
diff --git a/chrome/installer/linux/common/rpm.include b/chrome/installer/linux/common/rpm.include
index 29438f42720..df9e2d3b69f 100644
--- a/chrome/installer/linux/common/rpm.include
+++ b/chrome/installer/linux/common/rpm.include
@@ -477,7 +477,7 @@ get_lib_dir() {
       [ "$DEFAULT_ARCH" = "mipsel" ]; then
     LIBDIR=lib
   elif [ "$DEFAULT_ARCH" = "x86_64" ] || [ "$DEFAULT_ARCH" = "aarch64" ] || \
-        [ "$DEFAULT_ARCH" = "mips64el" ]; then
+        [ "$DEFAULT_ARCH" = "mips64el" ] || [ "$DEFAULT_ARCH" = "loongarch64" ]; then
     LIBDIR=lib64
   else
     echo Unknown CPU Architecture: "$DEFAULT_ARCH"
diff --git a/chrome/installer/linux/debian/build.sh b/chrome/installer/linux/debian/build.sh
index 7cd40b9c37c..00ee185eb29 100755
--- a/chrome/installer/linux/debian/build.sh
+++ b/chrome/installer/linux/debian/build.sh
@@ -229,7 +229,7 @@ OUTPUTDIR="${PWD}"
 # call cleanup() on exit
 trap cleanup 0
 process_opts "$@"
-IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=0}
+IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=1}
 
 STAGEDIR="${OUTPUTDIR}/deb-staging-${CHANNEL}"
 mkdir -p "${STAGEDIR}"
diff --git a/chrome/installer/linux/debian/calculate_package_deps.py b/chrome/installer/linux/debian/calculate_package_deps.py
index e6e88a9159c..d68bfc06414 100755
--- a/chrome/installer/linux/debian/calculate_package_deps.py
+++ b/chrome/installer/linux/debian/calculate_package_deps.py
@@ -56,6 +56,9 @@ elif arch == 'mipsel':
 elif arch == 'mips64el':
   cmd.extend(['-l%s/usr/lib/mips64el-linux-gnuabi64' % sysroot,
               '-l%s/lib/mips64el-linux-gnuabi64' % sysroot])
+elif arch == 'loong64':
+  cmd.extend(['-l%s/usr/lib/loongarch64-linux-gnu' % sysroot,
+              '-l%s/lib/loongarch64-linux-gnu' % sysroot])
 else:
   print('Unsupported architecture ' + arch)
   sys.exit(1)
diff --git a/chrome/installer/linux/rpm/build.sh b/chrome/installer/linux/rpm/build.sh
index 3053be4fbf8..c215dca23f5 100755
--- a/chrome/installer/linux/rpm/build.sh
+++ b/chrome/installer/linux/rpm/build.sh
@@ -212,7 +212,7 @@ OUTPUTDIR="${PWD}"
 trap cleanup 0
 process_opts "$@"
 export ARCHITECTURE="${ARCHITECTURE}"
-IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=0}
+IS_OFFICIAL_BUILD=${IS_OFFICIAL_BUILD:=1}
 
 STAGEDIR="${OUTPUTDIR}/rpm-staging-${CHANNEL}"
 mkdir -p "${STAGEDIR}"
diff --git a/components/autofill/core/browser/contact_info_sync_util.cc b/components/autofill/core/browser/contact_info_sync_util.cc
index b5b0a0bbef4..08d63cd1f34 100644
--- a/components/autofill/core/browser/contact_info_sync_util.cc
+++ b/components/autofill/core/browser/contact_info_sync_util.cc
@@ -195,9 +195,10 @@ class ContactInfoProfileSetter {
       CHECK(observations.empty());
       for (const sync_pb::ContactInfoSpecifics::Observation& proto_observation :
            metadata.observations()) {
-        observations.emplace_back(proto_observation.type(),
-                                  ProfileTokenQuality::FormSignatureHash(
-                                      proto_observation.form_hash()));
+	ProfileTokenQuality::Observation observation;
+	observation.type = proto_observation.type();
+	observation.form_hash = ProfileTokenQuality::FormSignatureHash(proto_observation.form_hash());
+        observations.emplace_back(observation);
       }
     }
   }
diff --git a/components/autofill/core/browser/webdata/autofill_table.cc b/components/autofill/core/browser/webdata/autofill_table.cc
index 6e601b5c9b6..a8df9fcfd23 100644
--- a/components/autofill/core/browser/webdata/autofill_table.cc
+++ b/components/autofill/core/browser/webdata/autofill_table.cc
@@ -1763,10 +1763,14 @@ std::unique_ptr<AutofillProfile> AutofillTable::GetAutofillProfile(
     }
 
     base::span<const uint8_t> observations_data = s.ColumnBlob(3);
-    field_type_values.emplace_back(
-        type, s.ColumnString16(1), s.ColumnInt(2),
+    FieldTypeData type_data;
+    type_data.type = type;
+    type_data.value = s.ColumnString16(1);
+    type_data.status = s.ColumnInt(2);
+    type_data.serialized_data =
         std::vector<uint8_t>(observations_data.begin(),
-                             observations_data.end()));
+                             observations_data.end());
+    field_type_values.emplace_back(type_data);
 
     if (type == ADDRESS_HOME_COUNTRY) {
       country_code = base::UTF16ToUTF8(s.ColumnString16(1));
diff --git a/components/metrics/debug/metrics_internals_utils.cc b/components/metrics/debug/metrics_internals_utils.cc
index fed505e6dae..2bc4ab51411 100644
--- a/components/metrics/debug/metrics_internals_utils.cc
+++ b/components/metrics/debug/metrics_internals_utils.cc
@@ -68,6 +68,8 @@ std::string CpuArchitectureToString(
       return "arm32";
     case variations::Study::TRANSLATED_X86_64:
       return "translated_x86_64";
+    case variations::Study::LOONGARCH64:
+      return "loongarch64";
   }
   NOTREACHED();
 }
diff --git a/components/optimization_guide/core/tflite_model_executor.h b/components/optimization_guide/core/tflite_model_executor.h
index bbb5208aae9..a256a85322e 100644
--- a/components/optimization_guide/core/tflite_model_executor.h
+++ b/components/optimization_guide/core/tflite_model_executor.h
@@ -240,7 +240,7 @@ class TFLiteModelExecutor : public ModelExecutor<OutputType, InputType> {
   void SendForBatchExecution(
       BatchExecutionCallback callback_on_complete,
       base::TimeTicks start_time,
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
       override {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -262,7 +262,7 @@ class TFLiteModelExecutor : public ModelExecutor<OutputType, InputType> {
   // Starts the synchronous execution of the model. Returns model outputs.
   // Model needs to be loaded. Synchronous calls do not load or unload model.
   std::vector<absl::optional<OutputType>> SendForBatchExecutionSync(
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs)
       override {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -417,7 +417,7 @@ class TFLiteModelExecutor : public ModelExecutor<OutputType, InputType> {
   // executes it on the model execution thread.
   void LoadModelFileAndBatchExecute(
       BatchExecutionCallback callback_on_complete,
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs) {
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs) {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
 
@@ -434,7 +434,7 @@ class TFLiteModelExecutor : public ModelExecutor<OutputType, InputType> {
 
   // Batch executes the loaded model for inputs.
   void BatchExecuteLoadedModel(
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
       std::vector<absl::optional<OutputType>>* outputs) {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
@@ -494,7 +494,7 @@ class TFLiteModelExecutor : public ModelExecutor<OutputType, InputType> {
   // Unloads the model if needed.
   void BatchExecuteLoadedModelAndRunCallback(
       BatchExecutionCallback callback_on_complete,
-      ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
+      typename ModelExecutor<OutputType, InputType>::ConstRefInputVector inputs,
       ExecutionStatus execution_status) {
     DCHECK(execution_task_runner_->RunsTasksInCurrentSequence());
     DCHECK_CALLED_ON_VALID_SEQUENCE(sequence_checker_);
diff --git a/components/password_manager/core/browser/password_manager.cc b/components/password_manager/core/browser/password_manager.cc
index 87fcc6108b3..d9f05e714ea 100644
--- a/components/password_manager/core/browser/password_manager.cc
+++ b/components/password_manager/core/browser/password_manager.cc
@@ -629,8 +629,11 @@ void PasswordManager::OnUserModifiedNonPasswordField(
     bool is_likely_otp) {
   // |driver| might be empty on iOS or in tests.
   int driver_id = driver ? driver->GetId() : 0;
+  PossibleUsernameFieldIdentifier identifier;
+  identifier.driver_id = driver_id;
+  identifier.renderer_id = renderer_id;
   possible_usernames_.Put(
-      PossibleUsernameFieldIdentifier(driver_id, renderer_id),
+      identifier,
       PossibleUsernameData(GetSignonRealm(driver->GetLastCommittedURL()),
                            renderer_id, value, base::Time::Now(), driver_id,
                            autocomplete_attribute_has_username, is_likely_otp));
diff --git a/components/supervised_user/core/browser/proto_fetcher.cc b/components/supervised_user/core/browser/proto_fetcher.cc
index 26a121a2d4b..802fb92e1f3 100644
--- a/components/supervised_user/core/browser/proto_fetcher.cc
+++ b/components/supervised_user/core/browser/proto_fetcher.cc
@@ -526,7 +526,7 @@ class RetryingFetcherImpl final : public DeferredFetcherImpl<Response> {
   RetryingFetcherImpl(const RetryingFetcherImpl&) = delete;
   RetryingFetcherImpl& operator=(const RetryingFetcherImpl&) = delete;
 
-  void Start(ProtoFetcher<Response>::Callback callback) override {
+  void Start(typename ProtoFetcher<Response>::Callback callback) override {
     callback_ = std::move(callback);
     Retry();
   }
@@ -564,7 +564,7 @@ class RetryingFetcherImpl final : public DeferredFetcherImpl<Response> {
   }
 
   // Client callback.
-  ProtoFetcher<Response>::Callback callback_;
+  typename ProtoFetcher<Response>::Callback callback_;
 
   // Retry controls.
   base::OneShotTimer timer_;
@@ -707,7 +707,7 @@ ParallelFetchManager<Request, Response>::ParallelFetchManager(
 template <typename Request, typename Response>
 void ParallelFetchManager<Request, Response>::Fetch(
     const Request& request,
-    Fetcher::Callback callback) {
+    typename Fetcher::Callback callback) {
   CHECK(callback) << "Use base::DoNothing() instead of empty callback.";
   KeyType key = requests_in_flight_.Add(MakeFetcher(request));
   requests_in_flight_.Lookup(key)->Start(
diff --git a/components/supervised_user/core/browser/proto_fetcher.h b/components/supervised_user/core/browser/proto_fetcher.h
index 8266c99d78a..9c41978aea6 100644
--- a/components/supervised_user/core/browser/proto_fetcher.h
+++ b/components/supervised_user/core/browser/proto_fetcher.h
@@ -165,10 +165,10 @@ class ParallelFetchManager {
 
   // Starts the fetch. Underlying fetcher is stored internally, and will be
   // cleaned up after finish or when this manager is destroyed.
-  void Fetch(const Request& request, Fetcher::Callback callback);
+  void Fetch(const Request& request, typename Fetcher::Callback callback);
 
  private:
-  using KeyType = base::IDMap<std::unique_ptr<Fetcher>>::KeyType;
+  using KeyType = typename base::IDMap<std::unique_ptr<Fetcher>>::KeyType;
 
   // Remove fetcher under key from requests_in_flight_.
   void Remove(KeyType key);
diff --git a/components/variations/proto/study.proto b/components/variations/proto/study.proto
index 1117ec8d728..b27f666d3a3 100644
--- a/components/variations/proto/study.proto
+++ b/components/variations/proto/study.proto
@@ -264,6 +264,8 @@ message Study {
     // A Mac-only value, indicating an x86-64 binary running on an arm64 host
     // via "Rosetta 2" binary translation.
     TRANSLATED_X86_64 = 4;
+
+    LOONGARCH64 = 5;
   }
 
   // Enum to pass as optional bool.
diff --git a/components/variations/service/variations_field_trial_creator_base.cc b/components/variations/service/variations_field_trial_creator_base.cc
index 83dc9819988..65a1d61d7ec 100644
--- a/components/variations/service/variations_field_trial_creator_base.cc
+++ b/components/variations/service/variations_field_trial_creator_base.cc
@@ -93,6 +93,9 @@ RestrictionPolicy GetVariationPolicyRestriction(PrefService* local_state) {
 
 Study::CpuArchitecture GetCurrentCpuArchitecture() {
   std::string process_arch = base::SysInfo::ProcessCPUArchitecture();
+  if (process_arch == "LOONGARCH64") {
+    return Study::LOONGARCH64;
+  }
   if (process_arch == "ARM_64") {
     return Study::ARM64;
   }
diff --git a/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc b/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
index 17718f38f6c..7fecb97cf83 100644
--- a/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
+++ b/components/viz/service/display_embedder/skia_output_surface_impl_on_gpu.cc
@@ -1567,7 +1567,7 @@ void SkiaOutputSurfaceImplOnGpu::CopyOutputNV12(
 
       // Issue readbacks from the surfaces:
       for (size_t i = 0; i < CopyOutputResult::kNV12MaxPlanes; ++i) {
-        SkISize size(plane_surfaces[i]->width(), plane_surfaces[i]->height());
+        SkISize size = SkISize::Make(plane_surfaces[i]->width(), plane_surfaces[i]->height());
         SkImageInfo dst_info = SkImageInfo::Make(
             size, (i == 0) ? kAlpha_8_SkColorType : kR8G8_unorm_SkColorType,
             kUnpremul_SkAlphaType);
diff --git a/content/browser/download/save_package.cc b/content/browser/download/save_package.cc
index 5bd4ca1fe6c..32d074d675b 100644
--- a/content/browser/download/save_package.cc
+++ b/content/browser/download/save_package.cc
@@ -767,8 +767,11 @@ void SavePackage::Finish() {
   if (download_) {
     std::vector<download::DownloadSaveItemData::ItemInfo> files;
     for (auto& item : saved_success_items_) {
-      files.emplace_back(item.second->full_path(), item.second->url(),
-                         item.second->referrer().url);
+      download::DownloadSaveItemData::ItemInfo file;
+      file.file_path = item.second->full_path();
+      file.url = item.second->url();
+      file.referrer_url = item.second->referrer().url;
+      files.emplace_back(file);
     }
     download::DownloadSaveItemData::AttachItemData(download_, std::move(files));
   }
diff --git a/content/browser/interest_group/interest_group_storage.cc b/content/browser/interest_group/interest_group_storage.cc
index 22a183f1b4f..396bd442b36 100644
--- a/content/browser/interest_group/interest_group_storage.cc
+++ b/content/browser/interest_group/interest_group_storage.cc
@@ -3001,11 +3001,12 @@ DoGetKAnonymityData(sql::Database& db,
   interest_group_kanon_query.BindString(1, group_key.name);
 
   std::vector<StorageInterestGroup::KAnonymityData> k_anon_data;
+  StorageInterestGroup::KAnonymityData data;
   while (interest_group_kanon_query.Step()) {
-    k_anon_data.emplace_back(
-        /*key=*/interest_group_kanon_query.ColumnString(0),
-        /*is_k_anonymous=*/interest_group_kanon_query.ColumnBool(1),
-        /*last_updated=*/interest_group_kanon_query.ColumnTime(2));
+    data.key = interest_group_kanon_query.ColumnString(0);
+    data.is_k_anonymous = interest_group_kanon_query.ColumnBool(1);
+    data.last_updated = interest_group_kanon_query.ColumnTime(2);
+    k_anon_data.emplace_back(data);
   }
   if (!interest_group_kanon_query.Succeeded()) {
     return absl::nullopt;
diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index fe69db83393..dc4c6249d20 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -8678,8 +8678,11 @@ void RenderFrameHostImpl::SendFencedFrameReportingBeacon(
 
   for (const blink::FencedFrame::ReportingDestination& destination :
        destinations) {
+    DestinationEnumEvent event;
+    event.type = event_type;
+    event.data = event_data;
     SendFencedFrameReportingBeaconInternal(
-        DestinationEnumEvent(event_type, event_data), destination,
+        event, destination,
         /*from_renderer=*/true, attribution_reporting_runtime_features);
   }
 }
@@ -8713,8 +8716,10 @@ void RenderFrameHostImpl::SendFencedFrameReportingBeaconToCustomURL(
     return;
   }
 
+  DestinationURLEvent url_event;
+  url_event.url = destination_url;
   SendFencedFrameReportingBeaconInternal(
-      DestinationURLEvent(destination_url),
+      url_event,
       blink::FencedFrame::ReportingDestination::kBuyer,
       /*from_renderer=*/true, attribution_reporting_runtime_features);
 }
@@ -8812,9 +8817,11 @@ void RenderFrameHostImpl::MaybeSendFencedFrameAutomaticReportingBeacon(
                     destination) != info->destinations.end()) {
         data = info->data;
       }
+      DestinationEnumEvent event;
+      event.type = blink::kFencedFrameTopNavigationBeaconType;
+      event.data = data;
       initiator_rfh->SendFencedFrameReportingBeaconInternal(
-          DestinationEnumEvent(blink::kFencedFrameTopNavigationBeaconType,
-                               data),
+	  event,
           destination,
           /*from_renderer=*/false, attribution_reporting_features,
           navigation_request.GetNavigationId());
@@ -8826,9 +8833,11 @@ void RenderFrameHostImpl::MaybeSendFencedFrameAutomaticReportingBeacon(
 
     for (blink::FencedFrame::ReportingDestination destination :
          info->destinations) {
+      DestinationEnumEvent event;
+      event.type = blink::kFencedFrameTopNavigationBeaconType;
+      event.data = info->data;
       initiator_rfh->SendFencedFrameReportingBeaconInternal(
-          DestinationEnumEvent(blink::kFencedFrameTopNavigationBeaconType,
-                               info->data),
+	  event,
           destination,
           /*from_renderer=*/false, info->attribution_reporting_runtime_features,
           navigation_request.GetNavigationId());
diff --git a/content/browser/service_worker/service_worker_context_wrapper.cc b/content/browser/service_worker/service_worker_context_wrapper.cc
index 36e307e4ad4..3590e9f6097 100644
--- a/content/browser/service_worker/service_worker_context_wrapper.cc
+++ b/content/browser/service_worker/service_worker_context_wrapper.cc
@@ -1453,7 +1453,12 @@ void ServiceWorkerContextWrapper::MaybeProcessPendingWarmUpRequest() {
     return;
   }
 
-  auto [document_url, key, callback] = std::move(*request);
+  //auto [document_url, key, callback] = std::move(*request);
+  auto warm_up_request = std::move(*request);
+  auto document_url = std::get<0>(warm_up_request);
+  auto key = std::get<1>(warm_up_request);
+  auto callback = std::move(std::get<2>(warm_up_request));
+
 
   DCHECK(document_url.is_valid());
   TRACE_EVENT1("ServiceWorker",
diff --git a/content/public/browser/web_ui_browser_interface_broker_registry.h b/content/public/browser/web_ui_browser_interface_broker_registry.h
index 0a419be66b3..7253c9680f7 100644
--- a/content/public/browser/web_ui_browser_interface_broker_registry.h
+++ b/content/public/browser/web_ui_browser_interface_broker_registry.h
@@ -127,10 +127,10 @@ class CONTENT_EXPORT WebUIBrowserInterfaceBrokerRegistry {
   //
   // TODO(crbug.com/1407936): Point to WebUIJsBridge documentation.
   template <typename ControllerType>
-  JsBridgeTraits<ControllerType>::BinderInitializer& ForWebUIWithJsBridge() {
+  typename JsBridgeTraits<ControllerType>::BinderInitializer& ForWebUIWithJsBridge() {
     using Traits = JsBridgeTraits<ControllerType>;
-    using Interface = Traits::Interface;
-    using JsBridgeBinderInitializer = Traits::BinderInitializer;
+    using Interface = typename Traits::Interface;
+    using JsBridgeBinderInitializer = typename Traits::BinderInitializer;
 
     // WebUIController::GetType() requires an instantiated WebUIController
     // (because it's a virtual method and can't be static). Here we only have
diff --git a/media/base/cdm_promise_adapter.cc b/media/base/cdm_promise_adapter.cc
index f013809a62e..9c4142eac44 100644
--- a/media/base/cdm_promise_adapter.cc
+++ b/media/base/cdm_promise_adapter.cc
@@ -94,12 +94,13 @@ void CdmPromiseAdapter::RejectPromise(uint32_t promise_id,
 void CdmPromiseAdapter::Clear(ClearReason reason) {
   // Reject all outstanding promises.
   DCHECK(thread_checker_.CalledOnValidThread());
-  for (auto& [promise_id, promise] : promises_) {
+  //for (auto& [promise_id, promise] : promises_) {
+  for (auto& promises : promises_) {
     TRACE_EVENT_NESTABLE_ASYNC_END1(
-        "media", "CdmPromise", TRACE_ID_WITH_SCOPE("CdmPromise", promise_id),
+        "media", "CdmPromise", TRACE_ID_WITH_SCOPE("CdmPromise", promises.first),
         "status", "cleared");
-    promise->reject(CdmPromise::Exception::INVALID_STATE_ERROR,
-                    ToSystemCode(reason), "Operation aborted.");
+    promises.second->reject(CdmPromise::Exception::INVALID_STATE_ERROR,
+                     ToSystemCode(reason), "Operation aborted.");
   }
   promises_.clear();
 }
diff --git a/net/dns/host_resolver_cache.cc b/net/dns/host_resolver_cache.cc
index 00871cebad5..fd2edb44101 100644
--- a/net/dns/host_resolver_cache.cc
+++ b/net/dns/host_resolver_cache.cc
@@ -367,8 +367,11 @@ void HostResolverCache::Set(
   }
 
   std::string domain_name = result->domain_name();
+  Key key;
+  key.domain_name = std::move(domain_name);
+  key.network_anonymization_key = network_anonymization_key;
   entries_.emplace(
-      Key(std::move(domain_name), network_anonymization_key),
+      key,
       Entry(std::move(result), source, secure, staleness_generation));
 
   if (entries_.size() > max_entries_) {
diff --git a/net/dns/host_resolver_cache.h b/net/dns/host_resolver_cache.h
index e35e231ecf1..65f79fa1869 100644
--- a/net/dns/host_resolver_cache.h
+++ b/net/dns/host_resolver_cache.h
@@ -167,18 +167,18 @@ class NET_EXPORT HostResolverCache final {
     ~KeyComparator() = default;
 
     bool operator()(const Key& lhs, const Key& rhs) const {
-      return std::tie(lhs.domain_name, lhs.network_anonymization_key) <
-             std::tie(rhs.domain_name, rhs.network_anonymization_key);
+      return lhs.domain_name < rhs.domain_name &&
+	     lhs.network_anonymization_key < rhs.network_anonymization_key;
     }
 
     bool operator()(const Key& lhs, const KeyRef& rhs) const {
-      return std::tie(lhs.domain_name, lhs.network_anonymization_key) <
-             std::tie(rhs.domain_name, *rhs.network_anonymization_key);
+      return lhs.domain_name < rhs.domain_name &&
+	     lhs.network_anonymization_key < *rhs.network_anonymization_key;
     }
 
     bool operator()(const KeyRef& lhs, const Key& rhs) const {
-      return std::tie(lhs.domain_name, *lhs.network_anonymization_key) <
-             std::tie(rhs.domain_name, rhs.network_anonymization_key);
+      return lhs.domain_name < rhs.domain_name &&
+	     *lhs.network_anonymization_key < rhs.network_anonymization_key;
     }
   };
 
diff --git a/sandbox/features.gni b/sandbox/features.gni
index 8434144118b..e1c0af43ceb 100644
--- a/sandbox/features.gni
+++ b/sandbox/features.gni
@@ -9,7 +9,8 @@
 use_seccomp_bpf = (is_linux || is_chromeos || is_android) &&
                   (current_cpu == "x86" || current_cpu == "x64" ||
                    current_cpu == "arm" || current_cpu == "arm64" ||
-                   current_cpu == "mipsel" || current_cpu == "mips64el")
+                   current_cpu == "mipsel" || current_cpu == "mips64el" ||
+                   current_cpu == "loong64")
 
 # SSBD (Speculative Store Bypass Disable) is a mitigation of Spectre Variant 4.
 # As Spectre Variant 4 can be mitigated by site isolation, opt-out SSBD on site
diff --git a/sandbox/linux/BUILD.gn b/sandbox/linux/BUILD.gn
index 483488a3f78..72d2f08cded 100644
--- a/sandbox/linux/BUILD.gn
+++ b/sandbox/linux/BUILD.gn
@@ -396,6 +396,7 @@ source_set("sandbox_services_headers") {
     "system_headers/linux_stat.h",
     "system_headers/linux_syscalls.h",
     "system_headers/linux_time.h",
+    "system_headers/loongarch64_linux_syscalls.h",
     "system_headers/mips64_linux_syscalls.h",
     "system_headers/mips_linux_syscalls.h",
     "system_headers/x86_32_linux_syscalls.h",
diff --git a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
index 1d0590b7dd6..f12599c6515 100644
--- a/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
+++ b/sandbox/linux/bpf_dsl/linux_syscall_ranges.h
@@ -56,6 +56,13 @@
 #define MAX_PUBLIC_SYSCALL __NR_syscalls
 #define MAX_SYSCALL MAX_PUBLIC_SYSCALL
 
+#elif defined(__loongarch_lp64)
+
+#include <asm-generic/unistd.h>
+#define MIN_SYSCALL 0u
+#define MAX_PUBLIC_SYSCALL __NR_syscalls
+#define MAX_SYSCALL MAX_PUBLIC_SYSCALL
+
 #else
 #error "Unsupported architecture"
 #endif
diff --git a/sandbox/linux/bpf_dsl/seccomp_macros.h b/sandbox/linux/bpf_dsl/seccomp_macros.h
index 87d5825aa3d..811fcae2e85 100644
--- a/sandbox/linux/bpf_dsl/seccomp_macros.h
+++ b/sandbox/linux/bpf_dsl/seccomp_macros.h
@@ -343,6 +343,48 @@ struct regs_struct {
 #define SECCOMP_PT_PARM4(_regs) (_regs).regs[3]
 #define SECCOMP_PT_PARM5(_regs) (_regs).regs[4]
 #define SECCOMP_PT_PARM6(_regs) (_regs).regs[5]
+
+#elif defined(__loongarch_lp64)
+struct regs_struct {
+  uint64_t regs[32];
+  uint64_t pc;
+};
+
+#define SECCOMP_ARCH AUDIT_ARCH_LOONGARCH64
+
+#define SECCOMP_REG(_ctx, _reg) ((_ctx)->uc_mcontext.__gregs[_reg])
+
+#define SECCOMP_RESULT(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_SYSCALL(_ctx) SECCOMP_REG(_ctx, 11)
+#define SECCOMP_IP(_ctx) (_ctx)->uc_mcontext.__pc
+#define SECCOMP_PARM1(_ctx) SECCOMP_REG(_ctx, 4)
+#define SECCOMP_PARM2(_ctx) SECCOMP_REG(_ctx, 5)
+#define SECCOMP_PARM3(_ctx) SECCOMP_REG(_ctx, 6)
+#define SECCOMP_PARM4(_ctx) SECCOMP_REG(_ctx, 7)
+#define SECCOMP_PARM5(_ctx) SECCOMP_REG(_ctx, 8)
+#define SECCOMP_PARM6(_ctx) SECCOMP_REG(_ctx, 9)
+
+#define SECCOMP_NR_IDX (offsetof(struct arch_seccomp_data, nr))
+#define SECCOMP_ARCH_IDX (offsetof(struct arch_seccomp_data, arch))
+#define SECCOMP_IP_MSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 4)
+#define SECCOMP_IP_LSB_IDX \
+  (offsetof(struct arch_seccomp_data, instruction_pointer) + 0)
+#define SECCOMP_ARG_MSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 4)
+#define SECCOMP_ARG_LSB_IDX(nr) \
+  (offsetof(struct arch_seccomp_data, args) + 8 * (nr) + 0)
+
+#define SECCOMP_PT_RESULT(_regs) (_regs).regs[4]
+#define SECCOMP_PT_SYSCALL(_regs) (_regs).regs[11]
+#define SECCOMP_PT_IP(_regs) (_regs).pc
+#define SECCOMP_PT_PARM1(_regs) (_regs).regs[4]
+#define SECCOMP_PT_PARM2(_regs) (_regs).regs[5]
+#define SECCOMP_PT_PARM3(_regs) (_regs).regs[6]
+#define SECCOMP_PT_PARM4(_regs) (_regs).regs[7]
+#define SECCOMP_PT_PARM5(_regs) (_regs).regs[8]
+#define SECCOMP_PT_PARM6(_regs) (_regs).regs[9]
+
 #else
 #error Unsupported target platform
 
diff --git a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
index 4a2721c7ce1..a5e3cbd3584 100644
--- a/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
+++ b/sandbox/linux/integration_tests/bpf_dsl_seccomp_unittest.cc
@@ -577,6 +577,7 @@ class GreyListedPolicy : public Policy {
   const raw_ptr<int> aux_;
 };
 
+#if !defined(__loongarch__)
 BPF_TEST(SandboxBPF, GreyListedPolicy, GreyListedPolicy, int /* (*BPF_AUX) */) {
   BPF_ASSERT(sys_getpid() == -1);
   BPF_ASSERT(errno == EPERM);
@@ -593,6 +594,7 @@ BPF_TEST(SandboxBPF, GreyListedPolicy, GreyListedPolicy, int /* (*BPF_AUX) */) {
   BPF_ASSERT(*BPF_AUX == 3);
   BPF_ASSERT(*name);
 }
+#endif
 
 SANDBOX_TEST(SandboxBPF, EnableUnsafeTrapsInSigSysHandler) {
   // Disabling warning messages that could confuse our test framework.
@@ -1932,7 +1934,8 @@ BPF_TEST_C(SandboxBPF, PthreadBitMask, PthreadPolicyBitMask) {
 //
 // Depending on the architecture, this may modify regs, so the caller is
 // responsible for committing these changes using PTRACE_SETREGS.
-#if !defined(__arm__) && !defined(__aarch64__) && !defined(__mips__)
+#if !defined(__arm__) && !defined(__aarch64__) && !defined(__mips__) && \
+    !defined(__loongarch__)
 long SetSyscall(pid_t pid, regs_struct* regs, int syscall_number) {
 #if defined(__arm__)
   // On ARM, the syscall is changed using PTRACE_SET_SYSCALL.  We cannot use the
@@ -1972,7 +1975,7 @@ SANDBOX_TEST(SandboxBPF, DISABLE_ON_TSAN(SeccompRetTrace)) {
 // See https://code.google.com/p/chromium/issues/detail?id=383977
 #if defined(__arm__) || defined(__aarch64__)
   printf("This test is currently disabled on ARM32/64 due to a kernel bug.");
-#elif defined(__mips__)
+#elif defined(__mips__) || defined(__loongarch__)
   // TODO: Figure out how to support specificity of handling indirect syscalls
   //        in this test and enable it.
   printf("This test is currently disabled on MIPS.");
diff --git a/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc b/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
index 7bde501115b..a423e33079d 100644
--- a/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/baseline_policy.cc
@@ -193,7 +193,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return RestrictFcntlCommands();
 #endif
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
   // fork() is never used as a system call (clone() is used instead), but we
   // have seen it in fallback code on Android.
   if (sysno == __NR_fork) {
@@ -255,7 +255,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
   }
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch_lp64)
   if (sysno == __NR_mmap)
     return RestrictMmapFlags();
 #endif
@@ -276,7 +276,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
     return RestrictPrctl();
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch_lp64)
   if (sysno == __NR_socketpair) {
     // Only allow AF_UNIX, PF_UNIX. Crash if anything else is seen.
     static_assert(AF_UNIX == PF_UNIX,
@@ -366,7 +366,7 @@ ResultExpr EvaluateSyscallImpl(int fs_denied_errno,
   // Allow creating pipes, but don't allow weird flags to pipe2().
   // O_NOTIFICATION_PIPE (== O_EXCL) can be used to create
   // "notification pipes", which are rarely used.
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
   if (sysno == __NR_pipe) {
     return Allow();
   }
diff --git a/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc b/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
index dbbf1fb510b..e3c2caa87f2 100644
--- a/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/baseline_policy_unittest.cc
@@ -256,7 +256,8 @@ BPF_TEST_C(BaselinePolicy, GetRandom, BaselinePolicy) {
 }
 
 // Not all architectures can restrict the domain for socketpair().
-#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
+    defined(__loongarch_lp64)
 BPF_DEATH_TEST_C(BaselinePolicy,
                  SocketpairWrongDomain,
                  DEATH_SEGV_MESSAGE(GetErrorMessageContentForTests()),
@@ -265,7 +266,8 @@ BPF_DEATH_TEST_C(BaselinePolicy,
   std::ignore = socketpair(AF_INET, SOCK_STREAM, 0, sv);
   _exit(1);
 }
-#endif  // defined(__x86_64__) || defined(__arm__) || defined(__aarch64__)
+#endif  // defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) ||
+        // defined(__loongarch_lp64)
 
 BPF_TEST_C(BaselinePolicy, EPERM_open, BaselinePolicy) {
   errno = 0;
@@ -329,7 +331,7 @@ TEST_BASELINE_SIGSYS(__NR_sysinfo)
 TEST_BASELINE_SIGSYS(__NR_syslog)
 TEST_BASELINE_SIGSYS(__NR_timer_create)
 
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
 TEST_BASELINE_SIGSYS(__NR_inotify_init)
 TEST_BASELINE_SIGSYS(__NR_vserver)
 #endif
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
index ba995ace6d4..bef7d3c39f4 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_parameters_restrictions.cc
@@ -37,7 +37,7 @@
 
 #if (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS_LACROS)) && \
     !defined(__arm__) && !defined(__aarch64__) &&             \
-    !defined(PTRACE_GET_THREAD_AREA)
+    !defined(PTRACE_GET_THREAD_AREA) && !defined(__loongarch__)
 // Also include asm/ptrace-abi.h since ptrace.h in older libc (for instance
 // the one in Ubuntu 16.04 LTS) is missing PTRACE_GET_THREAD_AREA.
 // asm/ptrace-abi.h doesn't exist on arm32 and PTRACE_GET_THREAD_AREA isn't
@@ -460,7 +460,10 @@ ResultExpr RestrictPtrace() {
   return Switch(request)
       .Cases({
 #if !defined(__aarch64__)
-                 PTRACE_GETREGS, PTRACE_GETFPREGS, PTRACE_GET_THREAD_AREA,
+                 PTRACE_GETREGS, PTRACE_GETFPREGS,
+#if !defined(__loongarch_lp64)
+		 PTRACE_GET_THREAD_AREA,
+#endif
                  PTRACE_GETREGSET,
 #endif
 #if defined(__arm__)
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
index 27ea264070d..ec35c6de701 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.cc
@@ -103,7 +103,7 @@ bool SyscallSets::IsUmask(int sysno) {
 // Both EPERM and ENOENT are valid errno unless otherwise noted in comment.
 bool SyscallSets::IsFileSystem(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_access:  // EPERM not a valid errno.
     case __NR_chmod:
     case __NR_chown:
@@ -136,7 +136,7 @@ bool SyscallSets::IsFileSystem(int sysno) {
     case __NR_faccessat2:
     case __NR_fchmodat:
     case __NR_fchownat:  // Should be called chownat ?
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__loongarch_lp64)
     case __NR_newfstatat:  // fstatat(). EPERM not a valid errno.
 #elif defined(__i386__) || defined(__arm__) || \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
@@ -241,7 +241,7 @@ bool SyscallSets::IsAllowedFileSystemAccessViaFd(int sysno) {
     case __NR_oldfstat:
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_sync_file_range:  // EPERM not a valid errno.
 #elif defined(__arm__)
     case __NR_arm_sync_file_range:  // EPERM not a valid errno.
@@ -260,7 +260,7 @@ bool SyscallSets::IsDeniedFileSystemAccessViaFd(int sysno) {
 #if defined(__i386__) || defined(__arm__)
     case __NR_fchown32:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_getdents:    // EPERM not a valid errno.
 #endif
     case __NR_getdents64:  // EPERM not a valid errno.
@@ -339,7 +339,7 @@ bool SyscallSets::IsProcessPrivilegeChange(int sysno) {
 bool SyscallSets::IsProcessGroupOrSession(int sysno) {
   switch (sysno) {
     case __NR_setpgid:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_getpgrp:
 #endif
     case __NR_setsid:
@@ -373,7 +373,7 @@ bool SyscallSets::IsAllowedSignalHandling(int sysno) {
     case __NR_rt_sigqueueinfo:
     case __NR_rt_sigsuspend:
     case __NR_rt_tgsigqueueinfo:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_signalfd:
 #endif
     case __NR_signalfd4:
@@ -397,12 +397,12 @@ bool SyscallSets::IsAllowedOperationOnFd(int sysno) {
   switch (sysno) {
     case __NR_close:
     case __NR_dup:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_dup2:
 #endif
     case __NR_dup3:
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_shutdown:
 #endif
       return true;
@@ -441,7 +441,7 @@ bool SyscallSets::IsAllowedProcessStartOrDeath(int sysno) {
       return true;
     case __NR_clone:  // Should be parameter-restricted.
     case __NR_setns:  // Privileged.
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_fork:
 #endif
 #if defined(__i386__) || defined(__x86_64__)
@@ -452,7 +452,7 @@ bool SyscallSets::IsAllowedProcessStartOrDeath(int sysno) {
 #endif
     case __NR_set_tid_address:
     case __NR_unshare:
-#if !defined(__mips__) && !defined(__aarch64__)
+#if !defined(__mips__) && !defined(__aarch64__) && !defined(__loongarch__)
     case __NR_vfork:
 #endif
     default:
@@ -477,7 +477,7 @@ bool SyscallSets::IsAllowedFutex(int sysno) {
 
 bool SyscallSets::IsAllowedEpoll(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_epoll_create:
     case __NR_epoll_wait:
 #endif
@@ -499,7 +499,7 @@ bool SyscallSets::IsAllowedEpoll(int sysno) {
 bool SyscallSets::IsDeniedGetOrModifySocket(int sysno) {
   switch (sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_accept:
     case __NR_accept4:
     case __NR_bind:
@@ -553,7 +553,7 @@ bool SyscallSets::IsAllowedAddressSpaceAccess(int sysno) {
     case __NR_mincore:
     case __NR_mlockall:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_mmap:
 #endif
 #if defined(__i386__) || defined(__arm__) || \
@@ -586,7 +586,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR__llseek:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_poll:
 #endif
     case __NR_ppoll:
@@ -607,7 +607,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     case __NR_recv:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_recvfrom:  // Could specify source.
     case __NR_recvmsg:   // Could specify source.
 #endif
@@ -622,7 +622,7 @@ bool SyscallSets::IsAllowedGeneralIo(int sysno) {
     case __NR_send:
 #endif
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_sendmsg:  // Could specify destination.
     case __NR_sendto:   // Could specify destination.
 #endif
@@ -671,7 +671,7 @@ bool SyscallSets::IsSeccomp(int sysno) {
 bool SyscallSets::IsAllowedBasicScheduler(int sysno) {
   switch (sysno) {
     case __NR_sched_yield:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_pause:
 #endif
     case __NR_nanosleep:
@@ -755,7 +755,7 @@ bool SyscallSets::IsNuma(int sysno) {
     case __NR_getcpu:
     case __NR_mbind:
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_migrate_pages:
 #endif
     case __NR_move_pages:
@@ -790,7 +790,7 @@ bool SyscallSets::IsGlobalProcessEnvironment(int sysno) {
   switch (sysno) {
     case __NR_acct:  // Privileged.
 #if defined(__i386__) || defined(__x86_64__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
     case __NR_getrlimit:
 #endif
 #if defined(__i386__) || defined(__arm__)
@@ -825,7 +825,7 @@ bool SyscallSets::IsDebug(int sysno) {
 
 bool SyscallSets::IsGlobalSystemStatus(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR__sysctl:
     case __NR_sysfs:
 #endif
@@ -843,7 +843,7 @@ bool SyscallSets::IsGlobalSystemStatus(int sysno) {
 
 bool SyscallSets::IsEventFd(int sysno) {
   switch (sysno) {
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_eventfd:
 #endif
     case __NR_eventfd2:
@@ -895,7 +895,8 @@ bool SyscallSets::IsKeyManagement(int sysno) {
 }
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch_lp64)
 bool SyscallSets::IsSystemVSemaphores(int sysno) {
   switch (sysno) {
     case __NR_semctl:
@@ -914,7 +915,7 @@ bool SyscallSets::IsSystemVSemaphores(int sysno) {
 #endif
 
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__) ||                                         \
+    defined(__aarch64__) || defined(__loongarch_lp64) ||               \
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
 // These give a lot of ambient authority and bypass the setuid sandbox.
 bool SyscallSets::IsSystemVSharedMemory(int sysno) {
@@ -931,7 +932,8 @@ bool SyscallSets::IsSystemVSharedMemory(int sysno) {
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch_lp64)
 bool SyscallSets::IsSystemVMessageQueue(int sysno) {
   switch (sysno) {
     case __NR_msgctl:
@@ -962,7 +964,8 @@ bool SyscallSets::IsSystemVIpc(int sysno) {
 
 bool SyscallSets::IsAnySystemV(int sysno) {
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch_lp64)
   return IsSystemVMessageQueue(sysno) || IsSystemVSemaphores(sysno) ||
          IsSystemVSharedMemory(sysno);
 #elif defined(__i386__) || \
@@ -999,7 +1002,7 @@ bool SyscallSets::IsAdvancedScheduler(int sysno) {
 bool SyscallSets::IsInotify(int sysno) {
   switch (sysno) {
     case __NR_inotify_add_watch:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_inotify_init:
 #endif
     case __NR_inotify_init1:
@@ -1137,7 +1140,7 @@ bool SyscallSets::IsMisc(int sysno) {
 #if defined(__x86_64__)
     case __NR_tuxcall:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_vserver:
 #endif
       return true;
diff --git a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
index 9be7b03ec43..6ffba1c61d7 100644
--- a/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
+++ b/sandbox/linux/seccomp-bpf-helpers/syscall_sets.h
@@ -52,7 +52,7 @@ class SANDBOX_EXPORT SyscallSets {
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__mips__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch__)
   static bool IsNetworkSocketInformation(int sysno);
 #endif
 
@@ -79,23 +79,27 @@ class SANDBOX_EXPORT SyscallSets {
   static bool IsAsyncIo(int sysno);
   static bool IsKeyManagement(int sysno);
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch__)
   static bool IsSystemVSemaphores(int sysno);
 #endif
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
     defined(__aarch64__) ||                                         \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) || \
+    defined(__loongarch__)
   // These give a lot of ambient authority and bypass the setuid sandbox.
   static bool IsSystemVSharedMemory(int sysno);
 #endif
 
 #if defined(__x86_64__) || defined(__arm__) || defined(__aarch64__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS))
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)) ||    \
+    defined(__loongarch__)
   static bool IsSystemVMessageQueue(int sysno);
 #endif
 
-#if defined(__i386__) || \
-    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
+#if defined(__i386__) ||                                            \
+    (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS)) || \
+    defined(__looongarch__)
   // Big system V multiplexing system call.
   static bool IsSystemVIpc(int sysno);
 #endif
diff --git a/sandbox/linux/seccomp-bpf/syscall.cc b/sandbox/linux/seccomp-bpf/syscall.cc
index 02cbb047c15..43a11eb571c 100644
--- a/sandbox/linux/seccomp-bpf/syscall.cc
+++ b/sandbox/linux/seccomp-bpf/syscall.cc
@@ -18,7 +18,7 @@ namespace sandbox {
 namespace {
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
 // Number that's not currently used by any Linux kernel ABIs.
 const int kInvalidSyscallNumber = 0x351d3;
 #else
@@ -308,6 +308,25 @@ asm(// We need to be able to tell the kernel exactly where we made a
     "2:ret\n"
     ".cfi_endproc\n"
     ".size SyscallAsm, .-SyscallAsm\n"
+#elif defined(__loongarch_lp64)
+    ".text\n"
+    ".global SyscallAsm\n"
+    ".type SyscallAsm, %function\n"
+    "SyscallAsm:\n"
+    "bge $a0, $zero, 1f\n"
+    "la $a0, 2f\n"
+    "b 2f\n"
+    "1:ld.d $a5, $a6, 40\n"
+    "ld.d $a4, $a6, 32\n"
+    "ld.d $a3, $a6, 24\n"
+    "ld.d $a2, $a6, 16\n"
+    "ld.d $a1, $a6, 8\n"
+    "move $a7, $a0\n"
+    "ld.d $a0, $a6, 0\n"
+    // Enter the kernel
+    "syscall 0\n"
+    "2:jirl $zero, $ra, 0\n"
+    ".size SyscallAsm, .-SyscallAsm\n"
 #endif
     );  // asm
 
@@ -424,6 +443,17 @@ intptr_t Syscall::Call(int nr,
                  : "memory", "x1", "x2", "x3", "x4", "x5", "x8", "x30");
     ret = inout;
   }
+#elif defined(__loongarch_lp64)
+  intptr_t ret;
+  {
+    register intptr_t inout __asm__("$r4") = nr;
+    register const intptr_t* data __asm__("$r10") = args;
+    asm volatile("bl SyscallAsm\n"
+                 : "=r"(inout)
+                 : "0"(inout), "r"(data)
+                 : "memory", "$r5", "$r6", "$r7", "$r8", "$r9", "$r11", "$r1");
+    ret = inout;
+  }
 
 #else
 #error "Unimplemented architecture"
diff --git a/sandbox/linux/seccomp-bpf/syscall_unittest.cc b/sandbox/linux/seccomp-bpf/syscall_unittest.cc
index 8fe9b720535..23601f1974f 100644
--- a/sandbox/linux/seccomp-bpf/syscall_unittest.cc
+++ b/sandbox/linux/seccomp-bpf/syscall_unittest.cc
@@ -72,6 +72,7 @@ TEST(Syscall, WellKnownEntryPoint) {
   EXPECT_EQ(0x0cu, LoadBehind<uint32_t>(Syscall::Call(-1)) & 0x0000FFFF);
 #elif defined(__aarch64__)
   EXPECT_EQ(0xD4000001u, LoadBehind<uint32_t>(Syscall::Call(-1)));  // SVC 0
+#elif defined(__loongarch_lp64)
 #else
 #warning Incomplete test case; need port for target platform
 #endif
diff --git a/sandbox/linux/services/credentials.cc b/sandbox/linux/services/credentials.cc
index e284c59d239..ea30f36276c 100644
--- a/sandbox/linux/services/credentials.cc
+++ b/sandbox/linux/services/credentials.cc
@@ -80,7 +80,7 @@ bool ChrootToSafeEmptyDir() {
   pid_t pid = -1;
   alignas(16) char stack_buf[PTHREAD_STACK_MIN];
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
   // The stack grows downward.
   void* stack = stack_buf + sizeof(stack_buf);
 #else
diff --git a/sandbox/linux/services/syscall_wrappers.cc b/sandbox/linux/services/syscall_wrappers.cc
index 7650e983b38..6a0f90a2150 100644
--- a/sandbox/linux/services/syscall_wrappers.cc
+++ b/sandbox/linux/services/syscall_wrappers.cc
@@ -61,7 +61,7 @@ long sys_clone(unsigned long flags,
 #if defined(ARCH_CPU_X86_64)
   return syscall(__NR_clone, flags, child_stack, ptid, ctid, tls);
 #elif defined(ARCH_CPU_X86) || defined(ARCH_CPU_ARM_FAMILY) || \
-    defined(ARCH_CPU_MIPS_FAMILY)
+    defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
   // CONFIG_CLONE_BACKWARDS defined.
   return syscall(__NR_clone, flags, child_stack, ptid, tls, ctid);
 #endif
diff --git a/sandbox/linux/syscall_broker/broker_process.cc b/sandbox/linux/syscall_broker/broker_process.cc
index a55b548a8ec..73d72d2277e 100644
--- a/sandbox/linux/syscall_broker/broker_process.cc
+++ b/sandbox/linux/syscall_broker/broker_process.cc
@@ -122,44 +122,44 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
   // and are default disabled in Android. So, we should refuse to broker them
   // to be consistent with the platform's restrictions.
   switch (sysno) {
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !defined(OS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_access:
 #endif
     case __NR_faccessat:
     case __NR_faccessat2:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_ACCESS);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_mkdir:
 #endif
     case __NR_mkdirat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_MKDIR);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_open:
 #endif
     case __NR_openat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_OPEN);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_readlink:
 #endif
     case __NR_readlinkat:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_READLINK);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_rename:
 #endif
     case __NR_renameat:
     case __NR_renameat2:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_RENAME);
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_rmdir:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_RMDIR);
 #endif
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_stat:
     case __NR_lstat:
 #endif
@@ -169,7 +169,7 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
 #if defined(__NR_fstatat64)
     case __NR_fstatat64:
 #endif
-#if defined(__x86_64__) || defined(__aarch64__)
+#if defined(__x86_64__) || defined(__aarch64__) || defined(__loongarch_lp64)
     case __NR_newfstatat:
 #endif
       return !fast_check || policy_->allowed_command_set.test(COMMAND_STAT);
@@ -184,7 +184,7 @@ bool BrokerProcess::IsSyscallBrokerable(int sysno, bool fast_check) const {
       return !fast_check || policy_->allowed_command_set.test(COMMAND_STAT);
 #endif
 
-#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID)
+#if !defined(__aarch64__) && !BUILDFLAG(IS_ANDROID) && !defined(__loongarch_lp64)
     case __NR_unlink:
       return !fast_check || policy_->allowed_command_set.test(COMMAND_UNLINK);
 #endif
diff --git a/sandbox/linux/syscall_broker/broker_process_unittest.cc b/sandbox/linux/syscall_broker/broker_process_unittest.cc
index cb85c87f2c2..d8afb84e90d 100644
--- a/sandbox/linux/syscall_broker/broker_process_unittest.cc
+++ b/sandbox/linux/syscall_broker/broker_process_unittest.cc
@@ -1996,12 +1996,14 @@ TEST(BrokerProcess, IsSyscallAllowed) {
         __NR_readlink
 #endif
        }},
+#if !defined(__loongarch_lp64)
       {COMMAND_RENAME,
        {__NR_renameat,
 #if defined(__NR_rename) && !BUILDFLAG(IS_ANDROID)
         __NR_rename
 #endif
        }},
+#endif
       {COMMAND_UNLINK,
        {__NR_unlinkat,
 #if defined(__NR_unlink) && !BUILDFLAG(IS_ANDROID)
diff --git a/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc b/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc
index 15b2ee66d4b..54de47873ad 100644
--- a/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc
+++ b/sandbox/linux/syscall_broker/remote_syscall_arg_handler_unittest.cc
@@ -28,7 +28,11 @@ namespace {
 const char kPathPart[] = "/i/am/path";
 
 void FillBufferWithPath(char* buf, size_t size, bool null_terminate) {
+#if defined(__loongarch_lp64)
+  SANDBOX_ASSERT_LE(size, static_cast<size_t>(PATH_MAX)*4);
+#else
   SANDBOX_ASSERT_LE(size, static_cast<size_t>(PATH_MAX));
+#endif
   size_t str_len = strlen(kPathPart);
   size_t len_left_to_write = size;
   char* curr_buf_pos = buf;
diff --git a/sandbox/linux/system_headers/linux_seccomp.h b/sandbox/linux/system_headers/linux_seccomp.h
index 8690a96eb01..97638236f4d 100644
--- a/sandbox/linux/system_headers/linux_seccomp.h
+++ b/sandbox/linux/system_headers/linux_seccomp.h
@@ -39,6 +39,10 @@
 #define EM_AARCH64 183
 #endif
 
+#ifndef EM_LOONGARCH
+#define EM_LOONGARCH 258
+#endif
+
 #ifndef __AUDIT_ARCH_64BIT
 #define __AUDIT_ARCH_64BIT 0x80000000
 #endif
@@ -71,6 +75,10 @@
 #define AUDIT_ARCH_AARCH64 (EM_AARCH64 | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
 #endif
 
+#ifndef AUDIT_ARCH_LOONGARCH64
+#define AUDIT_ARCH_LOONGARCH64 (EM_LOONGARCH | __AUDIT_ARCH_64BIT | __AUDIT_ARCH_LE)
+#endif
+
 // For prctl.h
 #ifndef PR_SET_SECCOMP
 #define PR_SET_SECCOMP               22
diff --git a/sandbox/linux/system_headers/linux_signal.h b/sandbox/linux/system_headers/linux_signal.h
index 69ccaf10815..37e0d77fe35 100644
--- a/sandbox/linux/system_headers/linux_signal.h
+++ b/sandbox/linux/system_headers/linux_signal.h
@@ -13,7 +13,7 @@
 // (not undefined, but defined different values and in different memory
 // layouts). So, fill the gap here.
 #if defined(__i386__) || defined(__x86_64__) || defined(__arm__) || \
-    defined(__aarch64__)
+    defined(__aarch64__) || defined(__loongarch_lp64)
 
 #define LINUX_SIGHUP 1
 #define LINUX_SIGINT 2
@@ -97,7 +97,8 @@ typedef siginfo_t LinuxSigInfo;
 struct LinuxSigSet {
   unsigned long sig[_NSIG_WORDS];
 };
-#elif defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS)
+#elif defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_64_BITS) || \
+    defined(ARCH_CPU_LOONGARCH_FAMILY)
 #if !defined(_NSIG_WORDS)
 #define _NSIG_WORDS 2
 #endif
diff --git a/sandbox/linux/system_headers/linux_stat.h b/sandbox/linux/system_headers/linux_stat.h
index 3aae8cbced7..694f63ee47b 100644
--- a/sandbox/linux/system_headers/linux_stat.h
+++ b/sandbox/linux/system_headers/linux_stat.h
@@ -150,7 +150,7 @@ struct kernel_stat {
   int st_blocks;
   int st_pad4[14];
 };
-#elif defined(__aarch64__)
+#elif defined(__aarch64__) || defined(__loongarch_lp64)
 struct kernel_stat {
   unsigned long st_dev;
   unsigned long st_ino;
diff --git a/sandbox/linux/system_headers/linux_syscalls.h b/sandbox/linux/system_headers/linux_syscalls.h
index 438147b4018..1353b081a9d 100644
--- a/sandbox/linux/system_headers/linux_syscalls.h
+++ b/sandbox/linux/system_headers/linux_syscalls.h
@@ -35,5 +35,9 @@
 #include "sandbox/linux/system_headers/arm64_linux_syscalls.h"
 #endif
 
+#if defined(__loongarch_lp64)
+#include "sandbox/linux/system_headers/loongarch64_linux_syscalls.h"
+#endif
+
 #endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LINUX_SYSCALLS_H_
 
diff --git a/sandbox/linux/system_headers/loongarch64_linux_syscalls.h b/sandbox/linux/system_headers/loongarch64_linux_syscalls.h
new file mode 100644
index 00000000000..c18efa4eb1c
--- /dev/null
+++ b/sandbox/linux/system_headers/loongarch64_linux_syscalls.h
@@ -0,0 +1,1221 @@
+// Copyright 2021 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef SANDBOX_LINUX_SYSTEM_HEADERS_LOONGARCH64_LINUX_SYSCALLS_H_
+#define SANDBOX_LINUX_SYSTEM_HEADERS_LOONGARCH64_LINUX_SYSCALLS_H_
+
+#if !defined(__loongarch__)
+#error "Including header on wrong architecture"
+#endif
+#include <asm/unistd.h>
+
+#if !defined(__NR_io_setup)
+#define __NR_io_setup 0
+#endif
+
+#if !defined(__NR_io_destroy)
+#define __NR_io_destroy 1
+#endif
+
+#if !defined(__NR_io_submit)
+#define __NR_io_submit 2
+#endif
+
+#if !defined(__NR_io_cancel)
+#define __NR_io_cancel 3
+#endif
+
+#if !defined(__NR_io_getevents)
+#define __NR_io_getevents 4
+#endif
+
+#if !defined(__NR_setxattr)
+#define __NR_setxattr 5
+#endif
+
+#if !defined(__NR_lsetxattr)
+#define __NR_lsetxattr 6
+#endif
+
+#if !defined(__NR_fsetxattr)
+#define __NR_fsetxattr 7
+#endif
+
+#if !defined(__NR_getxattr)
+#define __NR_getxattr 8
+#endif
+
+#if !defined(__NR_lgetxattr)
+#define __NR_lgetxattr 9
+#endif
+
+#if !defined(__NR_fgetxattr)
+#define __NR_fgetxattr 10
+#endif
+
+#if !defined(__NR_listxattr)
+#define __NR_listxattr 11
+#endif
+
+#if !defined(__NR_llistxattr)
+#define __NR_llistxattr 12
+#endif
+
+#if !defined(__NR_flistxattr)
+#define __NR_flistxattr 13
+#endif
+
+#if !defined(__NR_removexattr)
+#define __NR_removexattr 14
+#endif
+
+#if !defined(__NR_lremovexattr)
+#define __NR_lremovexattr 15
+#endif
+
+#if !defined(__NR_fremovexattr)
+#define __NR_fremovexattr 16
+#endif
+
+#if !defined(__NR_getcwd)
+#define __NR_getcwd 17
+#endif
+
+#if !defined(__NR_lookup_dcookie)
+#define __NR_lookup_dcookie 18
+#endif
+
+#if !defined(__NR_eventfd2)
+#define __NR_eventfd2 19
+#endif
+
+#if !defined(__NR_epoll_create1)
+#define __NR_epoll_create1 20
+#endif
+
+#if !defined(__NR_epoll_ctl)
+#define __NR_epoll_ctl 21
+#endif
+
+#if !defined(__NR_epoll_pwait)
+#define __NR_epoll_pwait 22
+#endif
+
+#if !defined(__NR_dup)
+#define __NR_dup 23
+#endif
+
+#if !defined(__NR_dup3)
+#define __NR_dup3 24
+#endif
+
+#if !defined(__NR_fcntl)
+#define __NR_fcntl 25
+#endif
+
+#if !defined(__NR_inotify_init1)
+#define __NR_inotify_init1 26
+#endif
+
+#if !defined(__NR_inotify_add_watch)
+#define __NR_inotify_add_watch 27
+#endif
+
+#if !defined(__NR_inotify_rm_watch)
+#define __NR_inotify_rm_watch 28
+#endif
+
+#if !defined(__NR_ioctl)
+#define __NR_ioctl 29
+#endif
+
+#if !defined(__NR_ioprio_set)
+#define __NR_ioprio_set 30
+#endif
+
+#if !defined(__NR_ioprio_get)
+#define __NR_ioprio_get 31
+#endif
+
+#if !defined(__NR_flock)
+#define __NR_flock 32
+#endif
+
+#if !defined(__NR_mknodat)
+#define __NR_mknodat 33
+#endif
+
+#if !defined(__NR_mkdirat)
+#define __NR_mkdirat 34
+#endif
+
+#if !defined(__NR_unlinkat)
+#define __NR_unlinkat 35
+#endif
+
+#if !defined(__NR_symlinkat)
+#define __NR_symlinkat 36
+#endif
+
+#if !defined(__NR_linkat)
+#define __NR_linkat 37
+#endif
+
+#if !defined(__NR_renameat)
+#define __NR_renameat 38
+#endif
+
+#if !defined(__NR_umount2)
+#define __NR_umount2 39
+#endif
+
+#if !defined(__NR_mount)
+#define __NR_mount 40
+#endif
+
+#if !defined(__NR_pivot_root)
+#define __NR_pivot_root 41
+#endif
+
+#if !defined(__NR_nfsservctl)
+#define __NR_nfsservctl 42
+#endif
+
+#if !defined(__NR_statfs)
+#define __NR_statfs 43
+#endif
+
+#if !defined(__NR_fstatfs)
+#define __NR_fstatfs 44
+#endif
+
+#if !defined(__NR_truncate)
+#define __NR_truncate 45
+#endif
+
+#if !defined(__NR_ftruncate)
+#define __NR_ftruncate 46
+#endif
+
+#if !defined(__NR_fallocate)
+#define __NR_fallocate 47
+#endif
+
+#if !defined(__NR_faccessat)
+#define __NR_faccessat 48
+#endif
+
+#if !defined(__NR_chdir)
+#define __NR_chdir 49
+#endif
+
+#if !defined(__NR_fchdir)
+#define __NR_fchdir 50
+#endif
+
+#if !defined(__NR_chroot)
+#define __NR_chroot 51
+#endif
+
+#if !defined(__NR_fchmod)
+#define __NR_fchmod 52
+#endif
+
+#if !defined(__NR_fchmodat)
+#define __NR_fchmodat 53
+#endif
+
+#if !defined(__NR_fchownat)
+#define __NR_fchownat 54
+#endif
+
+#if !defined(__NR_fchown)
+#define __NR_fchown 55
+#endif
+
+#if !defined(__NR_openat)
+#define __NR_openat 56
+#endif
+
+#if !defined(__NR_close)
+#define __NR_close 57
+#endif
+
+#if !defined(__NR_vhangup)
+#define __NR_vhangup 58
+#endif
+
+#if !defined(__NR_pipe2)
+#define __NR_pipe2 59
+#endif
+
+#if !defined(__NR_quotactl)
+#define __NR_quotactl 60
+#endif
+
+#if !defined(__NR_getdents64)
+#define __NR_getdents64 61
+#endif
+
+#if !defined(__NR_lseek)
+#define __NR_lseek 62
+#endif
+
+#if !defined(__NR_read)
+#define __NR_read 63
+#endif
+
+#if !defined(__NR_write)
+#define __NR_write 64
+#endif
+
+#if !defined(__NR_readv)
+#define __NR_readv 65
+#endif
+
+#if !defined(__NR_writev)
+#define __NR_writev 66
+#endif
+
+#if !defined(__NR_pread64)
+#define __NR_pread64 67
+#endif
+
+#if !defined(__NR_pwrite64)
+#define __NR_pwrite64 68
+#endif
+
+#if !defined(__NR_preadv)
+#define __NR_preadv 69
+#endif
+
+#if !defined(__NR_pwritev)
+#define __NR_pwritev 70
+#endif
+
+#if !defined(__NR_sendfile)
+#define __NR_sendfile 71
+#endif
+
+#if !defined(__NR_pselect6)
+#define __NR_pselect6 72
+#endif
+
+#if !defined(__NR_ppoll)
+#define __NR_ppoll 73
+#endif
+
+#if !defined(__NR_signalfd4)
+#define __NR_signalfd4 74
+#endif
+
+#if !defined(__NR_vmsplice)
+#define __NR_vmsplice 75
+#endif
+
+#if !defined(__NR_splice)
+#define __NR_splice 76
+#endif
+
+#if !defined(__NR_tee)
+#define __NR_tee 77
+#endif
+
+#if !defined(__NR_readlinkat)
+#define __NR_readlinkat 78
+#endif
+
+#if !defined(__NR_newfstatat)
+#define __NR_newfstatat 79
+#endif
+
+#if !defined(__NR_fstat)
+#define __NR_fstat 80
+#endif
+
+#if !defined(__NR_sync)
+#define __NR_sync 81
+#endif
+
+#if !defined(__NR_fsync)
+#define __NR_fsync 82
+#endif
+
+#if !defined(__NR_fdatasync)
+#define __NR_fdatasync 83
+#endif
+
+#if !defined(__NR_sync_file_range)
+#define __NR_sync_file_range 84
+#endif
+
+#if !defined(__NR_timerfd_create)
+#define __NR_timerfd_create 85
+#endif
+
+#if !defined(__NR_timerfd_settime)
+#define __NR_timerfd_settime 86
+#endif
+
+#if !defined(__NR_timerfd_gettime)
+#define __NR_timerfd_gettime 87
+#endif
+
+#if !defined(__NR_utimensat)
+#define __NR_utimensat 88
+#endif
+
+#if !defined(__NR_acct)
+#define __NR_acct 89
+#endif
+
+#if !defined(__NR_capget)
+#define __NR_capget 90
+#endif
+
+#if !defined(__NR_capset)
+#define __NR_capset 91
+#endif
+
+#if !defined(__NR_personality)
+#define __NR_personality 92
+#endif
+
+#if !defined(__NR_exit)
+#define __NR_exit 93
+#endif
+
+#if !defined(__NR_exit_group)
+#define __NR_exit_group 94
+#endif
+
+#if !defined(__NR_waitid)
+#define __NR_waitid 95
+#endif
+
+#if !defined(__NR_set_tid_address)
+#define __NR_set_tid_address 96
+#endif
+
+#if !defined(__NR_unshare)
+#define __NR_unshare 97
+#endif
+
+#if !defined(__NR_futex)
+#define __NR_futex 98
+#endif
+
+#if !defined(__NR_set_robust_list)
+#define __NR_set_robust_list 99
+#endif
+
+#if !defined(__NR_get_robust_list)
+#define __NR_get_robust_list 100
+#endif
+
+#if !defined(__NR_nanosleep)
+#define __NR_nanosleep 101
+#endif
+
+#if !defined(__NR_getitimer)
+#define __NR_getitimer 102
+#endif
+
+#if !defined(__NR_setitimer)
+#define __NR_setitimer 103
+#endif
+
+#if !defined(__NR_kexec_load)
+#define __NR_kexec_load 104
+#endif
+
+#if !defined(__NR_init_module)
+#define __NR_init_module 105
+#endif
+
+#if !defined(__NR_delete_module)
+#define __NR_delete_module 106
+#endif
+
+#if !defined(__NR_timer_create)
+#define __NR_timer_create 107
+#endif
+
+#if !defined(__NR_timer_gettime)
+#define __NR_timer_gettime 108
+#endif
+
+#if !defined(__NR_timer_getoverrun)
+#define __NR_timer_getoverrun 109
+#endif
+
+#if !defined(__NR_timer_settime)
+#define __NR_timer_settime 110
+#endif
+
+#if !defined(__NR_timer_delete)
+#define __NR_timer_delete 111
+#endif
+
+#if !defined(__NR_clock_settime)
+#define __NR_clock_settime 112
+#endif
+
+#if !defined(__NR_clock_gettime)
+#define __NR_clock_gettime 113
+#endif
+
+#if !defined(__NR_clock_getres)
+#define __NR_clock_getres 114
+#endif
+
+#if !defined(__NR_clock_nanosleep)
+#define __NR_clock_nanosleep 115
+#endif
+
+#if !defined(__NR_syslog)
+#define __NR_syslog 116
+#endif
+
+#if !defined(__NR_ptrace)
+#define __NR_ptrace 117
+#endif
+
+#if !defined(__NR_sched_setparam)
+#define __NR_sched_setparam 118
+#endif
+
+#if !defined(__NR_sched_setscheduler)
+#define __NR_sched_setscheduler 119
+#endif
+
+#if !defined(__NR_sched_getscheduler)
+#define __NR_sched_getscheduler 120
+#endif
+
+#if !defined(__NR_sched_getparam)
+#define __NR_sched_getparam 121
+#endif
+
+#if !defined(__NR_sched_setaffinity)
+#define __NR_sched_setaffinity 122
+#endif
+
+#if !defined(__NR_sched_getaffinity)
+#define __NR_sched_getaffinity 123
+#endif
+
+#if !defined(__NR_sched_yield)
+#define __NR_sched_yield 124
+#endif
+
+#if !defined(__NR_sched_get_priority_max)
+#define __NR_sched_get_priority_max 125
+#endif
+
+#if !defined(__NR_sched_get_priority_min)
+#define __NR_sched_get_priority_min 126
+#endif
+
+#if !defined(__NR_sched_rr_get_interval)
+#define __NR_sched_rr_get_interval 127
+#endif
+
+#if !defined(__NR_restart_syscall)
+#define __NR_restart_syscall 128
+#endif
+
+#if !defined(__NR_kill)
+#define __NR_kill 129
+#endif
+
+#if !defined(__NR_tkill)
+#define __NR_tkill 130
+#endif
+
+#if !defined(__NR_tgkill)
+#define __NR_tgkill 131
+#endif
+
+#if !defined(__NR_sigaltstack)
+#define __NR_sigaltstack 132
+#endif
+
+#if !defined(__NR_rt_sigsuspend)
+#define __NR_rt_sigsuspend 133
+#endif
+
+#if !defined(__NR_rt_sigaction)
+#define __NR_rt_sigaction 134
+#endif
+
+#if !defined(__NR_rt_sigprocmask)
+#define __NR_rt_sigprocmask 135
+#endif
+
+#if !defined(__NR_rt_sigpending)
+#define __NR_rt_sigpending 136
+#endif
+
+#if !defined(__NR_rt_sigtimedwait)
+#define __NR_rt_sigtimedwait 137
+#endif
+
+#if !defined(__NR_rt_sigqueueinfo)
+#define __NR_rt_sigqueueinfo 138
+#endif
+
+#if !defined(__NR_rt_sigreturn)
+#define __NR_rt_sigreturn 139
+#endif
+
+#if !defined(__NR_setpriority)
+#define __NR_setpriority 140
+#endif
+
+#if !defined(__NR_getpriority)
+#define __NR_getpriority 141
+#endif
+
+#if !defined(__NR_reboot)
+#define __NR_reboot 142
+#endif
+
+#if !defined(__NR_setregid)
+#define __NR_setregid 143
+#endif
+
+#if !defined(__NR_setgid)
+#define __NR_setgid 144
+#endif
+
+#if !defined(__NR_setreuid)
+#define __NR_setreuid 145
+#endif
+
+#if !defined(__NR_setuid)
+#define __NR_setuid 146
+#endif
+
+#if !defined(__NR_setresuid)
+#define __NR_setresuid 147
+#endif
+
+#if !defined(__NR_getresuid)
+#define __NR_getresuid 148
+#endif
+
+#if !defined(__NR_setresgid)
+#define __NR_setresgid 149
+#endif
+
+#if !defined(__NR_getresgid)
+#define __NR_getresgid 150
+#endif
+
+#if !defined(__NR_setfsuid)
+#define __NR_setfsuid 151
+#endif
+
+#if !defined(__NR_setfsgid)
+#define __NR_setfsgid 152
+#endif
+
+#if !defined(__NR_times)
+#define __NR_times 153
+#endif
+
+#if !defined(__NR_setpgid)
+#define __NR_setpgid 154
+#endif
+
+#if !defined(__NR_getpgid)
+#define __NR_getpgid 155
+#endif
+
+#if !defined(__NR_getsid)
+#define __NR_getsid 156
+#endif
+
+#if !defined(__NR_setsid)
+#define __NR_setsid 157
+#endif
+
+#if !defined(__NR_getgroups)
+#define __NR_getgroups 158
+#endif
+
+#if !defined(__NR_setgroups)
+#define __NR_setgroups 159
+#endif
+
+#if !defined(__NR_uname)
+#define __NR_uname 160
+#endif
+
+#if !defined(__NR_sethostname)
+#define __NR_sethostname 161
+#endif
+
+#if !defined(__NR_setdomainname)
+#define __NR_setdomainname 162
+#endif
+
+#if !defined(__NR_getrlimit)
+#define __NR_getrlimit 163
+#endif
+
+#if !defined(__NR_setrlimit)
+#define __NR_setrlimit 164
+#endif
+
+#if !defined(__NR_getrusage)
+#define __NR_getrusage 165
+#endif
+
+#if !defined(__NR_umask)
+#define __NR_umask 166
+#endif
+
+#if !defined(__NR_prctl)
+#define __NR_prctl 167
+#endif
+
+#if !defined(__NR_getcpu)
+#define __NR_getcpu 168
+#endif
+
+#if !defined(__NR_gettimeofday)
+#define __NR_gettimeofday 169
+#endif
+
+#if !defined(__NR_settimeofday)
+#define __NR_settimeofday 170
+#endif
+
+#if !defined(__NR_adjtimex)
+#define __NR_adjtimex 171
+#endif
+
+#if !defined(__NR_getpid)
+#define __NR_getpid 172
+#endif
+
+#if !defined(__NR_getppid)
+#define __NR_getppid 173
+#endif
+
+#if !defined(__NR_getuid)
+#define __NR_getuid 174
+#endif
+
+#if !defined(__NR_geteuid)
+#define __NR_geteuid 175
+#endif
+
+#if !defined(__NR_getgid)
+#define __NR_getgid 176
+#endif
+
+#if !defined(__NR_getegid)
+#define __NR_getegid 177
+#endif
+
+#if !defined(__NR_gettid)
+#define __NR_gettid 178
+#endif
+
+#if !defined(__NR_sysinfo)
+#define __NR_sysinfo 179
+#endif
+
+#if !defined(__NR_mq_open)
+#define __NR_mq_open 180
+#endif
+
+#if !defined(__NR_mq_unlink)
+#define __NR_mq_unlink 181
+#endif
+
+#if !defined(__NR_mq_timedsend)
+#define __NR_mq_timedsend 182
+#endif
+
+#if !defined(__NR_mq_timedreceive)
+#define __NR_mq_timedreceive 183
+#endif
+
+#if !defined(__NR_mq_notify)
+#define __NR_mq_notify 184
+#endif
+
+#if !defined(__NR_mq_getsetattr)
+#define __NR_mq_getsetattr 185
+#endif
+
+#if !defined(__NR_msgget)
+#define __NR_msgget 186
+#endif
+
+#if !defined(__NR_msgctl)
+#define __NR_msgctl 187
+#endif
+
+#if !defined(__NR_msgrcv)
+#define __NR_msgrcv 188
+#endif
+
+#if !defined(__NR_msgsnd)
+#define __NR_msgsnd 189
+#endif
+
+#if !defined(__NR_semget)
+#define __NR_semget 190
+#endif
+
+#if !defined(__NR_semctl)
+#define __NR_semctl 191
+#endif
+
+#if !defined(__NR_semtimedop)
+#define __NR_semtimedop 192
+#endif
+
+#if !defined(__NR_semop)
+#define __NR_semop 193
+#endif
+
+#if !defined(__NR_shmget)
+#define __NR_shmget 194
+#endif
+
+#if !defined(__NR_shmctl)
+#define __NR_shmctl 195
+#endif
+
+#if !defined(__NR_shmat)
+#define __NR_shmat 196
+#endif
+
+#if !defined(__NR_shmdt)
+#define __NR_shmdt 197
+#endif
+
+#if !defined(__NR_socket)
+#define __NR_socket 198
+#endif
+
+#if !defined(__NR_socketpair)
+#define __NR_socketpair 199
+#endif
+
+#if !defined(__NR_bind)
+#define __NR_bind 200
+#endif
+
+#if !defined(__NR_listen)
+#define __NR_listen 201
+#endif
+
+#if !defined(__NR_accept)
+#define __NR_accept 202
+#endif
+
+#if !defined(__NR_connect)
+#define __NR_connect 203
+#endif
+
+#if !defined(__NR_getsockname)
+#define __NR_getsockname 204
+#endif
+
+#if !defined(__NR_getpeername)
+#define __NR_getpeername 205
+#endif
+
+#if !defined(__NR_sendto)
+#define __NR_sendto 206
+#endif
+
+#if !defined(__NR_recvfrom)
+#define __NR_recvfrom 207
+#endif
+
+#if !defined(__NR_setsockopt)
+#define __NR_setsockopt 208
+#endif
+
+#if !defined(__NR_getsockopt)
+#define __NR_getsockopt 209
+#endif
+
+#if !defined(__NR_shutdown)
+#define __NR_shutdown 210
+#endif
+
+#if !defined(__NR_sendmsg)
+#define __NR_sendmsg 211
+#endif
+
+#if !defined(__NR_recvmsg)
+#define __NR_recvmsg 212
+#endif
+
+#if !defined(__NR_readahead)
+#define __NR_readahead 213
+#endif
+
+#if !defined(__NR_brk)
+#define __NR_brk 214
+#endif
+
+#if !defined(__NR_munmap)
+#define __NR_munmap 215
+#endif
+
+#if !defined(__NR_mremap)
+#define __NR_mremap 216
+#endif
+
+#if !defined(__NR_add_key)
+#define __NR_add_key 217
+#endif
+
+#if !defined(__NR_request_key)
+#define __NR_request_key 218
+#endif
+
+#if !defined(__NR_keyctl)
+#define __NR_keyctl 219
+#endif
+
+#if !defined(__NR_clone)
+#define __NR_clone 220
+#endif
+
+#if !defined(__NR_execve)
+#define __NR_execve 221
+#endif
+
+#if !defined(__NR_mmap)
+#define __NR_mmap 222
+#endif
+
+#if !defined(__NR_fadvise64)
+#define __NR_fadvise64 223
+#endif
+
+#if !defined(__NR_swapon)
+#define __NR_swapon 224
+#endif
+
+#if !defined(__NR_swapoff)
+#define __NR_swapoff 225
+#endif
+
+#if !defined(__NR_mprotect)
+#define __NR_mprotect 226
+#endif
+
+#if !defined(__NR_msync)
+#define __NR_msync 227
+#endif
+
+#if !defined(__NR_mlock)
+#define __NR_mlock 228
+#endif
+
+#if !defined(__NR_munlock)
+#define __NR_munlock 229
+#endif
+
+#if !defined(__NR_mlockall)
+#define __NR_mlockall 230
+#endif
+
+#if !defined(__NR_munlockall)
+#define __NR_munlockall 231
+#endif
+
+#if !defined(__NR_mincore)
+#define __NR_mincore 232
+#endif
+
+#if !defined(__NR_madvise)
+#define __NR_madvise 233
+#endif
+
+#if !defined(__NR_remap_file_pages)
+#define __NR_remap_file_pages 234
+#endif
+
+#if !defined(__NR_mbind)
+#define __NR_mbind 235
+#endif
+
+#if !defined(__NR_get_mempolicy)
+#define __NR_get_mempolicy 236
+#endif
+
+#if !defined(__NR_set_mempolicy)
+#define __NR_set_mempolicy 237
+#endif
+
+#if !defined(__NR_migrate_pages)
+#define __NR_migrate_pages 238
+#endif
+
+#if !defined(__NR_move_pages)
+#define __NR_move_pages 239
+#endif
+
+#if !defined(__NR_rt_tgsigqueueinfo)
+#define __NR_rt_tgsigqueueinfo 240
+#endif
+
+#if !defined(__NR_perf_event_open)
+#define __NR_perf_event_open 241
+#endif
+
+#if !defined(__NR_accept4)
+#define __NR_accept4 242
+#endif
+
+#if !defined(__NR_recvmmsg)
+#define __NR_recvmmsg 243
+#endif
+
+#if !defined(__NR_wait4)
+#define __NR_wait4 260
+#endif
+
+#if !defined(__NR_prlimit64)
+#define __NR_prlimit64 261
+#endif
+
+#if !defined(__NR_fanotify_init)
+#define __NR_fanotify_init 262
+#endif
+
+#if !defined(__NR_fanotify_mark)
+#define __NR_fanotify_mark 263
+#endif
+
+#if !defined(__NR_name_to_handle_at)
+#define __NR_name_to_handle_at 264
+#endif
+
+#if !defined(__NR_open_by_handle_at)
+#define __NR_open_by_handle_at 265
+#endif
+
+#if !defined(__NR_clock_adjtime)
+#define __NR_clock_adjtime 266
+#endif
+
+#if !defined(__NR_syncfs)
+#define __NR_syncfs 267
+#endif
+
+#if !defined(__NR_setns)
+#define __NR_setns 268
+#endif
+
+#if !defined(__NR_sendmmsg)
+#define __NR_sendmmsg 269
+#endif
+
+#if !defined(__NR_process_vm_readv)
+#define __NR_process_vm_readv 270
+#endif
+
+#if !defined(__NR_process_vm_writev)
+#define __NR_process_vm_writev 271
+#endif
+
+#if !defined(__NR_kcmp)
+#define __NR_kcmp 272
+#endif
+
+#if !defined(__NR_finit_module)
+#define __NR_finit_module 273
+#endif
+
+#if !defined(__NR_sched_setattr)
+#define __NR_sched_setattr 274
+#endif
+
+#if !defined(__NR_sched_getattr)
+#define __NR_sched_getattr 275
+#endif
+
+#if !defined(__NR_renameat2)
+#define __NR_renameat2 276
+#endif
+
+#if !defined(__NR_seccomp)
+#define __NR_seccomp 277
+#endif
+
+#if !defined(__NR_getrandom)
+#define __NR_getrandom 278
+#endif
+
+#if !defined(__NR_memfd_create)
+#define __NR_memfd_create 279
+#endif
+
+#if !defined(__NR_bfp)
+#define __NR_bfp 280
+#endif
+
+#if !defined(__NR_execveat)
+#define __NR_execveat 281
+#endif
+
+#if !defined(__NR_userfaultfd)
+#define __NR_userfaultfd 282
+#endif
+
+#if !defined(__NR_membarrier)
+#define __NR_membarrier 283
+#endif
+
+#if !defined(__NR_memlock2)
+#define __NR_memlock2 284
+#endif
+
+#if !defined(__NR_copy_file_range)
+#define __NR_copy_file_range 285
+#endif
+
+#if !defined(__NR_preadv2)
+#define __NR_preadv2 286
+#endif
+
+#if !defined(__NR_pwritev2)
+#define __NR_pwritev2 287
+#endif
+
+#if !defined(__NR_pkey_mprotect)
+#define __NR_pkey_mprotect 288
+#endif
+
+#if !defined(__NR_pkey_alloc)
+#define __NR_pkey_alloc 289
+#endif
+
+#if !defined(__NR_pkey_free)
+#define __NR_pkey_free 290
+#endif
+
+#if !defined(__NR_statx)
+#define __NR_statx 291
+#endif
+
+#if !defined(__NR_io_pgetevents)
+#define __NR_io_pgetevents 292
+#endif
+
+#if !defined(__NR_rseq)
+#define __NR_rseq 293
+#endif
+
+#if !defined(__NR_kexec_file_load)
+#define __NR_kexec_file_load 294
+#endif
+
+#if !defined(__NR_pidfd_send_signal)
+#define __NR_pidfd_send_signal 424
+#endif
+
+#if !defined(__NR_io_uring_setup)
+#define __NR_io_uring_setup 425
+#endif
+
+#if !defined(__NR_io_uring_enter)
+#define __NR_io_uring_enter 426
+#endif
+
+#if !defined(__NR_io_uring_register)
+#define __NR_io_uring_register 427
+#endif
+
+#if !defined(__NR_open_tree)
+#define __NR_open_tree 428
+#endif
+
+#if !defined(__NR_move_mount)
+#define __NR_move_mount 429
+#endif
+
+#if !defined(__NR_fsopen)
+#define __NR_fsopen 430
+#endif
+
+#if !defined(__NR_fsconfig)
+#define __NR_fsconfig 431
+#endif
+
+#if !defined(__NR_fsmount)
+#define __NR_fsmount 432
+#endif
+
+#if !defined(__NR_fspick)
+#define __NR_fspick 433
+#endif
+
+#if !defined(__NR_pidfd_open)
+#define __NR_pidfd_open 434
+#endif
+
+#if !defined(__NR_clone3)
+#define __NR_clone3 435
+#endif
+
+#if !defined(__NR_close_range)
+#define __NR_close_range 436
+#endif
+
+#if !defined(__NR_openat2)
+#define __NR_openat2 437
+#endif
+
+#if !defined(__NR_pidfd_getfd)
+#define __NR_pidfd_getfd 438
+#endif
+
+#if !defined(__NR_faccessat2)
+#define __NR_faccessat2 439
+#endif
+
+#if !defined(__NR_process_madvise)
+#define __NR_process_madvise 440
+#endif
+
+#if !defined(__NR_epoll_pwait2)
+#define __NR_epoll_pwait2 441
+#endif
+
+#if !defined(__NR_mount_setattr)
+#define __NR_mount_setattr 442
+#endif
+
+#if !defined(__NR_quotactl_path)
+#define __NR_quotactl_path 443
+#endif
+
+#if !defined(__NR_landlock_create_ruleset)
+#define __NR_landlock_create_ruleset 444
+#endif
+
+#if !defined(__NR_landlock_add_rule)
+#define __NR_landlock_add_rule 445
+#endif
+
+#if !defined(__NR_landlock_restrict_self)
+#define __NR_landlock_restrict_self 446
+#endif
+
+#endif  // SANDBOX_LINUX_SYSTEM_HEADERS_LOONGARCH64_LINUX_SYSCALLS_H_
diff --git a/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc b/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
index df2567f7498..7c332713026 100644
--- a/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_cros_amd_gpu_policy_linux.cc
@@ -38,7 +38,7 @@ ResultExpr CrosAmdGpuProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_sched_setscheduler:
     case __NR_sysinfo:
     case __NR_uname:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_readlink:
     case __NR_stat:
 #endif
diff --git a/sandbox/policy/linux/bpf_gpu_policy_linux.cc b/sandbox/policy/linux/bpf_gpu_policy_linux.cc
index 35ccbb7a7f8..d59c64bcbd5 100644
--- a/sandbox/policy/linux/bpf_gpu_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_gpu_policy_linux.cc
@@ -73,7 +73,7 @@ ResultExpr GpuProcessPolicy::EvaluateSyscall(int sysno) const {
     (defined(ARCH_CPU_MIPS_FAMILY) && defined(ARCH_CPU_32_BITS))
     case __NR_ftruncate64:
 #endif
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_getdents:
 #endif
     case __NR_getdents64:
diff --git a/sandbox/policy/linux/bpf_network_policy_linux.cc b/sandbox/policy/linux/bpf_network_policy_linux.cc
index ed1582d7905..f7a7b14df5c 100644
--- a/sandbox/policy/linux/bpf_network_policy_linux.cc
+++ b/sandbox/policy/linux/bpf_network_policy_linux.cc
@@ -255,7 +255,7 @@ ResultExpr NetworkProcessPolicy::EvaluateSyscall(int sysno) const {
     case __NR_fdatasync:
     case __NR_fsync:
     case __NR_mremap:
-#if !defined(__aarch64__)
+#if !defined(__aarch64__) && !defined(__loongarch_lp64)
     case __NR_getdents:
 #endif
     case __NR_getdents64:
diff --git a/skia/BUILD.gn b/skia/BUILD.gn
index 012e650b592..5767a8495bd 100644
--- a/skia/BUILD.gn
+++ b/skia/BUILD.gn
@@ -789,6 +789,8 @@ skia_source_set("skia_opts") {
     # Conditional and empty body needed to avoid assert() below.
   } else if (current_cpu == "riscv64") {
     # Conditional and empty body needed to avoid assert() below.
+  } else if (current_cpu == "loong64") {
+    # Conditional and empty body needed to avoid assert() below.
   } else {
     assert(false, "Unknown cpu target")
   }
diff --git a/third_party/blink/renderer/bindings/core/v8/async_iterable.h b/third_party/blink/renderer/bindings/core/v8/async_iterable.h
index b4f3b0dbf41..4fff7509f2d 100644
--- a/third_party/blink/renderer/bindings/core/v8/async_iterable.h
+++ b/third_party/blink/renderer/bindings/core/v8/async_iterable.h
@@ -220,7 +220,7 @@ class PairAsyncIterable {
  private:
   virtual IterationSource* CreateIterationSource(
       ScriptState* script_state,
-      IterationSource::Kind kind,
+      typename IterationSource::Kind kind,
       ExceptionState& exception_state) = 0;
 };
 
@@ -262,7 +262,7 @@ class ValueAsyncIterable {
  private:
   virtual IterationSource* CreateIterationSource(
       ScriptState* script_state,
-      IterationSource::Kind kind,
+      typename IterationSource::Kind kind,
       ExceptionState& exception_state) = 0;
 };
 
diff --git a/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc b/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc
index 83ef203ed50..b211f4316ea 100644
--- a/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc
+++ b/third_party/blink/renderer/core/html/parser/html_document_parser_fastpath.cc
@@ -172,7 +172,7 @@ class HTMLFastPathParser {
   using Span = base::span<const Char>;
   using USpan = base::span<const UChar>;
   // 32 matches that used by HTMLToken::Attribute.
-  typedef std::conditional<std::is_same_v<Char, UChar>,
+  typedef typename std::conditional<std::is_same_v<Char, UChar>,
                            UCharLiteralBuffer<32>,
                            LCharLiteralBuffer<32>>::type LiteralBufferType;
   typedef UCharLiteralBuffer<32> UCharLiteralBufferType;
diff --git a/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc b/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc
index 35be24c60c2..edef9b46189 100644
--- a/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc
+++ b/third_party/blink/renderer/core/layout/grid/grid_layout_algorithm.cc
@@ -3445,7 +3445,11 @@ void GridLayoutAlgorithm::PlaceGridItems(
   DCHECK(out_row_break_between);
 
   const auto& container_space = ConstraintSpace();
-  const auto& [grid_items, layout_data, tree_size] = sizing_tree.TreeRootData();
+  //const auto& [grid_items, layout_data, tree_size] = sizing_tree.TreeRootData();
+  const auto& grid_tree_node = sizing_tree.TreeRootData();
+  const auto& grid_items = grid_tree_node.grid_items;
+  const auto& layout_data = grid_tree_node.layout_data;
+  //const auto& tree_size = grid_tree_node.subtree_size;
 
   const auto* cached_layout_subtree = container_space.GetGridLayoutSubtree();
   const auto container_writing_direction =
@@ -3609,7 +3613,11 @@ void GridLayoutAlgorithm::PlaceGridItemsForFragmentation(
 
   // TODO(ikilpatrick): Update |SetHasSeenAllChildren| and early exit if true.
   const auto& constraint_space = ConstraintSpace();
-  const auto& [grid_items, layout_data, tree_size] = sizing_tree.TreeRootData();
+  //const auto& [grid_items, layout_data, tree_size] = sizing_tree.TreeRootData();
+  const auto& grid_tree_node = sizing_tree.TreeRootData();
+  const auto& grid_items = grid_tree_node.grid_items;
+  const auto& layout_data = grid_tree_node.layout_data;
+  //const auto& tree_size = grid_tree_node.subtree_size;
 
   const auto* cached_layout_subtree = constraint_space.GetGridLayoutSubtree();
   const auto container_writing_direction =
diff --git a/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h b/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h
index 9adc6dfac54..be94e55af7c 100644
--- a/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h
+++ b/third_party/blink/renderer/core/paint/object_paint_properties_sparse.h
@@ -272,8 +272,8 @@ class CORE_EXPORT ObjectPaintPropertiesSparse : public ObjectPaintProperties {
       NodeList& nodes,
       NodeId node_id,
       const ParentType& parent,
-      NodeType::State&& state,
-      const NodeType::AnimationState& animation_state =
+      typename NodeType::State&& state,
+      const typename NodeType::AnimationState& animation_state =
           NodeType::AnimationState()) {
     // First, check if we need to add a new node.
     if (!nodes.HasField(node_id)) {
diff --git a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc
index fb635d9b0a7..62eb37ff6b9 100644
--- a/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc
+++ b/third_party/blink/renderer/modules/canvas/canvas2d/canvas_style.cc
@@ -83,6 +83,12 @@ bool ParseCanvasColorString(const String& color_string, Color& parsed_color) {
 
 void CanvasStyle::ApplyToFlags(cc::PaintFlags& flags,
                                float global_alpha) const {
+  SkColor4f rgba;
+  rgba.fR = 0.0f;
+  rgba.fG = 0.0f;
+  rgba.fB = 0.0f;
+  rgba.fA = global_alpha;
+
   switch (type_) {
     case kColor:
       ApplyColorToFlags(flags, global_alpha);
@@ -90,12 +96,12 @@ void CanvasStyle::ApplyToFlags(cc::PaintFlags& flags,
     case kGradient:
       GetCanvasGradient()->GetGradient()->ApplyToFlags(flags, SkMatrix::I(),
                                                        ImageDrawOptions());
-      flags.setColor(SkColor4f(0.0f, 0.0f, 0.0f, global_alpha));
+      flags.setColor(rgba);
       break;
     case kImagePattern:
       GetCanvasPattern()->GetPattern()->ApplyToFlags(
           flags, AffineTransformToSkMatrix(GetCanvasPattern()->GetTransform()));
-      flags.setColor(SkColor4f(0.0f, 0.0f, 0.0f, global_alpha));
+      flags.setColor(rgba);
       break;
     default:
       NOTREACHED();
diff --git a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc
index b3624fc0162..5fe5ee1008d 100644
--- a/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc
+++ b/third_party/blink/renderer/modules/service_worker/service_worker_global_scope.cc
@@ -2791,9 +2791,11 @@ void ServiceWorkerGlobalScope::InsertNewItemToRaceNetworkRequests(
         url_loader_factory,
     const KURL& request_url) {
   auto race_network_request_token = String(token.ToString());
-  auto info = std::make_unique<RaceNetworkRequestInfo>(
-      fetch_event_id, race_network_request_token,
-      std::move(url_loader_factory));
+  RaceNetworkRequestInfo request_info;
+  request_info.fetch_event_id = fetch_event_id;
+  request_info.token = race_network_request_token;
+  request_info.url_loader_factory = std::move(url_loader_factory);
+  auto info = std::make_unique<RaceNetworkRequestInfo>(std::move(request_info));
   race_network_request_fetch_event_ids_.insert(fetch_event_id, info.get());
   auto insert_result = race_network_requests_.insert(race_network_request_token,
                                                      std::move(info));
diff --git a/third_party/blink/renderer/platform/BUILD.gn b/third_party/blink/renderer/platform/BUILD.gn
index aaabc708f03..33206301ee6 100644
--- a/third_party/blink/renderer/platform/BUILD.gn
+++ b/third_party/blink/renderer/platform/BUILD.gn
@@ -1598,7 +1598,7 @@ component("platform") {
   if (current_cpu == "loong64") {
     cflags = [
       "-mlsx",
-      "-flax-vector-conversions",
+      "-flax-vector-conversions=all",
     ]
   }
 
diff --git a/third_party/blink/renderer/platform/fonts/font_palette.h b/third_party/blink/renderer/platform/fonts/font_palette.h
index 01dac9c908e..eab8b108d3a 100644
--- a/third_party/blink/renderer/platform/fonts/font_palette.h
+++ b/third_party/blink/renderer/platform/fonts/font_palette.h
@@ -95,8 +95,11 @@ class PLATFORM_EXPORT FontPalette : public RefCounted<FontPalette> {
       double alpha_multiplier,
       Color::ColorSpace color_interpolation_space,
       absl::optional<Color::HueInterpolationMethod> hue_interpolation_method) {
+    NonNormalizedPercentages percentages;
+    percentages.start = start_percentage;
+    percentages.end = end_percentage;
     return base::AdoptRef(new FontPalette(
-        start, end, NonNormalizedPercentages(start_percentage, end_percentage),
+        start, end, percentages,
         normalized_percentage, alpha_multiplier, color_interpolation_space,
         hue_interpolation_method));
   }
@@ -168,9 +171,10 @@ class PLATFORM_EXPORT FontPalette : public RefCounted<FontPalette> {
 
   static NonNormalizedPercentages ComputeEndpointPercentagesFromNormalized(
       double normalized_percentage) {
-    double end_percentage = normalized_percentage * 100.0;
-    double start_percentage = 100.0 - end_percentage;
-    return NonNormalizedPercentages(start_percentage, end_percentage);
+    NonNormalizedPercentages percentages;
+    percentages.end = normalized_percentage * 100.0;
+    percentages.start = 100.0 - percentages.end;
+    return percentages;
   }
 
   double GetAlphaMultiplier() const {
diff --git a/third_party/blink/renderer/platform/fonts/palette_interpolation.cc b/third_party/blink/renderer/platform/fonts/palette_interpolation.cc
index 1ce08e956a7..cf49c00bec2 100644
--- a/third_party/blink/renderer/platform/fonts/palette_interpolation.cc
+++ b/third_party/blink/renderer/platform/fonts/palette_interpolation.cc
@@ -31,7 +31,9 @@ Vector<FontPalette::FontPaletteOverride> PaletteInterpolation::MixColorRecords(
         color_interpolation_space, hue_interpolation_method, start_color,
         end_color, percentage, alpha_multiplier);
 
-    FontPalette::FontPaletteOverride result_color_record(i, result_color);
+    FontPalette::FontPaletteOverride result_color_record;
+    result_color_record.index = i;
+    result_color_record.color = result_color;
     result_color_records.push_back(result_color_record);
   }
   return result_color_records;
diff --git a/third_party/boringssl/src/include/openssl/target.h b/third_party/boringssl/src/include/openssl/target.h
index 12736416f36..8ef6d040af4 100644
--- a/third_party/boringssl/src/include/openssl/target.h
+++ b/third_party/boringssl/src/include/openssl/target.h
@@ -45,6 +45,9 @@
 #define OPENSSL_RISCV64
 #elif defined(__riscv) && __SIZEOF_POINTER__ == 4
 #define OPENSSL_32_BIT
+#elif defined(__loongarch__) && __loongarch_grlen == 64
+#define OPENSSL_64_BIT
+#define OPENSSL_LOONG64
 #elif defined(__pnacl__)
 #define OPENSSL_32_BIT
 #define OPENSSL_PNACL
diff --git a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
index 1d79be7a08c..bf6adddadcb 100644
--- a/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
+++ b/third_party/crashpad/crashpad/client/crashpad_client_linux.cc
@@ -170,7 +170,9 @@ class SignalHandler {
     exception_information_.context_address =
         FromPointerCast<decltype(exception_information_.context_address)>(
             context);
+#if !defined(__loongarch_lp64)
     exception_information_.thread_id = sys_gettid();
+#endif
 
     ScopedPrSetDumpable set_dumpable(false);
     HandleCrashImpl();
@@ -309,7 +311,9 @@ class LaunchAtCrashHandler : public SignalHandler {
   }
 
   void HandleCrashImpl() override {
+#if !defined(__loongarch_lp64)
     ScopedPrSetPtracer set_ptracer(sys_getpid(), /* may_log= */ false);
+#endif
 
     pid_t pid = fork();
     if (pid < 0) {
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context.h b/third_party/crashpad/crashpad/minidump/minidump_context.h
index 12413de02b6..9c584e8f003 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context.h
@@ -687,6 +687,57 @@ struct MinidumpContextRISCV64 {
   uint32_t fcsr;
 };
 
+//! \brief LOONGARCH64-specifc flags for MinidumpContextLOONGARCH64::context_flags.
+//! Based on minidump_cpu_loongarch64.h from breakpad
+enum MinidumpContextLOONGARCH64Flags : uint32_t {
+  //! \brief Identifies the context structure as LOONGARCH64.
+  kMinidumpContextLOONGARCH64 = 0x00800000,
+
+  //! \brief Indicates the validity of integer registers.
+  //!
+  //! Registers `0`-`31`, `epc` are valid.
+  kMinidumpContextLOONGARCH64Integer = kMinidumpContextLOONGARCH64 | 0x00000002,
+
+  //! \brief Indicates the validity of floating point registers.
+  //!
+  //! Floating point registers `0`-`31`, `fpcsr` and `fir` are valid
+  kMinidumpContextLOONGARCH64FloatingPoint = kMinidumpContextLOONGARCH64 | 0x00000004,
+
+  //! \brief Indicates the validity of all registers.
+  kMinidumpContextLOONGARCH64All = kMinidumpContextLOONGARCH64Integer |
+                              kMinidumpContextLOONGARCH64FloatingPoint,
+};
+
+//! \brief A LOONGARCH64 CPU context (register state) carried in a minidump file.
+struct MinidumpContextLOONGARCH64 {
+  uint64_t context_flags;
+
+
+  //! \brief General purpose registers.
+  uint64_t regs[32];
+
+  //! \brief csr_epc registers.
+  uint64_t csr_epc;
+
+  //! \brief FPU registers.
+  union {
+    struct {
+      float _fp_fregs;
+      uint32_t _fp_pad;
+    } fregs[32];
+    double dregs[32];
+  } fpregs;
+
+  //! \brief Floating-point control and status register.
+  uint32_t fcsr;
+
+  //! \brief padding
+  uint32_t _pad;
+
+  //! \brief Floating-point status and control register.
+  uint64_t fcc;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
index 326b51fed6d..926dafa2d51 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.cc
@@ -110,6 +110,13 @@ MinidumpContextWriter::CreateFromSnapshot(const CPUContext* context_snapshot) {
       break;
     }
 
+    case kCPUArchitectureLOONGARCH64: {
+      context = std::make_unique<MinidumpContextLOONGARCH64Writer>();
+      reinterpret_cast<MinidumpContextLOONGARCH64Writer*>(context.get())
+          ->InitializeFromSnapshot(context_snapshot->loongarch64);
+      break;
+    }
+
     default: {
       LOG(ERROR) << "unknown context architecture "
                  << context_snapshot->architecture;
@@ -602,4 +609,43 @@ size_t MinidumpContextRISCV64Writer::ContextSize() const {
   return sizeof(context_);
 }
 
+MinidumpContextLOONGARCH64Writer::MinidumpContextLOONGARCH64Writer()
+    : MinidumpContextWriter(), context_() {
+  context_.context_flags = kMinidumpContextLOONGARCH64;
+}
+
+MinidumpContextLOONGARCH64Writer::~MinidumpContextLOONGARCH64Writer() = default;
+
+void MinidumpContextLOONGARCH64Writer::InitializeFromSnapshot(
+    const CPUContextLOONGARCH64* context_snapshot) {
+  DCHECK_EQ(state(), kStateMutable);
+  DCHECK_EQ(context_.context_flags, kMinidumpContextLOONGARCH64);
+
+  context_.context_flags = kMinidumpContextLOONGARCH64All;
+
+  static_assert(sizeof(context_.regs) == sizeof(context_snapshot->regs),
+                "GPRs size mismatch");
+  memcpy(context_.regs, context_snapshot->regs, sizeof(context_.regs));
+  context_.csr_epc = context_snapshot->csr_epc;
+
+  static_assert(sizeof(context_.fpregs) == sizeof(context_snapshot->fpregs),
+                "FPRs size mismatch");
+  memcpy(context_.fpregs.dregs,
+         context_snapshot->fpregs.dregs,
+         sizeof(context_.fpregs.dregs));
+  context_.fcsr = context_snapshot->fcsr;
+  context_.fcc = context_snapshot->fcc;
+}
+
+bool MinidumpContextLOONGARCH64Writer::WriteObject(
+    FileWriterInterface* file_writer) {
+  DCHECK_EQ(state(), kStateWritable);
+  return file_writer->Write(&context_, sizeof(context_));
+}
+
+size_t MinidumpContextLOONGARCH64Writer::ContextSize() const {
+  DCHECK_GE(state(), kStateFrozen);
+  return sizeof(context_);
+}
+
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
index 8e39c6692f2..85ca7ffd2e7 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer.h
@@ -413,6 +413,44 @@ class MinidumpContextRISCV64Writer final : public MinidumpContextWriter {
   MinidumpContextRISCV64 context_;
 };
 
+//! \brief The writer for a MinidumpContextLOONGARCH64 structure in a minidump file.
+class MinidumpContextLOONGARCH64Writer final : public MinidumpContextWriter {
+ public:
+  MinidumpContextLOONGARCH64Writer();
+  ~MinidumpContextLOONGARCH64Writer() override;
+
+  //! \brief Initializes the MinidumpContextLOONGARCH based on \a context_snapshot.
+  //!
+  //! \param[in] context_snapshot The context snapshot to use as source data.
+  //!
+  //! \note Valid in #kStateMutable. No mutation of context() may be done before
+  //!     calling this method, and it is not normally necessary to alter
+  //!     context() after calling this method.
+  void InitializeFromSnapshot(const CPUContextLOONGARCH64* context_snapshot);
+
+  //! \brief Returns a pointer to the context structure that this object will
+  //!     write.
+  //!
+  //! \attention This returns a non-`const` pointer to this objects private
+  //!     data so that a caller can populate the context structure directly.
+  //!     This is done because providing setter interfaces to each field in the
+  //!     context structure would be unwieldy and cumbersome. Care must be taken
+  //!     to populate the context structure correctly. The context structure
+  //!     must only be modified while this object is in the #kStateMutable
+  //!     state.
+  MinidumpContextLOONGARCH64* context() { return &context_; }
+
+ protected:
+  // MinidumpWritable:
+  bool WriteObject(FileWriterInterface* file_writer) override;
+
+  // MinidumpContextWriter:
+  size_t ContextSize() const override;
+
+ private:
+  MinidumpContextLOONGARCH64 context_;
+};
+
 }  // namespace crashpad
 
 #endif  // CRASHPAD_MINIDUMP_MINIDUMP_CONTEXT_WRITER_H_
diff --git a/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc b/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
index 9eebe81b296..4f38933dcbb 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_context_writer_test.cc
@@ -328,6 +328,22 @@ TYPED_TEST(MinidumpContextWriter, RISCV64_FromSnapshot) {
                    TypeParam>(context, ExpectMinidumpContextRISCV64, kSeed);
 }
 
+TYPED_TEST(MinidumpContextWriter, LOONGARCH64_Zeros) {
+  EmptyContextTest<MinidumpContextLOONGARCH64Writer,
+                   MinidumpContextLOONGARCH64,
+                   TypeParam>(ExpectMinidumpContextLOONGARCH64);
+}
+
+TYPED_TEST(MinidumpContextWriter, LOONGARCH64_FromSnapshot) {
+  constexpr uint32_t kSeed = 64;
+  CPUContextLOONGARCH64 context_loongarch64;
+  CPUContext context;
+  context.loongarch64 = &context_loongarch64;
+  InitializeCPUContextLOONGARCH64(&context, kSeed);
+  FromSnapshotTest<MinidumpContextLOONGARCH64Writer, MinidumpContextLOONGARCH64,
+                   TypeParam>(context, ExpectMinidumpContextLOONGARCH64, kSeed);
+}
+
 }  // namespace
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/minidump_extensions.h b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
index a5f442bf5eb..dcc867eae7f 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_extensions.h
+++ b/third_party/crashpad/crashpad/minidump/minidump_extensions.h
@@ -213,6 +213,12 @@ enum MinidumpCPUArchitecture : uint16_t {
   //! \brief Used by Breakpad for 64-bit RISC-V.
   kMinidumpCPUArchitectureRISCV64Breakpad = 0x8006,
 
+  //! \brief 64-bit LoongArch
+  //!
+  //! These systems indentify their CPUs generically as "loongarch64", or
+  //! with more specific names such as "loongarch".
+  kMinidumpCPUArchitectureLOONGARCH64 = 0x8005,
+
   //! \brief Unknown CPU architecture.
   kMinidumpCPUArchitectureUnknown = PROCESSOR_ARCHITECTURE_UNKNOWN,
 };
diff --git a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
index 1abb46c3181..e0779980d0e 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_misc_info_writer.cc
@@ -177,6 +177,8 @@ std::string MinidumpMiscInfoDebugBuildString() {
   static constexpr char kCPU[] = "mips64";
 #elif defined(ARCH_CPU_RISCV64)
   static constexpr char kCPU[] = "riscv64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+  static constexpr char kCPU[] = "loongarch64";
 #else
 #error define kCPU for this CPU
 #endif
diff --git a/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc b/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
index e2ab775ae77..f554263d60e 100644
--- a/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
+++ b/third_party/crashpad/crashpad/minidump/minidump_system_info_writer.cc
@@ -135,6 +135,9 @@ void MinidumpSystemInfoWriter::InitializeFromSnapshot(
     case kCPUArchitectureRISCV64:
       cpu_architecture = kMinidumpCPUArchitectureRISCV64Breakpad;
       break;
+    case kCPUArchitectureLOONGARCH64:
+      cpu_architecture = kMinidumpCPUArchitectureLOONGARCH64;
+      break;
     default:
       NOTREACHED();
       cpu_architecture = kMinidumpCPUArchitectureUnknown;
diff --git a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
index b40558cf288..010fcd113fa 100644
--- a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
+++ b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.cc
@@ -297,6 +297,31 @@ void InitializeMinidumpContextRISCV64(MinidumpContextRISCV64* context,
   context->fcsr = value++;
 }
 
+void InitializeMinidumpContextLOONGARCH64(MinidumpContextLOONGARCH64* context,
+                                     uint32_t seed) {
+  if (seed == 0) {
+    memset(context, 0, sizeof(*context));
+    context->context_flags = kMinidumpContextLOONGARCH64;
+    return;
+  }
+
+  context->context_flags = kMinidumpContextLOONGARCH64All;
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(context->regs); ++index) {
+    context->regs[index] = value++;
+  }
+
+  context->csr_epc = value++;
+
+  for (size_t index = 0; index < std::size(context->fpregs.dregs); ++index) {
+    context->fpregs.dregs[index] = static_cast<double>(value++);
+  }
+  context->fcsr = value++;
+  context->fcc = value++;
+}
+
 namespace {
 
 // Using Google Test assertions, compares |expected| to |observed|. This is
@@ -645,5 +670,26 @@ void ExpectMinidumpContextRISCV64(uint32_t expect_seed,
   EXPECT_EQ(observed->fcsr, expected.fcsr);
 }
 
+void ExpectMinidumpContextLOONGARCH64(uint32_t expect_seed,
+                                 const MinidumpContextLOONGARCH64* observed,
+                                 bool snapshot) {
+  MinidumpContextLOONGARCH64 expected;
+  InitializeMinidumpContextLOONGARCH64(&expected, expect_seed);
+
+  EXPECT_EQ(observed->context_flags, expected.context_flags);
+
+  for (size_t index = 0; index < std::size(expected.regs); ++index) {
+    EXPECT_EQ(observed->regs[index], expected.regs[index]);
+  }
+
+  EXPECT_EQ(observed->csr_epc, expected.csr_epc);
+
+  for (size_t index = 0; index < std::size(expected.fpregs.dregs); ++index) {
+    EXPECT_EQ(observed->fpregs.dregs[index], expected.fpregs.dregs[index]);
+  }
+  EXPECT_EQ(observed->fcsr, expected.fcsr);
+  EXPECT_EQ(observed->fcc, expected.fcc);
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
index 4ce5c1e1c39..cadb24ee011 100644
--- a/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
+++ b/third_party/crashpad/crashpad/minidump/test/minidump_context_test_util.h
@@ -49,6 +49,8 @@ void InitializeMinidumpContextMIPS64(MinidumpContextMIPS* context,
                                      uint32_t seed);
 void InitializeMinidumpContextRISCV64(MinidumpContextRISCV64* context,
                                       uint32_t seed);
+void InitializeMinidumpContextLOONGARCH64(MinidumpContextLOONGARCH64* context,
+                                          uint32_t seed);
 //! \}
 
 //! \brief Verifies, via Google Test assertions, that a context structure
@@ -90,6 +92,9 @@ void ExpectMinidumpContextMIPS64(uint32_t expect_seed,
 void ExpectMinidumpContextRISCV64(uint32_t expect_seed,
                                   const MinidumpContextRISCV64* observed,
                                   bool snapshot);
+void ExpectMinidumpContextLOONGARCH64(uint32_t expect_seed,
+                                      const MinidumpContextLOONGARCH64* observed,
+                                      bool snapshot);
 //! \}
 
 }  // namespace test
diff --git a/third_party/crashpad/crashpad/snapshot/capture_memory.cc b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
index c1c6fba58fe..061069b1577 100644
--- a/third_party/crashpad/crashpad/snapshot/capture_memory.cc
+++ b/third_party/crashpad/crashpad/snapshot/capture_memory.cc
@@ -113,7 +113,7 @@ void CaptureMemory::PointedToByContext(const CPUContext& context,
       MaybeCaptureMemoryAround(delegate, context.arm->regs[i]);
     }
   }
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
   for (size_t i = 0; i < std::size(context.mipsel->regs); ++i) {
     MaybeCaptureMemoryAround(delegate, context.mipsel->regs[i]);
   }
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
index 26d45f84122..86875964fdd 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_architecture.h
@@ -47,6 +47,9 @@ enum CPUArchitecture {
 
   //! \brief 64-bit RISC-V.
   kCPUArchitectureRISCV64,
+
+  //! \brief 64-bit LoongArch.
+  kCPUArchitectureLOONGARCH64,
 };
 
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.cc b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
index 492a0f7f914..b03161d6922 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.cc
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.cc
@@ -191,6 +191,8 @@ uint64_t CPUContext::StackPointer() const {
       return arm64->sp;
     case kCPUArchitectureRISCV64:
       return riscv64->regs[1];
+    case kCPUArchitectureLOONGARCH64:
+      return loongarch64->regs[3];
     default:
       NOTREACHED();
       return ~0ull;
diff --git a/third_party/crashpad/crashpad/snapshot/cpu_context.h b/third_party/crashpad/crashpad/snapshot/cpu_context.h
index c3640c328c6..8f0adc3a253 100644
--- a/third_party/crashpad/crashpad/snapshot/cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/cpu_context.h
@@ -371,6 +371,21 @@ struct CPUContextRISCV64 {
   uint32_t fcsr;
 };
 
+struct CPUContextLOONGARCH64 {
+  uint64_t regs[32];
+  uint64_t csr_epc;
+  union {
+    double dregs[32];
+    struct {
+      float _fp_fregs;
+      uint32_t _fp_pad;
+    } fregs[32];
+  } fpregs;
+  uint32_t fcsr;
+  uint32_t _pad;
+  uint64_t fcc;
+};
+
 //! \brief A context structure capable of carrying the context of any supported
 //!     CPU architecture.
 struct CPUContext {
@@ -412,6 +427,7 @@ struct CPUContext {
     CPUContextMIPS* mipsel;
     CPUContextMIPS64* mips64;
     CPUContextRISCV64* riscv64;
+    CPUContextLOONGARCH64* loongarch64;
   };
 };
 
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
index 6c4cb3ebce6..d0c37752b8a 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.cc
@@ -281,6 +281,23 @@ void InitializeCPUContextRISCV64(const ThreadContext::t64_t& thread_context,
   context->fcsr = float_context.fcsr;
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+void InitializeCPUContextLOONGARCH64(const ThreadContext::t64_t& thread_context,
+    const FloatContext::f64_t& float_context,
+    CPUContextLOONGARCH64* context) {
+  static_assert(sizeof(context->regs) == sizeof(thread_context.regs),
+                "registers size mismatch");
+  static_assert(sizeof(context->fpregs) == sizeof(float_context.fpregs),
+                "fp registers size mismatch");
+  memcpy(&context->regs, &thread_context.regs, sizeof(context->regs));
+  context->csr_epc = thread_context.csr_epc;
+
+  memcpy(&context->fpregs, &float_context.fpregs, sizeof(context->fpregs));
+  context->fcsr = float_context.fcsr;
+  context->fcc = float_context.fcc;
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 }  // namespace internal
diff --git a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
index 507d1b44dd0..3d69415a8b9 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/cpu_context_linux.h
@@ -174,6 +174,23 @@ void InitializeCPUContextMIPS(
 
 #endif  // ARCH_CPU_MIPS_FAMILY || DOXYGEN
 
+#if defined(ARCH_CPU_LOONGARCH_FAMILY) || DOXYGEN
+
+//! \brief Initializes a CPUContextLOONGARCH64 structure from native context
+//!     structures on Linux.
+//!
+//! This function has template specializations for LOONGARCH64 architecture
+//! contexts, using ContextTraits32 or ContextTraits64 as template parameter,
+//! respectively.
+//!
+//! \param[in] thread_context The native thread context.
+//! \param[in] float_context The native float context.
+//! \param[out] context The CPUContextLOONGARCH64 structure to initialize.
+void InitializeCPUContextLOONGARCH64(const ThreadContext::t64_t& thread_context,
+                                     const FloatContext::f64_t& float_context,
+                                     CPUContextLOONGARCH64* context);
+#endif  // ARCH_CPU_LOONGARCH_FAMILY || DOXYGEN
+
 #if defined(ARCH_CPU_RISCV64) || DOXYGEN
 
 //! \brief Initializes a CPUContextRISCV64 structure from native context
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
index 677afdaa773..93d8098133d 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.cc
@@ -367,6 +367,63 @@ bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
   return internal::ReadContext(reader, context_address, context_.riscv64);
 }
 
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+
+template <typename Traits>
+static bool ReadContext(ProcessReaderLinux* reader,
+                        LinuxVMAddress context_address,
+                        typename Traits::CPUContext* dest_context) {
+  const ProcessMemory* memory = reader->Memory();
+
+  /* WORKAROUND: signal_context isn't compatible with Mcontext64 here.
+  * singal_context is defined at sys/ucontext.h;
+  * Mcontext64 is defined at snapshot/linux/signal_context.h.
+  */
+  typename Traits::SignalThreadContext thread_context;
+
+  LinuxVMAddress gregs_address = context_address +
+                                 offsetof(UContext<Traits>, mcontext) +
+                                 sizeof(thread_context.csr_epc);
+  if (!memory->Read(gregs_address, sizeof(thread_context.regs),
+                    &thread_context.regs)) {
+    LOG(ERROR) << "Couldn't read gregs";
+    return false;
+  }
+
+  LinuxVMAddress pc_address = context_address +
+                              offsetof(UContext<Traits>, mcontext);
+  if (!memory->Read(pc_address, sizeof(thread_context.csr_epc),
+                    &thread_context.csr_epc)) {
+    LOG(ERROR) << "Couldn't read csr_epc";
+    return false;
+  }
+
+  LinuxVMAddress fpregs_address = context_address +
+                                  offsetof(UContext<Traits>, mcontext) +
+                                  offsetof(typename Traits::MContext, fpregs);
+
+  typename Traits::SignalFloatContext fp_context;
+  if (!memory->Read(fpregs_address, sizeof(fp_context), &fp_context)) {
+    LOG(ERROR) << "Couldn't read fpregs";
+    return false;
+  }
+
+  InitializeCPUContextLOONGARCH64(thread_context, fp_context, dest_context);
+
+  return true;
+}
+
+template <>
+bool ExceptionSnapshotLinux::ReadContext<ContextTraits64>(
+    ProcessReaderLinux* reader,
+    LinuxVMAddress context_address) {
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+
+  return internal::ReadContext<ContextTraits64>(
+    reader, context_address, context_.loongarch64);
+}
+
 #endif  // ARCH_CPU_X86_FAMILY
 
 bool ExceptionSnapshotLinux::Initialize(
@@ -397,7 +454,7 @@ bool ExceptionSnapshotLinux::Initialize(
       return false;
     }
   } else {
-#if !defined(ARCH_CPU_RISCV64)
+#if !defined(ARCH_CPU_RISCV64) && !defined(ARCH_CPU_LOONGARCH64)
     if (!ReadContext<ContextTraits32>(process_reader, context_address) ||
         !ReadSiginfo<Traits32>(process_reader, siginfo_address)) {
       return false;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
index f931d33002a..4844ef12fe2 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux.h
@@ -91,6 +91,8 @@ class ExceptionSnapshotLinux final : public ExceptionSnapshot {
     CPUContextMIPS64 mips64;
 #elif defined(ARCH_CPU_RISCV64)
     CPUContextRISCV64 riscv64;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    CPUContextLOONGARCH64 loongarch64;
 #endif
   } context_union_;
   CPUContext context_;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
index b351ccaa7f8..1baf1a58bdd 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/exception_snapshot_linux_test.cc
@@ -297,6 +297,27 @@ void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
             0);
 #undef CPU_ARCH_NAME
 }
+#elif defined(ARCH_CPU_LOONGARCH64)
+using NativeCPUContext = ucontext_t;
+
+void InitializeContext(NativeCPUContext* context) {
+  for (size_t reg = 0; reg < std::size(context->uc_mcontext.__gregs); ++reg) {
+    context->uc_mcontext.__gregs[reg] = reg;
+  }
+  memset(&context->uc_mcontext.__fpregs, 44, sizeof(context->uc_mcontext.__fpregs));
+}
+void ExpectContext(const CPUContext& actual, const NativeCPUContext& expected) {
+#define CPU_ARCH_NAME loongarch64
+  EXPECT_EQ(actual.architecture, kCPUArchitectureLOONGARCH64);
+  for (size_t reg = 0; reg < std::size(expected.uc_mcontext.__gregs); ++reg) {
+    EXPECT_EQ(actual.loongarch64->regs[reg], expected.uc_mcontext.__gregs[reg]);
+  }
+
+  EXPECT_EQ(memcmp(&actual.CPU_ARCH_NAME->fpregs,
+                   &expected.uc_mcontext.__fpregs,
+                   sizeof(actual.CPU_ARCH_NAME->fpregs)),
+            0);
+}
 
 #elif defined(ARCH_CPU_RISCV64)
 using NativeCPUContext = ucontext_t;
diff --git a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
index 45713386d95..3afcd514789 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/process_reader_linux.cc
@@ -129,6 +129,8 @@ void ProcessReaderLinux::Thread::InitializeStack(ProcessReaderLinux* reader) {
                                     : thread_info.thread_context.t32.regs[29];
 #elif defined(ARCH_CPU_RISCV64)
   stack_pointer = thread_info.thread_context.t64.regs[1];
+#elif defined(ARCH_CPU_LOONGARCH64)
+  stack_pointer = thread_info.thread_context.t64.regs[3];
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
index 89e697a08ba..35bc9fe4e4c 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/signal_context.h
@@ -456,6 +456,47 @@ static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
                   offsetof(ucontext_t, uc_mcontext.__fpregs),
               "context offset mismatch");
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+struct MContext64 {
+  uint64_t gregs[32];
+  uint64_t pc;
+  uint32_t flags;
+  uint32_t fcsr;
+  uint32_t _pad[2];
+  uint64_t fcc;
+  double fpregs[32];
+  uint32_t __reserved;
+};
+
+struct ContextTraits64 : public Traits64 {
+  using MContext = MContext64;
+  using SignalThreadContext = ThreadContext::t64_t;
+  using SignalFloatContext = FloatContext::f64_t;
+  using CPUContext = CPUContextLOONGARCH64;
+};
+
+template <typename Traits>
+struct UContext {
+  typename Traits::ULong flags;
+  typename Traits::Address link;
+  SignalStack<Traits> stack;
+  typename Traits::ULong_32Only alignment_padding_;
+  uint64_t _pad_to_64[3];
+  typename Traits::MContext mcontext;
+  Sigset<Traits> sigmask;
+};
+
+static_assert(offsetof(UContext<ContextTraits64>, mcontext) ==
+                  offsetof(ucontext_t, uc_mcontext),
+              "context offset mismtach");
+//static_assert(offsetof(UContext<ContextTraits64>, mcontext.gregs) ==
+//                  offsetof(ucontext_t, uc_mcontext.__gregs),
+//              "context offset mismatch");
+static_assert(offsetof(UContext<ContextTraits64>, mcontext.fpregs) ==
+                  offsetof(ucontext_t, uc_mcontext.__fpregs),
+              "context offset mismatch");
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
index b32f22d784f..f0d8f0f5ed9 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/system_snapshot_linux.cc
@@ -208,6 +208,8 @@ CPUArchitecture SystemSnapshotLinux::GetCPUArchitecture() const {
                                     : kCPUArchitectureMIPSEL;
 #elif defined(ARCH_CPU_RISCV64)
   return kCPUArchitectureRISCV64;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return kCPUArchitectureLOONGARCH64;
 #else
 #error port to your architecture
 #endif
@@ -226,6 +228,8 @@ uint32_t SystemSnapshotLinux::CPURevision() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return 0;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return 0;
 #else
 #error port to your architecture
 #endif
@@ -249,6 +253,8 @@ std::string SystemSnapshotLinux::CPUVendor() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return std::string();
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return std::string();
 #else
 #error port to your architecture
 #endif
@@ -385,6 +391,8 @@ bool SystemSnapshotLinux::NXEnabled() const {
 #elif defined(ARCH_CPU_RISCV64)
   // Not implemented
   return false;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  return false;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
index 85882e8ee46..c0b74d95d69 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.cc
@@ -196,6 +196,13 @@ bool ThreadSnapshotLinux::Initialize(
   InitializeCPUContextRISCV64(thread.thread_info.thread_context.t64,
                               thread.thread_info.float_context.f64,
                               context_.riscv64);
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+  context_.architecture = kCPUArchitectureLOONGARCH64;
+  context_.loongarch64 = &context_union_.loongarch64;
+  InitializeCPUContextLOONGARCH64(
+      thread.thread_info.thread_context.t64,
+      thread.thread_info.float_context.f64,
+      context_.loongarch64);
 #else
 #error Port.
 #endif
diff --git a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
index 5795bfb985a..2f55845282f 100644
--- a/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
+++ b/third_party/crashpad/crashpad/snapshot/linux/thread_snapshot_linux.h
@@ -76,6 +76,8 @@ class ThreadSnapshotLinux final : public ThreadSnapshot {
     CPUContextMIPS64 mips64;
 #elif defined(ARCH_CPU_RISCV64)
     CPUContextRISCV64 riscv64;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    CPUContextLOONGARCH64 loongarch64;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
index ec02dff1266..c4366ccf79f 100644
--- a/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
+++ b/third_party/crashpad/crashpad/snapshot/minidump/minidump_context_converter.cc
@@ -293,6 +293,30 @@ bool MinidumpContextConverter::Initialize(
     memcpy(&context_.riscv64->fpregs, &src->fpregs, sizeof(src->fpregs));
 
     context_.riscv64->fcsr = src->fcsr;
+  } else if (context_.architecture ==
+             CPUArchitecture::kCPUArchitectureLOONGARCH64) {
+    context_memory_.resize(sizeof(CPUContextLOONGARCH64));
+    context_.loongarch64 =
+        reinterpret_cast<CPUContextLOONGARCH64*>(context_memory_.data());
+    const MinidumpContextLOONGARCH64* src =
+        reinterpret_cast<const MinidumpContextLOONGARCH64*>(minidump_context.data());
+    if (minidump_context.size() < sizeof(MinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    if (!(src->context_flags & kMinidumpContextLOONGARCH64)) {
+      return false;
+    }
+
+    for (size_t i = 0; i < std::size(src->regs); i++) {
+      context_.loongarch64->regs[i] = src->regs[i];
+    }
+
+    context_.loongarch64->csr_epc = src->csr_epc;
+    context_.loongarch64->fcsr = src->fcsr;
+    context_.loongarch64->fcc = src->fcc;
+
+    memcpy(&context_.loongarch64->fpregs, &src->fpregs, sizeof(src->fpregs));
   } else {
     // Architecture is listed as "unknown".
     DLOG(ERROR) << "Unknown architecture";
diff --git a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
index 99822946639..6986605ca0c 100644
--- a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
+++ b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.cc
@@ -317,5 +317,30 @@ void InitializeCPUContextRISCV64(CPUContext* context, uint32_t seed) {
   riscv64->fcsr = value++;
 }
 
+void InitializeCPUContextLOONGARCH64(CPUContext* context, uint32_t seed) {
+  context->architecture = kCPUArchitectureLOONGARCH64;
+  CPUContextLOONGARCH64* loongarch64 = context->loongarch64;
+
+  if (seed == 0) {
+    memset(loongarch64, 0, sizeof(*loongarch64));
+    return;
+  }
+
+  uint64_t value = seed;
+
+  for (size_t index = 0; index < std::size(loongarch64->regs); ++index) {
+    loongarch64->regs[index] = value++;
+  }
+
+  loongarch64->csr_epc = value++;
+
+  for (size_t index = 0; index < std::size(loongarch64->fpregs.dregs); ++index) {
+    loongarch64->fpregs.dregs[index] = static_cast<double>(value++);
+  }
+
+  loongarch64->fcsr = value++;
+  loongarch64->fcc = value++;
+}
+
 }  // namespace test
 }  // namespace crashpad
diff --git a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
index 053dec28bc8..ce9184c88cf 100644
--- a/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
+++ b/third_party/crashpad/crashpad/snapshot/test/test_cpu_context.h
@@ -64,6 +64,7 @@ void InitializeCPUContextARM64(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS(CPUContext* context, uint32_t seed);
 void InitializeCPUContextMIPS64(CPUContext* context, uint32_t seed);
 void InitializeCPUContextRISCV64(CPUContext* context, uint32_t seed);
+void InitializeCPUContextLOONGARCH64(CPUContext* context, uint32_t seed);
 //! \}
 
 }  // namespace test
diff --git a/third_party/crashpad/crashpad/test/linux/get_tls.cc b/third_party/crashpad/crashpad/test/linux/get_tls.cc
index 405976eaa9b..f3c9f83cae6 100644
--- a/third_party/crashpad/crashpad/test/linux/get_tls.cc
+++ b/third_party/crashpad/crashpad/test/linux/get_tls.cc
@@ -51,6 +51,9 @@ LinuxVMAddress GetTLS() {
       : "$3");
 #elif defined(ARCH_CPU_RISCV64)
   asm("mv %0, tp" : "=r"(tls));
+#elif defined(ARCH_CPU_LOONGARCH64)
+  asm("move    %0,$tp\n\t"
+      : "=r"(tls) ::);
 #else
 #error Port.
 #endif  // ARCH_CPU_ARMEL
diff --git a/third_party/crashpad/crashpad/util/linux/ptracer.cc b/third_party/crashpad/crashpad/util/linux/ptracer.cc
index a985cb1d1ff..97f3233f6fb 100644
--- a/third_party/crashpad/crashpad/util/linux/ptracer.cc
+++ b/third_party/crashpad/crashpad/util/linux/ptracer.cc
@@ -430,6 +430,48 @@ bool GetThreadArea64(pid_t tid,
   return true;
 }
 
+#elif defined(ARCH_CPU_LOONGARCH64)
+
+bool GetFloatingPointRegisters32(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  return false;
+}
+
+bool GetFloatingPointRegisters64(pid_t tid,
+                                 FloatContext* context,
+                                 bool can_log) {
+  iovec iov;
+  iov.iov_base = context;
+  iov.iov_len = sizeof(*context);
+  if (ptrace(PTRACE_GETREGSET, tid, reinterpret_cast<void*>(NT_PRFPREG), &iov) != 0) {
+    PLOG_IF(ERROR, can_log) << "ptrace";
+    return false;
+  }
+  if (iov.iov_len != sizeof(context->f64)) {
+    LOG_IF(ERROR, can_log) << "Unexpected registers size " << iov.iov_len
+                           << " != " << sizeof(context->f64);
+    return false;
+  }
+
+  return true;
+}
+
+bool GetThreadArea32(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  return false;
+}
+
+bool GetThreadArea64(pid_t tid,
+                     const ThreadContext& context,
+                     LinuxVMAddress* address,
+                     bool can_log) {
+  *address = context.t64.regs[2];
+  return true;
+}
+
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
diff --git a/third_party/crashpad/crashpad/util/linux/thread_info.h b/third_party/crashpad/crashpad/util/linux/thread_info.h
index 808b35a3aff..9e2ad8c4b82 100644
--- a/third_party/crashpad/crashpad/util/linux/thread_info.h
+++ b/third_party/crashpad/crashpad/util/linux/thread_info.h
@@ -85,6 +85,8 @@ union ThreadContext {
     uint32_t cp0_status;
     uint32_t cp0_cause;
     uint32_t padding1_;
+#elif defined(ARCH_CPU_LOONGARCH_FAMILY)
+    // Nothing.
 #elif defined(ARCH_CPU_RISCV64)
     // 32 bit RISC-V not supported
 #else
@@ -144,13 +146,18 @@ union ThreadContext {
     // Reflects user_regs_struct in asm/ptrace.h.
     uint64_t pc;
     uint64_t regs[31];
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // Reflects user_regs_struct in sys/user.h.
+    uint64_t regs[32];
+    uint64_t csr_epc;
+    uint64_t _pad[12];
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
   } t64;
 
 #if defined(ARCH_CPU_X86_FAMILY) || defined(ARCH_CPU_ARM64) || \
-    defined(ARCH_CPU_RISCV64)
+    defined(ARCH_CPU_RISCV64) || defined(ARCH_CPU_LOONGARCH64)
   using NativeThreadContext = user_regs_struct;
 #elif defined(ARCH_CPU_ARMEL)
   using NativeThreadContext = user_regs;
@@ -158,7 +165,7 @@ union ThreadContext {
 // No appropriate NativeThreadsContext type available for MIPS
 #else
 #error Port.
-#endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64 || ARCH_CPU_RISCV64
+#endif  // ARCH_CPU_X86_FAMILY || ARCH_CPU_ARM64 || ARCH_CPU_RISCV64 || ARCH_CPU_LOONARCH64
 
 #if !defined(ARCH_CPU_MIPS_FAMILY)
 #if defined(ARCH_CPU_32_BITS)
@@ -233,6 +240,8 @@ union FloatContext {
     uint32_t fpu_id;
 #elif defined(ARCH_CPU_RISCV64)
     // 32 bit RISC-V not supported
+#elif defined(ARCH_CPU_LOONGARCH64)
+    // Nothing.
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -271,6 +280,11 @@ union FloatContext {
     // Reflects __riscv_d_ext_state in asm/ptrace.h
     uint64_t fpregs[32];
     uint64_t fcsr;
+#elif defined(ARCH_CPU_LOONGARCH64)
+    double fpregs[32];
+    uint32_t fcsr;
+    uint32_t _pad;
+    uint64_t fcc;
 #else
 #error Port.
 #endif  // ARCH_CPU_X86_FAMILY
@@ -298,7 +312,7 @@ union FloatContext {
 #endif
 #elif defined(ARCH_CPU_ARM64)
   static_assert(sizeof(f64) == sizeof(user_fpsimd_struct), "Size mismatch");
-#elif defined(ARCH_CPU_MIPS_FAMILY)
+#elif defined(ARCH_CPU_MIPS_FAMILY) || defined(ARCH_CPU_LOONGARCH_FAMILY)
 // No appropriate floating point context native type for available MIPS.
 #elif defined(ARCH_CPU_RISCV64)
   static_assert(sizeof(f64) == sizeof(__riscv_d_ext_state), "Size mismatch");
diff --git a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
index df63a77296d..a897f865c89 100644
--- a/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
+++ b/third_party/crashpad/crashpad/util/net/http_transport_libcurl.cc
@@ -239,6 +239,8 @@ std::string UserAgent() {
 #endif
 #elif defined (ARCH_CPU_RISCV64)
     static constexpr char arch[] = "riscv64";
+#elif defined(ARCH_CPU_LOONGARCH64)
+    static constexpr char arch[] = "loongarch64";
 #else
 #error Port
 #endif
diff --git a/third_party/ffmpeg/BUILD.gn b/third_party/ffmpeg/BUILD.gn
index 91e2f508c38..72d51dd9f65 100644
--- a/third_party/ffmpeg/BUILD.gn
+++ b/third_party/ffmpeg/BUILD.gn
@@ -313,6 +313,10 @@ target(link_target_type, "ffmpeg_internal") {
         asmflags += [ "-DHAVE_VFP_ARGS=0" ]
       }
     }
+
+    if (current_cpu == "loong64") {
+      cflags += [ "-mlasx", "-mlsx", ]
+    }
   }
 
   if (is_fuchsia || (is_posix && !is_mac)) {
diff --git a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
index f1ed4ce144a..9745b5243bc 100755
--- a/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
+++ b/third_party/ffmpeg/chromium/scripts/build_ffmpeg.py
@@ -20,11 +20,10 @@ import signal
 import subprocess
 import sys
 import tempfile
-from robo_lib import config
 
-ROBO_CONFIGURATION = config.RoboConfiguration()
-FFMPEG_DIR = ROBO_CONFIGURATION.ffmpeg_home()
-CHROMIUM_ROOT_DIR = ROBO_CONFIGURATION.chrome_src()
+SCRIPTS_DIR = os.path.abspath(os.path.dirname(__file__))
+FFMPEG_DIR = os.path.abspath(os.path.join(SCRIPTS_DIR, '..', '..'))
+CHROMIUM_ROOT_DIR = os.path.abspath(os.path.join(FFMPEG_DIR, '..', '..'))
 NDK_ROOT_DIR = os.path.abspath(
     os.path.join(CHROMIUM_ROOT_DIR, 'third_party', 'android_toolchain', 'ndk'))
 # Token to indicate that a build has completed successfully, so that we can
@@ -42,9 +41,7 @@ BRANDINGS = [
 
 ARCH_MAP = {
     'android': ['ia32', 'x64', 'arm-neon', 'arm64'],
-    'linux': [
-        'ia32', 'x64', 'noasm-x64', 'arm', 'arm-neon', 'arm64'
-    ],
+    'linux': ['x64', 'loong64'],
     'mac': ['x64', 'arm64'],
     'win': ['ia32', 'x64', 'arm64'],
 }
@@ -66,12 +63,13 @@ Platform specific build notes:
   linux ia32/x64:
     Script can run on a normal Ubuntu box.
 
-  linux arm/arm-neon/arm64/mipsel/mips64el:
+  linux arm/arm-neon/arm64/mipsel/mips64el/loong64:
     Script can run on a normal Ubuntu with ARM/ARM64 or MIPS32/MIPS64 ready Chromium checkout:
       build/linux/sysroot_scripts/install-sysroot.py --arch=arm
       build/linux/sysroot_scripts/install-sysroot.py --arch=arm64
       build/linux/sysroot_scripts/install-sysroot.py --arch=mips
       build/linux/sysroot_scripts/install-sysroot.py --arch=mips64el
+      build/linux/sysroot_scripts/install-sysroot.py --arch=loong64
 
   mac:
     Script must be run on Linux or macOS.  Additionally, ensure the Chromium
@@ -139,6 +137,8 @@ def DetermineHostOsAndArch():
     host_arch = 'x64'
   elif platform.machine() == 'aarch64':
     host_arch = 'arm64'
+  elif platform.machine() == 'loongarch64':
+    host_arch = 'loong64'
   elif platform.machine() == 'mips32':
     host_arch = 'mipsel'
   elif platform.machine() == 'mips64':
@@ -540,7 +540,7 @@ def BuildFFmpeg(target_os, target_arch, host_os, host_arch, parallel_jobs,
   if target_os == 'mac' and host_os == 'linux':
     RewriteFile(
         os.path.join(config_dir, 'ffbuild/config.mak'), [(r'LD=ld64.lld',
-        r'LD=' + ROBO_CONFIGURATION.get_script_path('fake_linker.py'))])
+        r'LD=' + os.path.join(SCRIPTS_DIR, 'fake_linker.py'))])
 
   # The FFMPEG roll build hits a bug in lld-link that does not impact the
   # overall Chromium build.
@@ -548,7 +548,7 @@ def BuildFFmpeg(target_os, target_arch, host_os, host_arch, parallel_jobs,
   if target_os == 'win' and target_arch == 'arm64' and host_os == 'linux':
     RewriteFile(
         os.path.join(config_dir, 'ffbuild/config.mak'), [(r'LD=lld-link',
-        r'LD=' + ROBO_CONFIGURATION.get_script_path('fake_linker.py'))])
+        r'LD=' + os.path.join(SCRIPTS_DIR, 'fake_linker.py'))])
 
   if target_os in (host_os, host_os + '-noasm', 'android',
                    'win', 'mac') and not config_only:
@@ -921,6 +921,20 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
             '--extra-cflags=--target=mips64el-linux-gnuabi64',
             '--extra-ldflags=--target=mips64el-linux-gnuabi64',
         ])
+    elif target_arch == 'loong64':
+      if target_os == 'linux':
+        configure_flags['Common'].extend([
+            '--enable-cross-compile',
+            '--arch=loongarch64',
+            '--target-os=linux',
+            '--cc=/opt/llvm_chromium/llvm_install_15.0.7/bin/clang',
+            '--cxx=/opt/llvm_chromium/llvm_install_15.0.7/bin/clang++',
+            '--ld=/opt/llvm_chromium/llvm_install_15.0.7/bin/clang',
+            '--sysroot=' + os.path.join(
+                CHROMIUM_ROOT_DIR, 'build/linux/debian_bullseye_loong64-sysroot'),
+            '--extra-cflags=--target=loongarch64-linux-gnu ',
+            '--extra-ldflags=--target=loongarch64-linux-gnu ',
+        ])
     else:
       print(
           'Error: Unknown target arch %r for target OS %r!' % (target_arch,
@@ -935,12 +949,15 @@ def ConfigureAndBuild(target_arch, target_os, host_os, host_arch, parallel_jobs,
     ])
 
   if 'win' not in target_os and 'android' not in target_os:
-    configure_flags['Common'].extend([
-        '--enable-pic',
-        '--cc=clang',
-        '--cxx=clang++',
-        '--ld=clang',
-    ])
+    if target_arch != 'loong64':
+      configure_flags['Common'].extend([
+          '--enable-pic',
+          '--cc=clang',
+          '--cxx=clang++',
+          '--ld=clang',
+      ])
+    else:
+      configure_flags['Common'].extend(['--enable-pic'])
 
     # Clang Linux will use the first 'ld' it finds on the path, which will
     # typically be the system one, so explicitly configure use of Clang's
diff --git a/third_party/ffmpeg/chromium/scripts/copy_config.sh b/third_party/ffmpeg/chromium/scripts/copy_config.sh
index a18048cf040..d8164515208 100755
--- a/third_party/ffmpeg/chromium/scripts/copy_config.sh
+++ b/third_party/ffmpeg/chromium/scripts/copy_config.sh
@@ -10,7 +10,7 @@ for os in android linux linux-noasm mac win; do
     # Copy config files for various architectures:
     #   - ia32/x64 have config.asm, config.h
     #   - arm/arm-neon have config.h
-    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el; do
+    for arch in arm arm-neon arm64 ia32 x64 mipsel mips64el loong64; do
       # Don't waste time on non-existent configs, if no config.h then skip.
       [ ! -e "build.$arch.$os/$target/config.h" ] && continue
       for f in config.h config_components.h config.asm libavutil/avconfig.h libavutil/ffversion.h libavcodec/bsf_list.c libavcodec/codec_list.c libavcodec/parser_list.c libavformat/demuxer_list.c libavformat/muxer_list.c libavformat/protocol_list.c; do
diff --git a/third_party/ffmpeg/chromium/scripts/generate_gn.py b/third_party/ffmpeg/chromium/scripts/generate_gn.py
index 7fd44ec47cc..adfb5a2fccb 100755
--- a/third_party/ffmpeg/chromium/scripts/generate_gn.py
+++ b/third_party/ffmpeg/chromium/scripts/generate_gn.py
@@ -36,10 +36,6 @@ import re
 import shutil
 import subprocess
 import sys
-from robo_lib import config
-
-# The test wrapper doesn't appreciate the status messages.
-ROBO_CONFIGURATION = config.RoboConfiguration(quiet=True)
 
 COPYRIGHT = """# Copyright %d The Chromium Authors. All rights reserved.
 # Use of this source code is governed by a BSD-style license that can be
@@ -82,7 +78,7 @@ _Attrs = ('ARCHITECTURE', 'TARGET', 'PLATFORM')
 Attr = collections.namedtuple('Attr', _Attrs)(*_Attrs)
 SUPPORT_MATRIX = {
     Attr.ARCHITECTURE:
-        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon']),
+        set(['ia32', 'x64', 'arm', 'arm64', 'arm-neon', 'loong64']),
     Attr.TARGET:
         set(['Chromium', 'Chrome', 'ChromeOS']),
     Attr.PLATFORM:
@@ -580,7 +576,7 @@ def ParseOptions():
       '-s',
       '--source_dir',
       dest='source_dir',
-      default=ROBO_CONFIGURATION.ffmpeg_home(),
+      default='.',
       metavar='DIR',
       help='FFmpeg source directory.')
 
@@ -588,7 +584,7 @@ def ParseOptions():
       '-b',
       '--build_dir',
       dest='build_dir',
-      default=ROBO_CONFIGURATION.ffmpeg_home(),
+      default='.',
       metavar='DIR',
       help='Build root containing build.x64.linux, etc...')
 
diff --git a/third_party/lss/linux_syscall_support.h b/third_party/lss/linux_syscall_support.h
index 99a4b444918..fb6d9ec2c28 100644
--- a/third_party/lss/linux_syscall_support.h
+++ b/third_party/lss/linux_syscall_support.h
@@ -322,7 +322,8 @@ struct kernel_old_sigaction {
  * actual number of signals is obviously the same, but the constants
  * differ by one.
  */
-#ifdef __mips__
+// old world for loongarch.
+#if defined(__mips__) || defined(__loongarch_lp64)
 #define KERNEL_NSIG 128
 #else
 #define KERNEL_NSIG  64
@@ -349,7 +350,7 @@ struct kernel_sigaction {
     void             (*sa_sigaction_)(int, siginfo_t *, void *);
   };
   unsigned long      sa_flags;
-#if !defined(__riscv) && !defined(__loongarch_lp64)
+#if !defined(__riscv)
   void               (*sa_restorer)(void);
 #endif
   struct kernel_sigset_t sa_mask;
@@ -747,7 +748,8 @@ struct kernel_statfs64 {
   unsigned long      f_spare[6];
 };
 #endif
-#elif defined(__s390__)
+// old world for loongarch.
+#elif defined(__s390__) || defined(__loongarch_lp64)
 /* See also arch/s390/include/asm/compat.h                                   */
 struct kernel_statfs64 {
   unsigned int       f_type;
@@ -811,7 +813,8 @@ struct kernel_statfs {
   uint64_t           f_frsize;
   uint64_t           f_spare[5];
 };
-#elif defined(__s390__)
+// old world for loongarch.
+#elif defined(__s390__) || defined(__loongarch_lp64)
 struct kernel_statfs {
   unsigned int       f_type;
   unsigned int       f_bsize;
@@ -1308,11 +1311,9 @@ struct kernel_statx {
 #ifndef __NR_readlinkat
 #define __NR_readlinkat          78
 #endif
-#if !defined(__loongarch_lp64)
 #ifndef __NR_newfstatat
 #define __NR_newfstatat          79
 #endif
-#endif
 #ifndef __NR_set_tid_address
 #define __NR_set_tid_address     96
 #endif
@@ -3025,6 +3026,135 @@ struct kernel_statx {
       }
       LSS_RETURN(int, __res);
     }
+  #elif defined(__loongarch_lp64)
+    // old world for loongarch.
+    /* Most definitions of _syscallX() neglect to mark "memory" as being
+     * clobbered. This causes problems with compilers, that do a better job
+     * at optimizing across __asm__ calls.
+     * So, we just have to redefine all of the _syscallX() macros.
+     */
+    #undef LSS_REG
+    #define LSS_REG(ar,a) register int64_t __a##ar __asm__("a"#ar) = (int64_t)a
+    // TODO(loonngson): Recheck LSS_SYSCALL_CLOBBERS for loongarch64
+    /* syscall is like subroutine calls, all caller-saved registers may be
+     * clobbered, we should add them to the |Clobbers| list.
+     * a0 is not included because it's in the output list.
+     */
+    #define LSS_SYSCALL_CLOBBERS "a1", "a2", "a3", "a4", "a5", "a6", "a7",    \
+                                 "t0", "t1", "t2", "t3", "t4", "t5", "t6",    \
+                                 "t7", "t8", "memory"
+    #undef  LSS_BODY
+    #define LSS_BODY(type,name,args...)                                       \
+          register int64_t __res_a0 __asm__("a0");                            \
+          int64_t __res;                                                      \
+          __asm__ __volatile__ ("li.w $a7, %1\n"                                \
+                                "syscall 0x0\n"                               \
+                                : "=r"(__res_a0)                              \
+                                : "i"(__NR_##name) , ## args                  \
+                                : LSS_SYSCALL_CLOBBERS);                      \
+          __res = __res_a0;                                                   \
+	  LSS_RETURN(type, __res)
+    #undef _syscall0
+    #define _syscall0(type, name)                                             \
+      type LSS_NAME(name)(void) {                                             \
+        LSS_BODY(type, name);                                                 \
+      }
+    #undef _syscall1
+    #define _syscall1(type, name, type1, arg1)                                \
+      type LSS_NAME(name)(type1 arg1) {                                       \
+        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__a0));                    \
+      }
+    #undef _syscall2
+    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
+      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
+        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1));                           \
+      }
+    #undef _syscall3
+    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2));                \
+      }
+    #undef _syscall4
+    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4);                                                     \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3));     \
+      }
+    #undef _syscall5
+    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
+                      type5,arg5)                                             \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
+                          type5 arg5) {                                       \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),      \
+                             "r"(__a4));                                      \
+      }
+    #undef _syscall6
+    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
+                      type5,arg5,type6,arg6)                                  \
+      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
+                          type5 arg5, type6 arg6) {                           \
+        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
+        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
+        LSS_BODY(type, name, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),      \
+                             "r"(__a4), "r"(__a5));                           \
+      }
+
+    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
+                                   int flags, void *arg, int *parent_tidptr,
+                                   void *newtls, int *child_tidptr) {
+      int64_t __res;
+      {
+        register uint64_t __flags __asm__("a0") = flags;
+        register void *__stack __asm__("a1") = child_stack;
+        register void *__ptid  __asm__("a2") = parent_tidptr;
+        register void *__tls   __asm__("a3") = newtls;
+        register int  *__ctid  __asm__("a4") = child_tidptr;
+        __asm__ __volatile__(/* Push "arg" and "fn" onto the stack that will be
+                              * used by the child.
+                              */
+                             "addi.d  %2, %2, -16\n"
+                             "st.d    %1, %2, 8\n"
+                             "st.d    %4, %2, 0\n"
+
+                             /* %a0 = syscall(%a0 = flags,
+                              *               %a1 = child_stack,
+                              *               %a2 = parent_tidptr,
+                              *               %a3 = newtls,
+                              *               %a4 = child_tidptr)
+                              */
+                             "li.w      $a7, %8\n"
+                             "syscall    0x0\n"
+
+                             /* if (%a0 != 0)
+                              *   return %a0;
+                              */
+                             "bnez    $a0, 1f\n"
+
+                             /* In the child, now. Call "fn(arg)".
+                              */
+                             "ld.d    $a0, $sp, 0\n"
+                             "ld.d    $a1, $sp, 8\n"
+                             "addi.d  $sp, $sp, 16\n"
+                             "jirl    $ra, $a1, 0\n"
+
+                             /* Call _exit(%a0).
+			      */
+                             "li.w     $a7, %9\n"
+                             "syscall    0x0\n"
+                           "1:\n"
+                             : "=r" (__res)
+                             : "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
+                               "r"(__ptid), "r"(__tls), "r"(__ctid),
+                               "i"(__NR_clone), "i"(__NR_exit)
+                             : LSS_SYSCALL_CLOBBERS);
+      }
+      LSS_RETURN(int, __res);
+    }
   #elif defined(__mips__)
     #undef LSS_REG
     #define LSS_REG(r,a) register unsigned long __r##r __asm__("$"#r) =       \
@@ -3933,134 +4063,6 @@ struct kernel_statx {
                               "b[4]", "b[5]", "pred0");
       LSS_RETURN(int, __res);
     }
-  #elif defined(__loongarch_lp64)
-    /* Most definitions of _syscallX() neglect to mark "memory" as being
-     * clobbered. This causes problems with compilers, that do a better job
-     * at optimizing across __asm__ calls.
-     * So, we just have to redefine all of the _syscallX() macros.
-     */
-    #undef LSS_REG
-    #define LSS_REG(ar,a) register int64_t __r##ar __asm__("a"#ar) = (int64_t)a
-    /* syscall is like subroutine calls, all caller-saved registers may be
-     * clobbered, we should add them to the |Clobbers| list.
-     * a0 is not included because it's in the output list.
-     */
-    #define LSS_SYSCALL_CLOBBERS "t0", "t1", "t2", "t3", "t4", "t5", "t6",    \
-                                 "t7", "t8", "memory"
-    #undef  LSS_BODY
-    #define LSS_BODY(type,name,args...)                                       \
-          register int64_t __res_a0 __asm__("a0");                            \
-          int64_t __res;                                                      \
-          __asm__ __volatile__ ("li.d $a7, %1\n"                              \
-                                "syscall 0x0\n"                               \
-                                : "=r"(__res_a0)                              \
-                                : "i"(__NR_##name) , ## args                  \
-                                : LSS_SYSCALL_CLOBBERS);                      \
-          __res = __res_a0;                                                   \
-          LSS_RETURN(type, __res)
-    #undef _syscall0
-    #define _syscall0(type, name)                                             \
-      type LSS_NAME(name)(void) {                                             \
-        LSS_BODY(type, name);                                                 \
-      }
-    #undef _syscall1
-    #define _syscall1(type, name, type1, arg1)                                \
-      type LSS_NAME(name)(type1 arg1) {                                       \
-        LSS_REG(0, arg1); LSS_BODY(type, name, "r"(__r0));                    \
-      }
-    #undef _syscall2
-    #define _syscall2(type, name, type1, arg1, type2, arg2)                   \
-      type LSS_NAME(name)(type1 arg1, type2 arg2) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1));                           \
-      }
-    #undef _syscall3
-    #define _syscall3(type, name, type1, arg1, type2, arg2, type3, arg3)      \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3) {               \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2));                \
-      }
-    #undef _syscall4
-    #define _syscall4(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4)  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4) {   \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4);                                                     \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3));     \
-      }
-    #undef _syscall5
-    #define _syscall5(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5)                                             \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5) {                                       \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5);                                   \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4));                                      \
-      }
-    #undef _syscall6
-    #define _syscall6(type,name,type1,arg1,type2,arg2,type3,arg3,type4,arg4,  \
-                      type5,arg5,type6,arg6)                                  \
-      type LSS_NAME(name)(type1 arg1, type2 arg2, type3 arg3, type4 arg4,     \
-                          type5 arg5, type6 arg6) {                           \
-        LSS_REG(0, arg1); LSS_REG(1, arg2); LSS_REG(2, arg3);                 \
-        LSS_REG(3, arg4); LSS_REG(4, arg5); LSS_REG(5, arg6);                 \
-        LSS_BODY(type, name, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),      \
-                             "r"(__r4), "r"(__r5));                           \
-      }
-
-    LSS_INLINE int LSS_NAME(clone)(int (*fn)(void *), void *child_stack,
-                                   int flags, void *arg, int *parent_tidptr,
-                                   void *newtls, int *child_tidptr) {
-      int64_t __res;
-      {
-        register int64_t __res_a0 __asm__("a0");
-        register uint64_t __flags __asm__("a0") = flags;
-        register void *__stack __asm__("a1") = child_stack;
-        register void *__ptid  __asm__("a2") = parent_tidptr;
-        register void *__tls   __asm__("a3") = newtls;
-        register int  *__ctid  __asm__("a4") = child_tidptr;
-        __asm__ __volatile__(/* Push "arg" and "fn" onto the stack that will be
-                              * used by the child.
-                              */
-                             "addi.d  %2, %2, -16\n"
-                             "st.d    %1, %2, 8\n"
-                             "st.d    %4, %2, 0\n"
-
-                             /* %a0 = syscall(%a0 = flags,
-                              *               %a1 = child_stack,
-                              *               %a2 = parent_tidptr,
-                              *               %a3 = newtls,
-                              *               %a4 = child_tidptr)
-                              */
-                             "li.d      $a7, %8\n"
-                             "syscall   0x0\n"
-
-                             /* if (%a0 != 0)
-                              *   return %a0;
-                              */
-                             "bnez    $a0, 1f\n"
-
-                             /* In the child, now. Call "fn(arg)".
-                              */
-                             "ld.d    $a0, $sp, 0\n"
-                             "ld.d    $a1, $sp, 8\n"
-                             "addi.d  $sp, $sp, 16\n"
-                             "jirl    $ra, $a1, 0\n"
-
-                             /* Call _exit(%a0).
-                              */
-                             "li.d     $a7, %9\n"
-                             "syscall  0x0\n"
-                           "1:\n"
-                             : "=r" (__res_a0)
-                             : "r"(fn), "r"(__stack), "r"(__flags), "r"(arg),
-                               "r"(__ptid), "r"(__tls), "r"(__ctid),
-                               "i"(__NR_clone), "i"(__NR_exit)
-                             : LSS_SYSCALL_CLOBBERS);
-      __res = __res_a0;
-      }
-      LSS_RETURN(int, __res);
-    }
 
   #endif
   #define __NR__exit   __NR_exit
@@ -5279,7 +5281,7 @@ struct kernel_statx {
 // TODO: define this in an arch-independant way instead of inlining the clone
 //       syscall body.
 
-# if defined(__aarch64__) || defined(__riscv) || defined(__loongarch_lp64)
+# if defined(__aarch64__) || defined(__riscv)
   LSS_INLINE pid_t LSS_NAME(fork)(void) {
     // No fork syscall on aarch64 - implement by means of the clone syscall.
     // Note that this does not reset glibc's cached view of the PID/TID, so
@@ -5298,6 +5300,26 @@ struct kernel_statx {
     LSS_BODY(pid_t, clone, "r"(__r0), "r"(__r1), "r"(__r2), "r"(__r3),
              "r"(__r4));
   }
+# elif defined(__loongarch_lp64)
+  // old world for loongarch.
+  LSS_INLINE pid_t LSS_NAME(fork)(void) {
+    // No fork syscall on aarch64 - implement by means of the clone syscall.
+    // Note that this does not reset glibc's cached view of the PID/TID, so
+    // some glibc interfaces might go wrong in the forked subprocess.
+    int flags = SIGCHLD;
+    void *child_stack = NULL;
+    void *parent_tidptr = NULL;
+    void *newtls = NULL;
+    void *child_tidptr = NULL;
+
+    LSS_REG(0, flags);
+    LSS_REG(1, child_stack);
+    LSS_REG(2, parent_tidptr);
+    LSS_REG(3, newtls);
+    LSS_REG(4, child_tidptr);
+    LSS_BODY(pid_t, clone, "r"(__a0), "r"(__a1), "r"(__a2), "r"(__a3),
+             "r"(__a4));
+  }
 # elif defined(__x86_64__)
   LSS_INLINE pid_t LSS_NAME(fork)(void) {
     // Android disallows the fork syscall on x86_64 - implement by means of the
diff --git a/third_party/pdfium/core/fpdfapi/render/cpdf_imagerenderer.cpp b/third_party/pdfium/core/fpdfapi/render/cpdf_imagerenderer.cpp
index 1efa7e90299..b335eb0ac77 100644
--- a/third_party/pdfium/core/fpdfapi/render/cpdf_imagerenderer.cpp
+++ b/third_party/pdfium/core/fpdfapi/render/cpdf_imagerenderer.cpp
@@ -483,7 +483,7 @@ bool CPDF_ImageRenderer::StartBitmapAlpha() {
         ArgbEncode(0xff, m_BitmapAlpha, m_BitmapAlpha, m_BitmapAlpha);
     m_pRenderStatus->GetRenderDevice()->DrawPath(
         path, nullptr, nullptr, fill_color, 0,
-        {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+	CFX_FillRenderOptions::WindingOptions());
     return false;
   }
   RetainPtr<CFX_DIBBase> pAlphaMask;
diff --git a/third_party/pdfium/core/fpdfapi/render/cpdf_rendershading.cpp b/third_party/pdfium/core/fpdfapi/render/cpdf_rendershading.cpp
index cf1ed0132bb..a34239a2dc0 100644
--- a/third_party/pdfium/core/fpdfapi/render/cpdf_rendershading.cpp
+++ b/third_party/pdfium/core/fpdfapi/render/cpdf_rendershading.cpp
@@ -710,11 +710,11 @@ struct PatchDrawer {
       D2.GetPoints(points.subspan(3, 4));
       C2.GetPointsReverse(points.subspan(6, 4));
       D1.GetPointsReverse(points.subspan(9, 4));
-      const CFX_FillRenderOptions fill_options = {
-          .fill_type = CFX_FillRenderOptions::FillType::kWinding,
-          .aliased_path = bNoPathSmooth,
-          .full_cover = true,
-      };
+      CFX_FillRenderOptions fill_options(
+          CFX_FillRenderOptions::WindingOptions());
+      fill_options.full_cover = true;
+      if (bNoPathSmooth)
+        fill_options.aliased_path = true;
       pDevice->DrawPath(
           path, nullptr, nullptr,
           ArgbEncode(alpha, div_colors[0].comp[0], div_colors[0].comp[1],
diff --git a/third_party/pdfium/core/fpdfapi/render/cpdf_renderstatus.cpp b/third_party/pdfium/core/fpdfapi/render/cpdf_renderstatus.cpp
index d86c2f6f27e..9269365b8e5 100644
--- a/third_party/pdfium/core/fpdfapi/render/cpdf_renderstatus.cpp
+++ b/third_party/pdfium/core/fpdfapi/render/cpdf_renderstatus.cpp
@@ -83,16 +83,19 @@ CFX_FillRenderOptions GetFillOptionsForDrawPathWithBlend(
     CFX_FillRenderOptions::FillType fill_type,
     bool is_stroke,
     bool is_type3_char) {
-  const bool rect_aa = (fill_type != CFX_FillRenderOptions::FillType::kNoFill &&
-                        options.bRectAA);
-  return {
-      .fill_type = fill_type,
-      .adjust_stroke = path_obj->m_GeneralState.GetStrokeAdjust(),
-      .aliased_path = options.bNoPathSmooth,
-      .rect_aa = rect_aa,
-      .stroke = is_stroke,
-      .text_mode = is_type3_char,
-  };
+  CFX_FillRenderOptions fill_options(fill_type);
+  if (fill_type != CFX_FillRenderOptions::FillType::kNoFill && options.bRectAA)
+    fill_options.rect_aa = true;
+  if (options.bNoPathSmooth)
+    fill_options.aliased_path = true;
+  if (path_obj->m_GeneralState.GetStrokeAdjust())
+    fill_options.adjust_stroke = true;
+  if (is_stroke)
+    fill_options.stroke = true;
+  if (is_type3_char)
+    fill_options.text_mode = true;
+
+  return fill_options;
 }
 
 CFX_FillRenderOptions GetFillOptionsForDrawTextPath(
@@ -100,12 +103,17 @@ CFX_FillRenderOptions GetFillOptionsForDrawTextPath(
     const CPDF_TextObject* text_obj,
     bool is_stroke,
     bool is_fill) {
-  return {
-      .adjust_stroke = text_obj->m_GeneralState.GetStrokeAdjust(),
-      .aliased_path = options.bNoTextSmooth,
-      .stroke = (is_stroke && is_fill),
-      .stroke_text_mode = (is_stroke && is_fill),
-  };
+  CFX_FillRenderOptions fill_options;
+  if (is_stroke && is_fill) {
+    fill_options.stroke = true;
+    fill_options.stroke_text_mode = true;
+  }
+  if (text_obj->m_GeneralState.GetStrokeAdjust())
+    fill_options.adjust_stroke = true;
+  if (options.bNoTextSmooth)
+    fill_options.aliased_path = true;
+
+  return fill_options;
 }
 
 FXDIB_Format GetFormatForLuminosity(bool is_luminosity) {
@@ -485,9 +493,8 @@ void CPDF_RenderStatus::ProcessClipPath(const CPDF_ClipPath& ClipPath,
     if (pPath->GetPoints().empty()) {
       CFX_Path empty_path;
       empty_path.AppendRect(-1, -1, 0, 0);
-      m_pDevice->SetClip_PathFill(
-          empty_path, nullptr,
-          {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+      m_pDevice->SetClip_PathFill(empty_path, nullptr,
+                                  CFX_FillRenderOptions::WindingOptions());
     } else {
       m_pDevice->SetClip_PathFill(
           *pPath, &mtObj2Device,
@@ -515,10 +522,9 @@ void CPDF_RenderStatus::ProcessClipPath(const CPDF_ClipPath& ClipPath,
     if (!pTextClippingPath)
       continue;
 
-    const CFX_FillRenderOptions fill_options = {
-        .fill_type = CFX_FillRenderOptions::FillType::kWinding,
-        .aliased_path = m_Options.GetOptions().bNoTextSmooth,
-    };
+    CFX_FillRenderOptions fill_options(CFX_FillRenderOptions::WindingOptions());
+    if (m_Options.GetOptions().bNoTextSmooth)
+      fill_options.aliased_path = true;
     m_pDevice->SetClip_PathFill(*pTextClippingPath, nullptr, fill_options);
     pTextClippingPath.reset();
   }
@@ -545,10 +551,10 @@ bool CPDF_RenderStatus::SelectClipPath(const CPDF_PathObject* path_obj,
                                          &path_matrix,
                                          path_obj->m_GraphState.GetObject());
   }
-  const CFX_FillRenderOptions fill_options = {
-      .fill_type = path_obj->filltype(),
-      .aliased_path = m_Options.GetOptions().bNoPathSmooth,
-  };
+  CFX_FillRenderOptions fill_options(path_obj->filltype());
+  if (m_Options.GetOptions().bNoPathSmooth) {
+    fill_options.aliased_path = true;
+  }
   return m_pDevice->SetClip_PathFill(*path_obj->path().GetObject(),
                                      &path_matrix, fill_options);
 }
diff --git a/third_party/pdfium/core/fxge/cfx_fillrenderoptions.h b/third_party/pdfium/core/fxge/cfx_fillrenderoptions.h
index 3c0a1aed519..de179756c72 100644
--- a/third_party/pdfium/core/fxge/cfx_fillrenderoptions.h
+++ b/third_party/pdfium/core/fxge/cfx_fillrenderoptions.h
@@ -23,6 +23,31 @@ struct CFX_FillRenderOptions {
     kWinding = 2,
   };
 
+#if defined(ARCH_CPU_LOONGARCH64)
+  static constexpr CFX_FillRenderOptions EvenOddOptions() {
+    return CFX_FillRenderOptions(FillType::kEvenOdd);
+  }
+  static constexpr CFX_FillRenderOptions WindingOptions() {
+    return CFX_FillRenderOptions(FillType::kWinding);
+  }
+
+  constexpr CFX_FillRenderOptions()
+    : CFX_FillRenderOptions(FillType::kNoFill) {}
+
+  // TODO(thestig): Switch to default member initializer for bit-fields when
+  // C++20 is available.
+  constexpr explicit CFX_FillRenderOptions(FillType fill_type)
+      : fill_type(fill_type),
+        adjust_stroke(false),
+        aliased_path(false),
+        full_cover(false),
+        rect_aa(false),
+        stroke(false),
+        stroke_text_mode(false),
+        text_mode(false),
+        zero_area(false) {}
+#endif
+
   bool operator==(const CFX_FillRenderOptions& other) const {
     return fill_type == other.fill_type &&
            adjust_stroke == other.adjust_stroke &&
diff --git a/third_party/pdfium/core/fxge/cfx_renderdevice.cpp b/third_party/pdfium/core/fxge/cfx_renderdevice.cpp
index 0d5497fa33e..fdb9163f89e 100644
--- a/third_party/pdfium/core/fxge/cfx_renderdevice.cpp
+++ b/third_party/pdfium/core/fxge/cfx_renderdevice.cpp
@@ -578,11 +578,9 @@ bool CFX_RenderDevice::SetClip_PathStroke(
 bool CFX_RenderDevice::SetClip_Rect(const FX_RECT& rect) {
   CFX_Path path;
   path.AppendRect(rect.left, rect.bottom, rect.right, rect.top);
-  if (!SetClip_PathFill(
-          path, nullptr,
-          {.fill_type = CFX_FillRenderOptions::FillType::kWinding})) {
+  if (!SetClip_PathFill(path, nullptr, CFX_FillRenderOptions::WindingOptions()))
     return false;
-  }
+
   UpdateClipBox();
   return true;
 }
@@ -865,10 +863,10 @@ void CFX_RenderDevice::DrawZeroAreaPath(
   if (matrix && !matrix->IsIdentity() && !set_identity)
     new_matrix = matrix;
 
-  const CFX_FillRenderOptions path_options = {
-      .aliased_path = aliased_path,
-      .zero_area = true,
-  };
+  CFX_FillRenderOptions path_options;
+  path_options.zero_area = true;
+  path_options.aliased_path = aliased_path;
+
   m_pDeviceDriver->DrawPath(new_path, new_matrix, &graph_state, 0, stroke_color,
                             path_options, blend_type);
 }
@@ -1081,9 +1079,8 @@ bool CFX_RenderDevice::DrawNormalText(pdfium::span<const TextCharPos> pCharPos,
   if (fabs(char2device.a) + fabs(char2device.b) > 50 * 1.0f ||
       GetDeviceType() == DeviceType::kPrinter) {
     if (pFont->GetFaceRec()) {
-      const CFX_FillRenderOptions path_options = {
-          .aliased_path = !is_text_smooth,
-      };
+      CFX_FillRenderOptions path_options;
+      path_options.aliased_path = !is_text_smooth;
       return DrawTextPath(pCharPos, pFont, font_size, mtText2Device, nullptr,
                           nullptr, fill_color, 0, nullptr, path_options);
     }
@@ -1224,13 +1221,10 @@ bool CFX_RenderDevice::DrawTextPath(pdfium::span<const TextCharPos> pCharPos,
     CFX_Path transformed_path(*pPath);
     transformed_path.Transform(matrix);
     if (fill_color || stroke_color) {
-      const CFX_FillRenderOptions::FillType fill_type =
-          fill_color ? CFX_FillRenderOptions::FillType::kWinding
-                     : CFX_FillRenderOptions::FillType::kNoFill;
-      const CFX_FillRenderOptions options = {
-          .fill_type = fill_type,
-          .text_mode = true,
-      };
+      CFX_FillRenderOptions options(fill_options);
+      if (fill_color)
+        options.fill_type = CFX_FillRenderOptions::FillType::kWinding;
+      options.text_mode = true;
       if (!DrawPathWithBlend(transformed_path, pUser2Device, pGraphState,
                              fill_color, stroke_color, options,
                              BlendMode::kNormal)) {
@@ -1249,7 +1243,7 @@ void CFX_RenderDevice::DrawFillRect(const CFX_Matrix* pUser2Device,
   CFX_Path path;
   path.AppendFloatRect(rect);
   DrawPath(path, pUser2Device, nullptr, color, 0,
-           {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+	   CFX_FillRenderOptions::WindingOptions());
 }
 
 void CFX_RenderDevice::DrawFillArea(const CFX_Matrix& mtUser2Device,
@@ -1262,7 +1256,7 @@ void CFX_RenderDevice::DrawFillArea(const CFX_Matrix& mtUser2Device,
     path.AppendPoint(points[i], CFX_Path::Point::Type::kLine);
 
   DrawPath(path, &mtUser2Device, nullptr, color, 0,
-           {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	   CFX_FillRenderOptions::EvenOddOptions());
 }
 
 void CFX_RenderDevice::DrawStrokeRect(const CFX_Matrix& mtUser2Device,
@@ -1275,7 +1269,7 @@ void CFX_RenderDevice::DrawStrokeRect(const CFX_Matrix& mtUser2Device,
   CFX_Path path;
   path.AppendFloatRect(rect);
   DrawPath(path, &mtUser2Device, &gsd, 0, color,
-           {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	   CFX_FillRenderOptions::EvenOddOptions());
 }
 
 void CFX_RenderDevice::DrawStrokeLine(const CFX_Matrix* pUser2Device,
@@ -1291,7 +1285,7 @@ void CFX_RenderDevice::DrawStrokeLine(const CFX_Matrix* pUser2Device,
   gsd.m_LineWidth = fWidth;
 
   DrawPath(path, pUser2Device, &gsd, 0, color,
-           {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+           CFX_FillRenderOptions::EvenOddOptions());
 }
 
 void CFX_RenderDevice::DrawFillRect(const CFX_Matrix* pUser2Device,
@@ -1357,7 +1351,7 @@ void CFX_RenderDevice::DrawBorder(const CFX_Matrix* pUser2Device,
       path.AppendRect(fLeft + fWidth, fBottom + fWidth, fRight - fWidth,
                       fTop - fWidth);
       DrawPath(path, pUser2Device, nullptr, color.ToFXColor(nTransparency), 0,
-               {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	       CFX_FillRenderOptions::EvenOddOptions());
       break;
     }
     case BorderStyle::kDash: {
@@ -1378,7 +1372,7 @@ void CFX_RenderDevice::DrawBorder(const CFX_Matrix* pUser2Device,
       path.AppendPoint(CFX_PointF(fLeft + fHalfWidth, fBottom + fHalfWidth),
                        CFX_Path::Point::Type::kLine);
       DrawPath(path, pUser2Device, &gsd, 0, color.ToFXColor(nTransparency),
-               {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+	       CFX_FillRenderOptions::WindingOptions());
       break;
     }
     case BorderStyle::kBeveled:
@@ -1407,7 +1401,7 @@ void CFX_RenderDevice::DrawBorder(const CFX_Matrix* pUser2Device,
           CFX_Path::Point::Type::kLine);
       DrawPath(path_left_top, pUser2Device, &gsd,
                crLeftTop.ToFXColor(nTransparency), 0,
-               {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	       CFX_FillRenderOptions::EvenOddOptions());
 
       CFX_Path path_right_bottom;
       path_right_bottom.AppendPoint(
@@ -1432,14 +1426,14 @@ void CFX_RenderDevice::DrawBorder(const CFX_Matrix* pUser2Device,
           CFX_Path::Point::Type::kLine);
       DrawPath(path_right_bottom, pUser2Device, &gsd,
                crRightBottom.ToFXColor(nTransparency), 0,
-               {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	       CFX_FillRenderOptions::EvenOddOptions());
 
       CFX_Path path;
       path.AppendRect(fLeft, fBottom, fRight, fTop);
       path.AppendRect(fLeft + fHalfWidth, fBottom + fHalfWidth,
                       fRight - fHalfWidth, fTop - fHalfWidth);
       DrawPath(path, pUser2Device, &gsd, color.ToFXColor(nTransparency), 0,
-               {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	       CFX_FillRenderOptions::EvenOddOptions());
       break;
     }
     case BorderStyle::kUnderline: {
@@ -1452,7 +1446,7 @@ void CFX_RenderDevice::DrawBorder(const CFX_Matrix* pUser2Device,
       path.AppendPoint(CFX_PointF(fRight, fBottom + fHalfWidth),
                        CFX_Path::Point::Type::kLine);
       DrawPath(path, pUser2Device, &gsd, 0, color.ToFXColor(nTransparency),
-               {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	       CFX_FillRenderOptions::EvenOddOptions());
       break;
     }
   }
diff --git a/third_party/pdfium/fpdfsdk/cpdfsdk_widget.cpp b/third_party/pdfium/fpdfsdk/cpdfsdk_widget.cpp
index 331bc51aa5c..dee6b90b4e2 100644
--- a/third_party/pdfium/fpdfsdk/cpdfsdk_widget.cpp
+++ b/third_party/pdfium/fpdfsdk/cpdfsdk_widget.cpp
@@ -923,7 +923,7 @@ void CPDFSDK_Widget::DrawAppearance(CFX_RenderDevice* pDevice,
     CFX_Path path;
     path.AppendFloatRect(GetRect());
     pDevice->DrawPath(path, &mtUser2Device, &gsd, 0, 0xFFAAAAAA,
-                      {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+		      CFX_FillRenderOptions::EvenOddOptions());
   } else {
     CPDFSDK_BAAnnot::DrawAppearance(pDevice, mtUser2Device, mode);
   }
diff --git a/third_party/pdfium/fpdfsdk/pwl/cpwl_caret.cpp b/third_party/pdfium/fpdfsdk/pwl/cpwl_caret.cpp
index 2507f4beb76..2d44b7d91d1 100644
--- a/third_party/pdfium/fpdfsdk/pwl/cpwl_caret.cpp
+++ b/third_party/pdfium/fpdfsdk/pwl/cpwl_caret.cpp
@@ -50,7 +50,7 @@ void CPWL_Caret::DrawThisAppearance(CFX_RenderDevice* pDevice,
   CFX_GraphStateData gsd;
   gsd.m_LineWidth = m_fWidth;
   pDevice->DrawPath(path, &mtUser2Device, &gsd, 0, ArgbEncode(255, 0, 0, 0),
-                    {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+		    CFX_FillRenderOptions::EvenOddOptions());
 }
 
 void CPWL_Caret::OnTimerFired() {
diff --git a/third_party/pdfium/fpdfsdk/pwl/cpwl_cbbutton.cpp b/third_party/pdfium/fpdfsdk/pwl/cpwl_cbbutton.cpp
index 0cec5272b37..a35eefdc524 100644
--- a/third_party/pdfium/fpdfsdk/pwl/cpwl_cbbutton.cpp
+++ b/third_party/pdfium/fpdfsdk/pwl/cpwl_cbbutton.cpp
@@ -55,7 +55,7 @@ void CPWL_CBButton::DrawThisAppearance(CFX_RenderDevice* pDevice,
 
   pDevice->DrawPath(path, &mtUser2Device, nullptr,
                     kDefaultBlackColor.ToFXColor(GetTransparency()), 0,
-                    {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+		    CFX_FillRenderOptions::EvenOddOptions());
 }
 
 bool CPWL_CBButton::OnLButtonDown(Mask<FWL_EVENTFLAG> nFlag,
diff --git a/third_party/pdfium/fpdfsdk/pwl/cpwl_edit.cpp b/third_party/pdfium/fpdfsdk/pwl/cpwl_edit.cpp
index c4b02707351..26aad7938d8 100644
--- a/third_party/pdfium/fpdfsdk/pwl/cpwl_edit.cpp
+++ b/third_party/pdfium/fpdfsdk/pwl/cpwl_edit.cpp
@@ -201,7 +201,7 @@ void CPWL_Edit::DrawThisAppearance(CFX_RenderDevice* pDevice,
     if (!path.GetPoints().empty()) {
       pDevice->DrawPath(
           path, &mtUser2Device, &gsd, 0, GetBorderColor().ToFXColor(255),
-          {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+	  CFX_FillRenderOptions::EvenOddOptions());
     }
   }
 
diff --git a/third_party/pdfium/fpdfsdk/pwl/cpwl_edit_impl.cpp b/third_party/pdfium/fpdfsdk/pwl/cpwl_edit_impl.cpp
index 30b78ef6041..144c7e7e952 100644
--- a/third_party/pdfium/fpdfsdk/pwl/cpwl_edit_impl.cpp
+++ b/third_party/pdfium/fpdfsdk/pwl/cpwl_edit_impl.cpp
@@ -644,7 +644,7 @@ void CPWL_EditImpl::DrawEdit(CFX_RenderDevice* pDevice,
 
           pDevice->DrawPath(
               pathSelBK, &mtUser2Device, nullptr, crSelBK, 0,
-              {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+	      CFX_FillRenderOptions::WindingOptions());
         }
       }
       if (bContinuous) {
diff --git a/third_party/pdfium/fxbarcode/BC_TwoDimWriter.cpp b/third_party/pdfium/fxbarcode/BC_TwoDimWriter.cpp
index 708699ae588..81dc61eac60 100644
--- a/third_party/pdfium/fxbarcode/BC_TwoDimWriter.cpp
+++ b/third_party/pdfium/fxbarcode/BC_TwoDimWriter.cpp
@@ -89,8 +89,7 @@ void CBC_TwoDimWriter::RenderDeviceResult(CFX_RenderDevice* device,
   CFX_Path path;
   path.AppendRect(0, 0, m_Width, m_Height);
   device->DrawPath(path, &matrix, &stateData, kBackgroundColor,
-                   kBackgroundColor,
-                   {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+		   kBackgroundColor, CFX_FillRenderOptions::EvenOddOptions());
   int32_t leftPos = m_leftPadding;
   int32_t topPos = m_topPadding;
 
@@ -121,7 +120,7 @@ void CBC_TwoDimWriter::RenderDeviceResult(CFX_RenderDevice* device,
                         topPos + end_y_output * m_multiY);
         device->DrawPath(
             rect, &matri, &data, kBarColor, 0,
-            {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+	    CFX_FillRenderOptions::WindingOptions());
       }
     }
   }
diff --git a/third_party/pdfium/fxbarcode/oned/BC_OneDimWriter.cpp b/third_party/pdfium/fxbarcode/oned/BC_OneDimWriter.cpp
index 7c2604a27fb..fce8163e1b9 100644
--- a/third_party/pdfium/fxbarcode/oned/BC_OneDimWriter.cpp
+++ b/third_party/pdfium/fxbarcode/oned/BC_OneDimWriter.cpp
@@ -237,15 +237,14 @@ bool CBC_OneDimWriter::RenderDeviceResult(CFX_RenderDevice* device,
   path.AppendRect(0, 0, static_cast<float>(m_Width),
                   static_cast<float>(m_Height));
   device->DrawPath(path, &matrix, &stateData, kBackgroundColor,
-                   kBackgroundColor,
-                   {.fill_type = CFX_FillRenderOptions::FillType::kEvenOdd});
+		   kBackgroundColor, CFX_FillRenderOptions::EvenOddOptions());
   CFX_Matrix scaledMatrix(m_outputHScale, 0.0, 0.0,
                           static_cast<float>(m_Height), 0.0, 0.0);
   scaledMatrix.Concat(matrix);
   for (const auto& rect : m_output) {
     CFX_GraphStateData data;
     device->DrawPath(rect, &scaledMatrix, &data, kBarColor, 0,
-                     {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+		     CFX_FillRenderOptions::WindingOptions());
   }
 
   return m_locTextLoc == BC_TEXT_LOC::kNone || !contents.Contains(' ') ||
diff --git a/third_party/pdfium/xfa/fgas/graphics/cfgas_gegraphics.cpp b/third_party/pdfium/xfa/fgas/graphics/cfgas_gegraphics.cpp
index ecac51a0ead..6f255d688e2 100644
--- a/third_party/pdfium/xfa/fgas/graphics/cfgas_gegraphics.cpp
+++ b/third_party/pdfium/xfa/fgas/graphics/cfgas_gegraphics.cpp
@@ -221,7 +221,7 @@ void CFGAS_GEGraphics::RenderDeviceFillPath(
   CFX_Matrix m = m_info.CTM;
   m.Concat(matrix);
 
-  const CFX_FillRenderOptions fill_options = {.fill_type = fill_type};
+  const CFX_FillRenderOptions fill_options(fill_type);
   switch (m_info.fillColor.GetType()) {
     case CFGAS_GEColor::Solid:
       m_renderDevice->DrawPath(path.GetPath(), &m, &m_info.graphState,
diff --git a/third_party/pdfium/xfa/fxfa/cxfa_ffwidget.cpp b/third_party/pdfium/xfa/fxfa/cxfa_ffwidget.cpp
index 0a456dde120..74b1cb26a66 100644
--- a/third_party/pdfium/xfa/fxfa/cxfa_ffwidget.cpp
+++ b/third_party/pdfium/xfa/fxfa/cxfa_ffwidget.cpp
@@ -120,8 +120,8 @@ void XFA_DrawImage(CFGAS_GEGraphics* pGS,
   CFX_RenderDevice::StateRestorer restorer(pRenderDevice);
   CFX_Path path;
   path.AppendRect(rtImage.left, rtImage.bottom(), rtImage.right(), rtImage.top);
-  pRenderDevice->SetClip_PathFill(
-      path, &matrix, {.fill_type = CFX_FillRenderOptions::FillType::kWinding});
+  pRenderDevice->SetClip_PathFill(path, &matrix,
+                                  CFX_FillRenderOptions::WindingOptions());
 
   CFX_Matrix mtImage(1, 0, 0, -1, 0, 1);
   mtImage.Concat(
diff --git a/third_party/protobuf/src/google/protobuf/port_def.inc b/third_party/protobuf/src/google/protobuf/port_def.inc
index 8cc16a6ecef..24ad0b6b97c 100644
--- a/third_party/protobuf/src/google/protobuf/port_def.inc
+++ b/third_party/protobuf/src/google/protobuf/port_def.inc
@@ -235,7 +235,7 @@
 #endif
 #if __has_cpp_attribute(clang::musttail) && !defined(__arm__) && \
     !defined(_ARCH_PPC) && !defined(__wasm__) &&                 \
-    !(defined(_MSC_VER) && defined(_M_IX86))
+    !(defined(_MSC_VER) && defined(_M_IX86)) && !defined(__loongarch__)
 #  ifndef PROTO2_OPENSOURCE
 // Compilation fails on ARM32: b/195943306
 // Compilation fails on powerpc64le: b/187985113
diff --git a/third_party/skia/BUILD.gn b/third_party/skia/BUILD.gn
index ed36df78dc4..a3b909703be 100644
--- a/third_party/skia/BUILD.gn
+++ b/third_party/skia/BUILD.gn
@@ -1532,6 +1532,7 @@ skia_component("skia") {
 
   defines = []
   libs = []
+  deps += [ "//base:npapi_buildflags" ]
 
   if (skia_enable_sksl_tracing) {
     defines += [ "SKSL_ENABLE_TRACING" ]
diff --git a/third_party/skia/src/core/SkRasterPipeline.h b/third_party/skia/src/core/SkRasterPipeline.h
index dc5fb4b8f24..b04bcee9b3b 100644
--- a/third_party/skia/src/core/SkRasterPipeline.h
+++ b/third_party/skia/src/core/SkRasterPipeline.h
@@ -24,7 +24,7 @@ enum SkColorType : int;
 struct SkImageInfo;
 struct skcms_TransferFunction;
 
-#if __has_cpp_attribute(clang::musttail) && !defined(__EMSCRIPTEN__) && !defined(SK_CPU_ARM32)
+#if __has_cpp_attribute(clang::musttail) && !defined(__EMSCRIPTEN__) && !defined(SK_CPU_ARM32) && !defined(__loongarch__)
     #define SK_HAS_MUSTTAIL 1
 #else
     #define SK_HAS_MUSTTAIL 0
diff --git a/third_party/swiftshader/src/Reactor/reactor.gni b/third_party/swiftshader/src/Reactor/reactor.gni
index 04fad6f8119..37f638c32ae 100644
--- a/third_party/swiftshader/src/Reactor/reactor.gni
+++ b/third_party/swiftshader/src/Reactor/reactor.gni
@@ -10,7 +10,7 @@ import("//build_overrides/build.gni")
 
 declare_args() {
   # Subzero doesn't support ARM64, MIPS64, PPC64, and RISCV64 (only x86 and ARMv7a).
-  supports_subzero = current_cpu != "arm64" && current_cpu != "mips64el" && current_cpu != "ppc64" && current_cpu != "riscv64"
+  supports_subzero = current_cpu != "arm64" && current_cpu != "mips64el" && current_cpu != "ppc64" && current_cpu != "riscv64" && current_cpu != "loong64"
 }
 
 declare_args() {
diff --git a/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn b/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
index 59e52303c5c..82764b0e1b9 100644
--- a/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
+++ b/third_party/swiftshader/third_party/llvm-10.0/BUILD.gn
@@ -158,6 +158,8 @@ swiftshader_llvm_source_set("swiftshader_llvm") {
     deps += [ ":swiftshader_llvm_riscv64" ]
   } else if (current_cpu == "x86" || current_cpu == "x64") {
     deps += [ ":swiftshader_llvm_x86" ]
+  } else if (current_cpu == "loong64") {
+    deps += [ ":swiftshader_llvm_loong64" ]
   } else {
     assert(false, "Unsupported current_cpu")
   }
@@ -1330,6 +1332,11 @@ swiftshader_llvm_source_set("swiftshader_llvm_x86") {
   ]
 }
 
+swiftshader_llvm_source_set("swiftshader_llvm_loong64") {
+  # TODO: Add support llvm-10 for loongarch.
+  sources = []
+}
+
 swiftshader_llvm_source_set("swiftshader_llvm_riscv64") {
   sources = [
     "llvm/lib/Target/RISCV/AsmParser/RISCVAsmParser.cpp",
diff --git a/third_party/swiftshader/third_party/llvm-subzero/include/llvm/Support/ELF.h b/third_party/swiftshader/third_party/llvm-subzero/include/llvm/Support/ELF.h
index d951e552f7d..3ec51712675 100644
--- a/third_party/swiftshader/third_party/llvm-subzero/include/llvm/Support/ELF.h
+++ b/third_party/swiftshader/third_party/llvm-subzero/include/llvm/Support/ELF.h
@@ -310,6 +310,7 @@ enum {
   EM_RISCV = 243,         // RISC-V
   EM_LANAI = 244,         // Lanai 32-bit processor
   EM_BPF = 247,           // Linux kernel bpf virtual machine
+  EM_LOONGARCH = 258,     // Loongson LOONGARCH
 
   // A request has been made to the maintainer of the official registry for
   // such numbers for an official value for WebAssembly. As soon as one is
diff --git a/third_party/webrtc/rtc_base/system/arch.h b/third_party/webrtc/rtc_base/system/arch.h
index 9d945ef7fc1..43011710177 100644
--- a/third_party/webrtc/rtc_base/system/arch.h
+++ b/third_party/webrtc/rtc_base/system/arch.h
@@ -74,13 +74,13 @@
 #define WEBRTC_ARCH_32_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
 #elif defined(__loongarch32)
-#define WEBRTC_ARCH_LOONG_FAMILY
-#define WEBRTC_ARCH_LOONG32
+#define WEBRTC_ARCH_LOONGARCH_FAMILY
+#define WEBRTC_ARCH_LOONGARCH32
 #define WEBRTC_ARCH_32_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
-#elif defined(__loongarch64)
-#define WEBRTC_ARCH_LOONG_FAMILY
-#define WEBRTC_ARCH_LOONG64
+#elif defined(__loongarch_lp64)
+#define WEBRTC_ARCH_LOONGARCH_FAMILY
+#define WEBRTC_ARCH_LOONGARCH64
 #define WEBRTC_ARCH_64_BITS
 #define WEBRTC_ARCH_LITTLE_ENDIAN
 #elif defined(__pnacl__)
diff --git a/ui/base/wayland/color_manager_util.cc b/ui/base/wayland/color_manager_util.cc
index 4401542d57a..2081f61a51b 100644
--- a/ui/base/wayland/color_manager_util.cc
+++ b/ui/base/wayland/color_manager_util.cc
@@ -4,80 +4,58 @@
 
 #include "ui/base/wayland/color_manager_util.h"
 
-#include <cstdint>
-
-#include "chrome-color-management-server-protocol.h"
-
 namespace ui::wayland {
 
 zcr_color_manager_v1_chromaticity_names ToColorManagerChromaticity(
-    gfx::ColorSpace::PrimaryID primaryID,
-    uint32_t version) {
+    gfx::ColorSpace::PrimaryID primaryID) {
   for (const auto& it : kChromaticityMap) {
-    if (it.second.primary == primaryID) {
-      if (it.second.version <= version) {
-        return it.first;
-      }
-      return ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT709;
-    }
+    if (it.second == primaryID)
+      return it.first;
   }
   return ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_UNKNOWN;
 }
 
 zcr_color_manager_v1_matrix_names ToColorManagerMatrix(
-    gfx::ColorSpace::MatrixID matrixID,
-    uint32_t version) {
+    gfx::ColorSpace::MatrixID matrixID) {
   for (const auto& it : kMatrixMap) {
-    if (it.second.matrix == matrixID) {
-      if (it.second.version <= version) {
-        return it.first;
-      }
-      return ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_RGB;
+    if (it.second == matrixID) {
+      return it.first;
     }
   }
   return ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_UNKNOWN;
 }
 
 zcr_color_manager_v1_range_names ToColorManagerRange(
-    gfx::ColorSpace::RangeID rangeID,
-    uint32_t version) {
+    gfx::ColorSpace::RangeID rangeID) {
   for (const auto& it : kRangeMap) {
-    if (it.second.range == rangeID) {
-      if (it.second.version <= version) {
-        return it.first;
-      }
-      return ZCR_COLOR_MANAGER_V1_RANGE_NAMES_FULL;
+    if (it.second == rangeID) {
+      return it.first;
     }
   }
   return ZCR_COLOR_MANAGER_V1_RANGE_NAMES_UNKNOWN;
 }
 
 zcr_color_manager_v1_eotf_names ToColorManagerEOTF(
-    gfx::ColorSpace::TransferID transferID,
-    uint32_t version) {
+    gfx::ColorSpace::TransferID transferID) {
   for (const auto& it : kEotfMap) {
-    if (it.second.transfer == transferID) {
-      if (it.second.version <= version) {
-        return it.first;
-      }
-      return ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB;
-    }
+    if (it.second == transferID)
+      return it.first;
   }
   return ZCR_COLOR_MANAGER_V1_EOTF_NAMES_UNKNOWN;
 }
 
-zcr_color_manager_v1_eotf_names ToColorManagerEOTF(gfx::ColorSpace color_space,
-                                                   uint32_t version) {
+zcr_color_manager_v1_eotf_names ToColorManagerEOTF(
+    gfx::ColorSpace color_space) {
   if (color_space.IsHDR()) {
     for (const auto& it : kHDRTransferMap) {
-      if (color_space.IsTransferFunctionEqualTo(it.second.transfer_fn)) {
-        if (it.second.version <= version) {
-          return it.first;
-        }
-        return ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB;
-      }
+      if (color_space.IsTransferFunctionEqualTo(it.second))
+        return it.first;
     }
   }
-  return ToColorManagerEOTF(color_space.GetTransferID(), version);
+  for (const auto& it : kTransferMap) {
+    if (color_space.IsTransferFunctionEqualTo(it.second))
+      return it.first;
+  }
+  return ZCR_COLOR_MANAGER_V1_EOTF_NAMES_UNKNOWN;
 }
 }  // namespace ui::wayland
diff --git a/ui/base/wayland/color_manager_util.h b/ui/base/wayland/color_manager_util.h
index 2efa825b2a5..8e56700792a 100644
--- a/ui/base/wayland/color_manager_util.h
+++ b/ui/base/wayland/color_manager_util.h
@@ -16,270 +16,124 @@ namespace ui::wayland {
 
 // A 2.4 gamma for the BT2087 transfer function.
 static constexpr skcms_TransferFunction gamma24 = {2.4f, 1.f};
-constexpr uint32_t kDefaultSinceVersion = 1;
-
-// These structs are used for holding ColorSpace enums, and the version of the
-// color management protocol their support was introduced.
-struct TransferFnVersion {
-  skcms_TransferFunction transfer_fn;
-  uint32_t version;
-};
-
-struct TransferVersion {
-  gfx::ColorSpace::TransferID transfer;
-  uint32_t version;
-};
-
-struct PrimaryVersion {
-  gfx::ColorSpace::PrimaryID primary;
-  uint32_t version;
-};
-
-struct MatrixVersion {
-  gfx::ColorSpace::MatrixID matrix;
-  uint32_t version;
-};
-
-struct RangeVersion {
-  gfx::ColorSpace::RangeID range;
-  uint32_t version;
-};
 
 // A map from the zcr_color_manager_v1 chromaticity_names enum values
 // representing well-known chromaticities, to their equivalent PrimaryIDs.
 // See components/exo/wayland/protocol/chrome-color-management.xml
-constexpr auto kChromaticityMap = base::MakeFixedFlatMap<
-    zcr_color_manager_v1_chromaticity_names,
-    PrimaryVersion>(
-    {{ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT601_525_LINE,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::SMPTE170M,
-                     kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT601_625_LINE,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT470BG,
-                     kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTE170M,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::SMPTE170M,
-                     kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT709,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT709, kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT2020,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT2020, kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SRGB,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::BT709, kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_DISPLAYP3,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::P3, kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_ADOBERGB,
-      PrimaryVersion(gfx::ColorSpace::PrimaryID::ADOBE_RGB,
-                     kDefaultSinceVersion)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_WIDE_GAMUT_COLOR_SPIN,
-      PrimaryVersion(
-          gfx::ColorSpace::PrimaryID::WIDE_GAMUT_COLOR_SPIN,
-          ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_WIDE_GAMUT_COLOR_SPIN_SINCE_VERSION)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT470M,
-      PrimaryVersion(
-          gfx::ColorSpace::PrimaryID::BT470M,
-          ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT470M_SINCE_VERSION)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTE240M,
-      PrimaryVersion(
-          gfx::ColorSpace::PrimaryID::SMPTE240M,
-          ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTE240M_SINCE_VERSION)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_XYZ_D50,
-      PrimaryVersion(
-          gfx::ColorSpace::PrimaryID::XYZ_D50,
-          ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_XYZ_D50_SINCE_VERSION)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST428_1,
-      PrimaryVersion(
-          gfx::ColorSpace::PrimaryID::SMPTEST428_1,
-          ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST428_1_SINCE_VERSION)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST431_2,
-      PrimaryVersion(
-          gfx::ColorSpace::PrimaryID::SMPTEST431_2,
-          ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTEST431_2_SINCE_VERSION)},
-     {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_FILM,
-      PrimaryVersion(
-          gfx::ColorSpace::PrimaryID::FILM,
-          ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_FILM_SINCE_VERSION)}});
+constexpr auto kChromaticityMap =
+    base::MakeFixedFlatMap<zcr_color_manager_v1_chromaticity_names,
+                           gfx::ColorSpace::PrimaryID>(
+        {{ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT601_525_LINE,
+          gfx::ColorSpace::PrimaryID::SMPTE170M},
+         {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT601_625_LINE,
+          gfx::ColorSpace::PrimaryID::BT470BG},
+         {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SMPTE170M,
+          gfx::ColorSpace::PrimaryID::SMPTE170M},
+         {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT709,
+          gfx::ColorSpace::PrimaryID::BT709},
+         {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_BT2020,
+          gfx::ColorSpace::PrimaryID::BT2020},
+         {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_SRGB,
+          gfx::ColorSpace::PrimaryID::BT709},
+         {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_DISPLAYP3,
+          gfx::ColorSpace::PrimaryID::P3},
+         {ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_ADOBERGB,
+          gfx::ColorSpace::PrimaryID::ADOBE_RGB}});
 
 // A map from the zcr_color_manager_v1 eotf_names enum values
 // representing well-known EOTFs, to their equivalent TransferIDs.
 // See components/exo/wayland/protocol/chrome-color-management.xml
-constexpr auto kEotfMap = base::MakeFixedFlatMap<
-    zcr_color_manager_v1_eotf_names,
-    TransferVersion>({
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR,
-     TransferVersion(gfx::ColorSpace::TransferID::LINEAR,
-                     kDefaultSinceVersion)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB,
-     TransferVersion(gfx::ColorSpace::TransferID::SRGB, kDefaultSinceVersion)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB_HDR,
-     TransferVersion(gfx::ColorSpace::TransferID::SRGB_HDR,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB_HDR_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709,
-     TransferVersion(gfx::ColorSpace::TransferID::BT709,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2087,
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA24,
-                     kDefaultSinceVersion)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_ADOBERGB,
-     // This is ever so slightly inaccurate. The number ought to be
-     // 2.19921875f, not 2.2
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA22,
-                     kDefaultSinceVersion)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_PQ,
-     TransferVersion(gfx::ColorSpace::TransferID::PQ, kDefaultSinceVersion)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG,
-     TransferVersion(gfx::ColorSpace::TransferID::HLG,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE170M,
-     TransferVersion(gfx::ColorSpace::TransferID::SMPTE170M,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE170M_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE240M,
-     TransferVersion(gfx::ColorSpace::TransferID::SMPTE240M,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTE240M_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTEST428_1,
-     TransferVersion(
-         gfx::ColorSpace::TransferID::SMPTEST428_1,
-         ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SMPTEST428_1_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG,
-     TransferVersion(gfx::ColorSpace::TransferID::LOG,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG_SQRT,
-     TransferVersion(gfx::ColorSpace::TransferID::LOG_SQRT,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LOG_SQRT_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_IEC61966_2_4,
-     TransferVersion(
-         gfx::ColorSpace::TransferID::IEC61966_2_4,
-         ZCR_COLOR_MANAGER_V1_EOTF_NAMES_IEC61966_2_4_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT1361_ECG,
-     TransferVersion(gfx::ColorSpace::TransferID::BT1361_ECG,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT1361_ECG_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_10,
-     TransferVersion(gfx::ColorSpace::TransferID::BT2020_10,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_10_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_12,
-     TransferVersion(gfx::ColorSpace::TransferID::BT2020_12,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2020_12_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SCRGB_LINEAR_80_NITS,
-     TransferVersion(
-         gfx::ColorSpace::TransferID::SCRGB_LINEAR_80_NITS,
-         ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SCRGB_LINEAR_80_NITS_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA18,
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA18,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA18_SINCE_VERSION)},
-    {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA28,
-     TransferVersion(gfx::ColorSpace::TransferID::GAMMA28,
-                     ZCR_COLOR_MANAGER_V1_EOTF_NAMES_GAMMA28_SINCE_VERSION)},
-});
+constexpr auto kEotfMap =
+    base::MakeFixedFlatMap<zcr_color_manager_v1_eotf_names,
+                           gfx::ColorSpace::TransferID>({
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR,
+         gfx::ColorSpace::TransferID::LINEAR},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB,
+         gfx::ColorSpace::TransferID::SRGB},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709,
+         gfx::ColorSpace::TransferID::BT709},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2087,
+         gfx::ColorSpace::TransferID::GAMMA24},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_ADOBERGB,
+         // This is ever so slightly inaccurate. The number ought to be
+         // 2.19921875f, not 2.2
+         gfx::ColorSpace::TransferID::GAMMA22},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_PQ, gfx::ColorSpace::TransferID::PQ},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG, gfx::ColorSpace::TransferID::HLG},
+    });
 
 // A map from the SDR zcr_color_manager_v1 eotf_names enum values
 // representing well-known EOTFs, to their equivalent transfer functions.
 // See components/exo/wayland/protocol/chrome-color-management.xml
 constexpr auto kTransferMap =
-    base::MakeFixedFlatMap<zcr_color_manager_v1_eotf_names, TransferFnVersion>({
-        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR,
-         TransferFnVersion(SkNamedTransferFn::kLinear, kDefaultSinceVersion)},
-        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB,
-         TransferFnVersion(SkNamedTransferFnExt::kSRGB, kDefaultSinceVersion)},
-        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709,
-         TransferFnVersion(
-             SkNamedTransferFnExt::kRec709,
-             ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709_SINCE_VERSION)},
-        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2087,
-         TransferFnVersion(gamma24, kDefaultSinceVersion)},
+    base::MakeFixedFlatMap<zcr_color_manager_v1_eotf_names,
+                           skcms_TransferFunction>({
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR, SkNamedTransferFn::kLinear},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB, SkNamedTransferFnExt::kSRGB},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709, SkNamedTransferFnExt::kRec709},
+        {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT2087, gamma24},
         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_ADOBERGB,
-         TransferFnVersion(SkNamedTransferFnExt::kA98RGB,
-                           kDefaultSinceVersion)},
+         SkNamedTransferFnExt::kA98RGB},
     });
 
 // A map from the HDR zcr_color_manager_v1 eotf_names enum values
 // representing well-known EOTFs, to their equivalent transfer functions.
 // See components/exo/wayland/protocol/chrome-color-management.xml
 constexpr auto kHDRTransferMap =
-    base::MakeFixedFlatMap<zcr_color_manager_v1_eotf_names, TransferFnVersion>(
-        {{ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR,
-          TransferFnVersion(SkNamedTransferFn::kLinear, kDefaultSinceVersion)},
-         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB_HDR,
-          TransferFnVersion(
-              SkNamedTransferFnExt::kSRGB,
-              ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB_HDR_SINCE_VERSION)},
-         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_PQ,
-          TransferFnVersion(SkNamedTransferFn::kPQ, kDefaultSinceVersion)},
-         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG,
-          TransferFnVersion(SkNamedTransferFn::kHLG,
-                            ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG_SINCE_VERSION)},
+    base::MakeFixedFlatMap<zcr_color_manager_v1_eotf_names,
+                           skcms_TransferFunction>(
+        {{ZCR_COLOR_MANAGER_V1_EOTF_NAMES_LINEAR, SkNamedTransferFn::kLinear},
+         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_SRGB, SkNamedTransferFnExt::kSRGB},
+         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_PQ, SkNamedTransferFn::kPQ},
+         {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_HLG, SkNamedTransferFn::kHLG},
          {ZCR_COLOR_MANAGER_V1_EOTF_NAMES_EXTENDEDSRGB10,
-          TransferFnVersion(
-              SkNamedTransferFnExt::kSRGBExtended1023Over510,
-              ZCR_COLOR_MANAGER_V1_EOTF_NAMES_EXTENDEDSRGB10_SINCE_VERSION)}});
+          SkNamedTransferFnExt::kSRGBExtended1023Over510}});
 
 // A map from zcr_color_manager_v1 matrix_names enum values to
 // gfx::ColorSpace::MatrixIDs.
 constexpr auto kMatrixMap =
-    base::MakeFixedFlatMap<zcr_color_manager_v1_matrix_names, MatrixVersion>(
+    base::MakeFixedFlatMap<zcr_color_manager_v1_matrix_names,
+                           gfx::ColorSpace::MatrixID>(
         {{ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_RGB,
-          MatrixVersion(gfx::ColorSpace::MatrixID::RGB, kDefaultSinceVersion)},
+          gfx::ColorSpace::MatrixID::RGB},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT709,
-          MatrixVersion(gfx::ColorSpace::MatrixID::BT709,
-                        kDefaultSinceVersion)},
-         {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT470BG,
-          MatrixVersion(
-              gfx::ColorSpace::MatrixID::BT470BG,
-              ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT470BG_SINCE_VERSION)},
+          gfx::ColorSpace::MatrixID::BT709},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT2020_NCL,
-          MatrixVersion(gfx::ColorSpace::MatrixID::BT2020_NCL,
-                        kDefaultSinceVersion)},
+          gfx::ColorSpace::MatrixID::BT2020_NCL},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_BT2020_CL,
-          MatrixVersion(gfx::ColorSpace::MatrixID::BT2020_CL,
-                        kDefaultSinceVersion)},
+          gfx::ColorSpace::MatrixID::BT2020_CL},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_FCC,
-          MatrixVersion(gfx::ColorSpace::MatrixID::FCC, kDefaultSinceVersion)},
-         {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YCOCG,
-          MatrixVersion(gfx::ColorSpace::MatrixID::YCOCG,
-                        ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YCOCG_SINCE_VERSION)},
-         {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YDZDX,
-          MatrixVersion(gfx::ColorSpace::MatrixID::YDZDX,
-                        ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_YDZDX_SINCE_VERSION)},
-         {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_GBR,
-          MatrixVersion(gfx::ColorSpace::MatrixID::GBR,
-                        ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_GBR_SINCE_VERSION)},
+          gfx::ColorSpace::MatrixID::FCC},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_SMPTE170M,
-          MatrixVersion(gfx::ColorSpace::MatrixID::SMPTE170M,
-                        kDefaultSinceVersion)},
+          gfx::ColorSpace::MatrixID::SMPTE170M},
          {ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_SMPTE240M,
-          MatrixVersion(gfx::ColorSpace::MatrixID::SMPTE240M,
-                        kDefaultSinceVersion)}});
+          gfx::ColorSpace::MatrixID::SMPTE240M}});
 
 // A map from zcr_color_manager_v1 range_names enum values to
 // gfx::ColorSpace::RangeIDs.
 constexpr auto kRangeMap =
-    base::MakeFixedFlatMap<zcr_color_manager_v1_range_names, RangeVersion>(
+    base::MakeFixedFlatMap<zcr_color_manager_v1_range_names,
+                           gfx::ColorSpace::RangeID>(
         {{ZCR_COLOR_MANAGER_V1_RANGE_NAMES_LIMITED,
-          RangeVersion(gfx::ColorSpace::RangeID::LIMITED,
-                       kDefaultSinceVersion)},
+          gfx::ColorSpace::RangeID::LIMITED},
          {ZCR_COLOR_MANAGER_V1_RANGE_NAMES_FULL,
-          RangeVersion(gfx::ColorSpace::RangeID::FULL, kDefaultSinceVersion)},
+          gfx::ColorSpace::RangeID::FULL},
          {ZCR_COLOR_MANAGER_V1_RANGE_NAMES_DERIVED,
-          RangeVersion(gfx::ColorSpace::RangeID::DERIVED,
-                       kDefaultSinceVersion)}});
+          gfx::ColorSpace::RangeID::DERIVED}});
 
 zcr_color_manager_v1_chromaticity_names ToColorManagerChromaticity(
-    gfx::ColorSpace::PrimaryID primaryID,
-    uint32_t version);
+    gfx::ColorSpace::PrimaryID primaryID);
 
 zcr_color_manager_v1_matrix_names ToColorManagerMatrix(
-    gfx::ColorSpace::MatrixID matrixID,
-    uint32_t version);
+    gfx::ColorSpace::MatrixID matrixID);
 
 zcr_color_manager_v1_range_names ToColorManagerRange(
-    gfx::ColorSpace::RangeID rangeID,
-    uint32_t version);
+    gfx::ColorSpace::RangeID rangeID);
 
 zcr_color_manager_v1_eotf_names ToColorManagerEOTF(
-    gfx::ColorSpace::TransferID transferID,
-    uint32_t version);
+    gfx::ColorSpace::TransferID transferID);
 
-zcr_color_manager_v1_eotf_names ToColorManagerEOTF(gfx::ColorSpace color_space,
-                                                   uint32_t version);
+zcr_color_manager_v1_eotf_names ToColorManagerEOTF(gfx::ColorSpace color_space);
 
 }  // namespace ui::wayland
 
diff --git a/ui/gfx/linux/drm_util_linux.cc b/ui/gfx/linux/drm_util_linux.cc
index 6714f488a21..498ae75a243 100644
--- a/ui/gfx/linux/drm_util_linux.cc
+++ b/ui/gfx/linux/drm_util_linux.cc
@@ -8,6 +8,16 @@
 
 #include "base/notreached.h"
 
+#if defined(__loongarch_lp64)
+// libdrm-dev
+#ifndef DRM_FORMAT_P010
+#define DRM_FORMAT_P010 fourcc_code('P', '0', '1', '0')
+#endif
+#ifndef DRM_FORMAT_ABGR16161616F
+#define DRM_FORMAT_ABGR16161616F fourcc_code('A', 'B', '4', 'H')
+#endif
+#endif
+
 namespace ui {
 
 int GetFourCCFormatFromBufferFormat(gfx::BufferFormat format) {
diff --git a/ui/gtk/gtk_ui.cc b/ui/gtk/gtk_ui.cc
index ce42101bdec..206673a3881 100644
--- a/ui/gtk/gtk_ui.cc
+++ b/ui/gtk/gtk_ui.cc
@@ -1013,11 +1013,13 @@ ui::DisplayConfig GtkUi::GetDisplayConfig() const {
     GdkRectangle geometry;
     gdk_monitor_get_geometry(monitor, &geometry);
     int monitor_scale = std::max(1, gdk_monitor_get_scale_factor(monitor));
-    config.display_geometries.emplace_back(
+    ui::DisplayGeometry display_geometry;
+    display_geometry.bounds_px = 
         gfx::Rect(monitor_scale * geometry.x, monitor_scale * geometry.y,
                   monitor_scale * geometry.width,
-                  monitor_scale * geometry.height),
-        monitor_scale * font_scale);
+                  monitor_scale * geometry.height);
+    display_geometry.scale = monitor_scale * font_scale;
+    config.display_geometries.emplace_back(display_geometry);
   }
   return config;
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_zcr_color_manager.cc b/ui/ozone/platform/wayland/host/wayland_zcr_color_manager.cc
index fd3b253d7a2..3dbaaa25924 100644
--- a/ui/ozone/platform/wayland/host/wayland_zcr_color_manager.cc
+++ b/ui/ozone/platform/wayland/host/wayland_zcr_color_manager.cc
@@ -107,35 +107,28 @@ void WaylandZcrColorManager::OnColorSpaceCreated(
 wl::Object<zcr_color_space_creator_v1>
 WaylandZcrColorManager::CreateZcrColorSpaceCreator(
     const gfx::ColorSpace& color_space) {
-  auto eotf = wayland::ToColorManagerEOTF(
-      color_space, zcr_color_manager_v1_get_version(zcr_color_manager_.get()));
+  auto eotf = wayland::ToColorManagerEOTF(color_space);
   if (eotf == ZCR_COLOR_MANAGER_V1_EOTF_NAMES_UNKNOWN) {
     LOG(WARNING) << "Attempt to create color space from"
                  << " unsupported or invalid TransferID: "
                  << color_space.ToString() << ".";
     eotf = ZCR_COLOR_MANAGER_V1_EOTF_NAMES_BT709;
   }
-  auto matrix = wayland::ToColorManagerMatrix(
-      color_space.GetMatrixID(),
-      zcr_color_manager_v1_get_version(zcr_color_manager_.get()));
+  auto matrix = wayland::ToColorManagerMatrix(color_space.GetMatrixID());
   if (matrix == ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_UNKNOWN) {
     LOG(WARNING) << "Attempt to create color space from"
                  << " unsupported or invalid MatrixID: "
                  << color_space.ToString();
     matrix = ZCR_COLOR_MANAGER_V1_MATRIX_NAMES_RGB;
   }
-  auto range = wayland::ToColorManagerRange(
-      color_space.GetRangeID(),
-      zcr_color_manager_v1_get_version(zcr_color_manager_.get()));
+  auto range = wayland::ToColorManagerRange(color_space.GetRangeID());
   if (range == ZCR_COLOR_MANAGER_V1_RANGE_NAMES_UNKNOWN) {
     LOG(WARNING) << "Attempt to create color space from"
                  << " unsupported or invalid RangeID: "
                  << color_space.ToString();
     range = ZCR_COLOR_MANAGER_V1_RANGE_NAMES_FULL;
   }
-  auto chromaticity = wayland::ToColorManagerChromaticity(
-      color_space.GetPrimaryID(),
-      zcr_color_manager_v1_get_version(zcr_color_manager_.get()));
+  auto chromaticity = wayland::ToColorManagerChromaticity(color_space.GetPrimaryID());
   if (chromaticity != ZCR_COLOR_MANAGER_V1_CHROMATICITY_NAMES_UNKNOWN) {
     if (zcr_color_manager_v1_get_version(zcr_color_manager_.get()) <
         ZCR_COLOR_SPACE_V1_COMPLETE_NAMES_SINCE_VERSION) {
diff --git a/ui/ozone/platform/wayland/host/wayland_zcr_color_space.cc b/ui/ozone/platform/wayland/host/wayland_zcr_color_space.cc
index 7e1c74b14d7..75639413da6 100644
--- a/ui/ozone/platform/wayland/host/wayland_zcr_color_space.cc
+++ b/ui/ozone/platform/wayland/host/wayland_zcr_color_space.cc
@@ -96,20 +96,20 @@ void WaylandZcrColorSpace::OnCompleteNames(void* data,
   auto* self = static_cast<WaylandZcrColorSpace*>(data);
   DCHECK(self);
   auto primaryID = ui::wayland::kChromaticityMap.contains(chromaticity)
-                       ? ui::wayland::kChromaticityMap.at(chromaticity).primary
+                       ? ui::wayland::kChromaticityMap.at(chromaticity)
                        : gfx::ColorSpace::PrimaryID::INVALID;
   auto matrixID = ui::wayland::kMatrixMap.contains(matrix)
-                      ? ui::wayland::kMatrixMap.at(matrix).matrix
+                      ? ui::wayland::kMatrixMap.at(matrix)
                       : gfx::ColorSpace::MatrixID::INVALID;
   auto rangeID = ui::wayland::kRangeMap.contains(range)
-                     ? ui::wayland::kRangeMap.at(range).range
+                     ? ui::wayland::kRangeMap.at(range)
                      : gfx::ColorSpace::RangeID::INVALID;
   auto transferID = ui::wayland::kEotfMap.contains(eotf)
-                        ? ui::wayland::kEotfMap.at(eotf).transfer
+                        ? ui::wayland::kEotfMap.at(eotf)
                         : gfx::ColorSpace::TransferID::INVALID;
   if (transferID == gfx::ColorSpace::TransferID::INVALID &&
       wayland::kHDRTransferMap.contains(eotf)) {
-    auto transfer_fn = ui::wayland::kHDRTransferMap.at(eotf).transfer_fn;
+    auto transfer_fn = ui::wayland::kHDRTransferMap.at(eotf);
     self->gathered_information[static_cast<uint8_t>(InformationType::kNames)] =
         gfx::ColorSpace(primaryID, gfx::ColorSpace::TransferID::CUSTOM_HDR,
                         matrixID, rangeID, nullptr, &transfer_fn);
@@ -152,17 +152,17 @@ void WaylandZcrColorSpace::OnCompleteParams(void* data,
   }
 
   auto matrixID = ui::wayland::kMatrixMap.contains(matrix)
-                      ? ui::wayland::kMatrixMap.at(matrix).matrix
+                      ? ui::wayland::kMatrixMap.at(matrix)
                       : gfx::ColorSpace::MatrixID::INVALID;
   auto rangeID = ui::wayland::kRangeMap.contains(range)
-                     ? ui::wayland::kRangeMap.at(range).range
+                     ? ui::wayland::kRangeMap.at(range)
                      : gfx::ColorSpace::RangeID::INVALID;
   auto transferID = ui::wayland::kEotfMap.contains(eotf)
-                        ? ui::wayland::kEotfMap.at(eotf).transfer
+                        ? ui::wayland::kEotfMap.at(eotf)
                         : gfx::ColorSpace::TransferID::INVALID;
   if (transferID == gfx::ColorSpace::TransferID::INVALID &&
       ui::wayland::kHDRTransferMap.contains(eotf)) {
-    auto transfer_fn = ui::wayland::kHDRTransferMap.at(eotf).transfer_fn;
+    auto transfer_fn = ui::wayland::kHDRTransferMap.at(eotf);
     self->gathered_information[static_cast<uint8_t>(InformationType::kParams)] =
         gfx::ColorSpace(gfx::ColorSpace::PrimaryID::CUSTOM,
                         gfx::ColorSpace::TransferID::CUSTOM_HDR, matrixID,
-- 
2.25.1

